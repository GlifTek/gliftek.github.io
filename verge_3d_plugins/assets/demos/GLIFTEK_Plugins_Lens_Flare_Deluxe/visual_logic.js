/**
 * Generated by Verge3D Puzzles v.3.8.0 pre4
 * Sun Aug 22 2021 18:14:50 GMT-0400 (Eastern Daylight Time)
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */

'use strict';

(function() {

// global variables/constants used by puzzles' functions

var LIST_NONE = '<none>';

var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster();

var PL = v3d.PL = v3d.PL || {};

// a more readable alias for PL (stands for "Puzzle Logic")
v3d.puzzles = PL;

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        }
    }

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    this.procedures["INIT"] = INIT;
this.procedures["SET_BG_GRADIENT"] = SET_BG_GRADIENT;
this.procedures["LOAD_BG_SKY_IMAGE_GRADIENT"] = LOAD_BG_SKY_IMAGE_GRADIENT;

    var PROC = {
    "INIT": INIT,
    "SET_BG_GRADIENT": SET_BG_GRADIENT,
    "LOAD_BG_SKY_IMAGE_GRADIENT": LOAD_BG_SKY_IMAGE_GRADIENT,
};

var color_1, EXEC_load_bg, color_2, bg_gradient;

// Describe this function...
function INIT() {
  LOAD_BG_SKY_IMAGE_GRADIENT();
}


// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}



// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}


// Describe this function...
function SET_BG_GRADIENT() {
  color_1 = '#0d427b';
  color_2 = ' #dc8f17';
  bg_gradient = ['linear-gradient(',color_1,',',color_2,')'].join('');
  console.log('bg-gradient: ' + String(bg_gradient));
  setHTMLElemStyle('backgroundImage', bg_gradient, ['CONTAINER'], true);
}

// Describe this function...
function LOAD_BG_SKY_IMAGE_GRADIENT() {
  EXEC_load_bg = ('// var bgTexture = new THREE.TextureLoader().load("images/background/space.png");' + '\n' +
  '// bgTexture.minFilter = THREE.LinearFilter;' + '\n' +
  '// scene.background = bgTexture;' + '\n' +
  'var bgTexture = new THREE.TextureLoader()' + '\n' +
  '.load(window.gliftek_SVGs.lensflare.bg_sky_gradient);' + '\n' +
  '' + '\n' +
  'bgTexture.minFilter = THREE.LinearFilter;' + '\n' +
  'app.scene.background = bgTexture;');
  var VARS = Object.defineProperties({}, {
    "color_1": { get: function() { return color_1; }, set: function(val) { color_1 = val; } },
    "EXEC_load_bg": { get: function() { return EXEC_load_bg; }, set: function(val) { EXEC_load_bg = val; } },
    "color_2": { get: function() { return color_2; }, set: function(val) { color_2 = val; } },
    "bg-gradient": { get: function() { return bg_gradient; }, set: function(val) { bg_gradient = val; } },
});

  Function('app', 'v3d', 'VARS', 'PROC', EXEC_load_bg)(appInstance, v3d, VARS, PROC);

}



// initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = true;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = false;
_initGlob.output.initOptions.useFullscreen = true;

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["CAMERA_CONSTRAINTS"] = CAMERA_CONSTRAINTS;
this.procedures["MAIN"] = MAIN;
this.procedures["FADE_IN"] = FADE_IN;
this.procedures["INIT_ALL_LENS_FLARE_SETTINGS"] = INIT_ALL_LENS_FLARE_SETTINGS;
this.procedures["INIT_RAYS_SETTINGS"] = INIT_RAYS_SETTINGS;
this.procedures["INIT_GLOW_SETTINGS"] = INIT_GLOW_SETTINGS;
this.procedures["INIT_BOKEH_SETTINGS"] = INIT_BOKEH_SETTINGS;
this.procedures["LENS_FLARE_DELUXE"] = LENS_FLARE_DELUXE;

var PROC = {
    "CAMERA_CONSTRAINTS": CAMERA_CONSTRAINTS,
    "MAIN": MAIN,
    "FADE_IN": FADE_IN,
    "INIT_ALL_LENS_FLARE_SETTINGS": INIT_ALL_LENS_FLARE_SETTINGS,
    "INIT_RAYS_SETTINGS": INIT_RAYS_SETTINGS,
    "INIT_GLOW_SETTINGS": INIT_GLOW_SETTINGS,
    "INIT_BOKEH_SETTINGS": INIT_BOKEH_SETTINGS,
    "LENS_FLARE_DELUXE": LENS_FLARE_DELUXE,
};

var LFD_RAYS_Settings, LFD_GLOW_Settings, LFD_BOKEH_Settings;


function screenFade() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        screenFade_ID_Input,
        screenFade_Z_Index_Input,
        typeDropdown,
        screenFade_Pause_Input,
        screenFade_Duration_Input,
        colorInput_1_PICKER,
        colorInput_1_TEXT,
        delete_When_Done_Checkbox,
        whenDone_Statement_Input,
    )
    {   //  BEGIN Plug.provide Function


//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Print To Modal Card';

        eval(`window.${screenFade_ID_Input} = { faded: null };`);

//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !screenFade_ID_Input ) {
            console.log('[ GLIFTEK ]: The',puzzleName, 'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

        // mainFunction();
        function mainFunction()
        {

//________________________________________________________________________________
//  PUZZLE CORE CODE


            function setColorFromInputs(colorInput_TEXT, colorInput_PICKER)
            {
                let colorInput_esc;

                if ( typeof colorInput_TEXT == 'undefined' || typeof colorInput_TEXT == null || colorInput_TEXT == '' )
                {
                    // colorInput_esc = colorInput_PICKER.substring(1);
                    colorInput_esc = colorInput_PICKER;
                    console.log(colorInput_PICKER,'supplied. using PICKER.');
                }
                else
                {
                    // colorInput_esc = colorInput_TEXT.substring(1);
                    colorInput_esc = colorInput_TEXT;
                    console.log(colorInput_TEXT,'supplied. using TEXT.');
                }

                return colorInput_esc
            };

            const colorInput_1esc = setColorFromInputs(colorInput_1_TEXT, colorInput_1_PICKER);

            console.log('colorInput_1esc:',colorInput_1esc);




            let computedColorDiv = document.createElement("div");
            computedColorDiv.id = 'computedColorDiv-' + screenFade_ID_Input;
            document.body.appendChild(computedColorDiv);



            function RGBA_from_color_input(color,alpha)
            {
                if
                (
                        color == 'transparent'
                    ||  color == null
                    ||  typeof color == 'undefined'
                )
                {
                    return 'rgba(0, 0, 0, 0)';
                }
                else
                {
                    computedColorDiv.style.color = color;
                    let computedColor = window.getComputedStyle(computedColorDiv).color;

                    console.log('computedColor for: ',color,':',computedColor);

                    let len = computedColor.length;
                    let computedColor_RGBA =
                    'rgba(' + computedColor.substring(4, len-1) + ", " + alpha +')';

                    console.log('computedColor_RGBA for: ',color,':',computedColor_RGBA);

                    return computedColor_RGBA;
                };
            };


            const screenFadeColor = RGBA_from_color_input ( colorInput_1esc, 1 );
            console.log('screenFadeColor: ',screenFadeColor);

            computedColorDiv.remove();


//________________________________________________________________________________
//  SET CSS


            let styleVar = setstyleVar();  //  sets all modal styles

            let style = document.createElement('style');

            style.id = 'screenFade-' + screenFade_ID_Input;

            style.innerHTML = styleVar;

            document.head.appendChild(style);



//________________________________________________________________________________
//  MAKE SCREEN FADE DIV


            let screenFade_Div = document.createElement('div');

            screenFade_Div.id = screenFade_ID_Input;

            screenFade_Div.className = 'screenFade-' + screenFade_ID_Input;



            getBGcolor();

            function getBGcolor()
            {
                if ( typeDropdown  == 'in' )
                    {
                        screenFade_Div.style.backgroundColor = 'rgba(0,0,0,0)';
                        console.log('screenFade_Div.style.backgroundColor:',screenFade_Div.style.backgroundColor);
                    }
                    else if ( typeDropdown  == 'out' )
                    {
                        screenFade_Div.style.backgroundColor = screenFadeColor;
                        console.log('screenFade_Div.style.backgroundColor:',screenFade_Div.style.backgroundColor);
                    }

            }



            const container = document.getElementById('v3d-container');

            container.appendChild(screenFade_Div);



//________________________________________________________________________________
//  SCREEN FADE ANIMATION

            setTimeout(function(){ animateScreenFade(); }, ( screenFade_Pause_Input * 1000 ) );


            function animateScreenFade()
            {
                const animationType = 'animation-screen-fade-' + typeDropdown + '-' + screenFade_ID_Input;

                screenFade_Div.style.animationName = animationType;

                console.log('screenFade_Div.style.animationName:',screenFade_Div.style.animationName);

                screenFade_Div.addEventListener('animationend', function(event)

                {
                    if ( event.animationName == animationType );
                    {
                        screenFade_Div.removeEventListener('animationend',null);

                        screenFadeDisplay();

                        let screenFadeState = eval(`${screenFade_ID_Input}.faded = '${typeDropdown}';`);
                        console.log('screenFadeState:',screenFadeState);

                        whenDone_Statement_Input();
                    }
                });


                function screenFadeDisplay()
                {
                    if ( typeDropdown  == 'in' )
                    {
                        screenFade_Div.style.display = 'block';
                        console.log('screenFade_Div.style.display:',screenFade_Div.style.display);
                        deleteWhenDone();
                    }
                    else if ( typeDropdown  == 'out' )
                    {
                        screenFade_Div.style.display = 'none';
                        console.log('screenFade_Div.style.display:',screenFade_Div.style.display);
                        deleteWhenDone();
                    }

                }

                function deleteWhenDone()
                {
                    if ( delete_When_Done_Checkbox == true )
                    {
                        screenFade_Div.remove();
                    }
                }

            };

//________________________________________________________________________________
//  SCREEN FADE DIV CSS

            function setstyleVar()
            {
                let result =
                `
                #computedColorDiv-${screenFade_ID_Input}
                {
                    height: 0px;
                    width: 0px;
                    display: none;
                    z-index = -10;
                }

                .screenFade-${screenFade_ID_Input}
                {
                    display: block;
                    position: fixed;
                    z-index: ${screenFade_Z_Index_Input};
                    left: 0;
                    top: 0;
                    height: 100%;
                    width: 100%;
                    overflow: hidden;
                    pointer-events: none;

                    animation-duration: ${screenFade_Duration_Input}s;
                    animation-timing-function: ease-in-out;
                }


                @keyframes animation-screen-fade-in-${screenFade_ID_Input}
                {
                    from {
                        background-color: rgba(0,0,0,0);
                    }
                    to {
                        background-color: ${screenFadeColor};
                    }
                }


                @keyframes animation-screen-fade-out-${screenFade_ID_Input}
                {
                    from {
                        background-color: ${screenFadeColor};
                    }
                    to {
                        background-color: rgba(0,0,0,0);
                    }
                }

                `;

                return result;
            };

//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function FADE_IN() {

          screenFade
          (
              'screenFade_1',
              10,
              'out',
              1.5,
              1,
              '#000000',
              '',
              true,
              function() {},
          )
      }


function setImageBackground() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        // sundiskCheckbox,
        imageURLInput,
    )
    {   //  BEGIN Plug.provide Function


//________________________________________________________________________________
//  MAIN FUNCTION

        mainFunction();
        function mainFunction()
        {

//________________________________________________________________________________
//  PUZZLE CORE CODE

            let bgTexture = new THREE.TextureLoader()
            .load(imageURLInput);

            bgTexture.minFilter = THREE.LinearFilter;

            app.scene.background = bgTexture;

            app.scene.background.encoding = THREE.sRGBEncoding;

//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}




// utility function envoked by almost all V3D-specific puzzles
// filter off some non-mesh types
function notIgnoredObj(obj) {
    return obj.type !== 'AmbientLight' &&
           obj.name !== '' &&
           !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
           !obj.isAuxClippingMesh;
}


// utility function envoked by almost all V3D-specific puzzles
// find first occurence of the object by its name
function getObjectByName(objName) {
    var objFound;
    var runTime = _pGlob !== undefined;
    objFound = runTime ? _pGlob.objCache[objName] : null;

    if (objFound && objFound.name === objName)
        return objFound;

    appInstance.scene.traverse(function(obj) {
        if (!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
            objFound = obj;
            if (runTime) {
                _pGlob.objCache[objName] = objFound;
            }
        }
    });
    return objFound;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects on the scene
function getAllObjectNames() {
    var objNameList = [];
    appInstance.scene.traverse(function(obj) {
        if (notIgnoredObj(obj))
            objNameList.push(obj.name)
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects which belong to the group
function getObjectNamesByGroupName(targetGroupName) {
    var objNameList = [];
    appInstance.scene.traverse(function(obj){
        if (notIgnoredObj(obj)) {
            var groupNames = obj.groupNames;
            if (!groupNames)
                return;
            for (var i = 0; i < groupNames.length; i++) {
                var groupName = groupNames[i];
                if (groupName == targetGroupName) {
                    objNameList.push(obj.name);
                }
            }
        }
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// process object input, which can be either single obj or array of objects, or a group
function retrieveObjectNames(objNames) {
    var acc = [];
    retrieveObjectNamesAcc(objNames, acc);
    return acc.filter(function(name) {
        return name;
    });
}

function retrieveObjectNamesAcc(currObjNames, acc) {
    if (typeof currObjNames == "string") {
        acc.push(currObjNames);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
        var newObj = getObjectNamesByGroupName(currObjNames[1]);
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "ALL_OBJECTS") {
        var newObj = getAllObjectNames();
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames)) {
        for (var i = 0; i < currObjNames.length; i++)
            retrieveObjectNamesAcc(currObjNames[i], acc);
    }
}





/**
 * Retrieve coordinate system from the loaded scene
 */
function getCoordSystem() {
    var scene = appInstance.scene;

    if (scene && "v3d" in scene.userData && "coordSystem" in scene.userData.v3d) {
        return scene.userData.v3d.coordSystem;
    } else {
        // COMPAT: <2.17, consider replacing to 'Y_UP_RIGHT' for scenes with unknown origin
        return 'Z_UP_RIGHT';
    }
}


/**
 * Transform coordinates from one space to another
 * Can be used with Vector3 or Euler.
 */
function coordsTransform(coords, from, to, noSignChange) {

    if (from == to)
        return coords;

    var y = coords.y, z = coords.z;

    if (from == 'Z_UP_RIGHT' && to == 'Y_UP_RIGHT') {
        coords.y = z;
        coords.z = noSignChange ? y : -y;
    } else if (from == 'Y_UP_RIGHT' && to == 'Z_UP_RIGHT') {
        coords.y = noSignChange ? z : -z;
        coords.z = y;
    } else {
        console.error('coordsTransform: Unsupported coordinate space');
    }

    return coords;
}


/**
 * Verge3D euler rotation to Blender/Max shortest.
 * 1) Convert from intrinsic rotation (v3d) to extrinsic XYZ (Blender/Max default
 *    order) via reversion: XYZ -> ZYX
 * 2) swizzle ZYX->YZX
 * 3) choose the shortest rotation to resemble Blender's behavior
 */
var eulerV3DToBlenderShortest = function() {

    var eulerTmp = new v3d.Euler();
    var eulerTmp2 = new v3d.Euler();
    var vec3Tmp = new v3d.Vector3();

    return function(euler, dest) {

        var eulerBlender = eulerTmp.copy(euler).reorder('YZX');
        var eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();

        var len = eulerBlender.toVector3(vec3Tmp).lengthSq();
        var lenAlt = eulerBlenderAlt.toVector3(vec3Tmp).lengthSq();

        dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
        return coordsTransform(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
    }

}();




function RotationInterface() {
    /**
     * For user manipulations use XYZ extrinsic rotations (which
     * are the same as ZYX intrinsic rotations)
     *     - Blender/Max/Maya use extrinsic rotations in the UI
     *     - XYZ is the default option, but could be set from
     *       some order hint if exported
     */
    this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
    this._actualRotation = new v3d.Euler();
}

Object.assign(RotationInterface, {
    initObject: function(obj) {
        if (obj.userData.v3d.puzzles === undefined) {
            obj.userData.v3d.puzzles = {}
        }
        if (obj.userData.v3d.puzzles.rotationInterface === undefined) {
            obj.userData.v3d.puzzles.rotationInterface = new RotationInterface();
        }

        var rotUI = obj.userData.v3d.puzzles.rotationInterface;
        rotUI.updateFromObject(obj);
        return rotUI;
    }
});

Object.assign(RotationInterface.prototype, {

    updateFromObject: function(obj) {
        var SYNC_ROT_EPS = 1e-8;

        if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
            this._actualRotation.copy(obj.rotation);
            this._updateUserRotFromActualRot();
        }
    },

    getActualRotation: function(euler) {
        return euler.copy(this._actualRotation);
    },

    setUserRotation: function(euler) {
        // don't copy the order, since it's fixed to ZYX for now
        this._userRotation.set(euler.x, euler.y, euler.z);
        this._updateActualRotFromUserRot();
    },

    getUserRotation: function(euler) {
        return euler.copy(this._userRotation);
    },

    _updateUserRotFromActualRot: function() {
        var order = this._userRotation.order;
        this._userRotation.copy(this._actualRotation).reorder(order);
    },

    _updateActualRotFromUserRot: function() {
        var order = this._actualRotation.order;
        this._actualRotation.copy(this._userRotation).reorder(order);
    }

});




// setObjTransform puzzle
function setObjTransform(objSelector, mode, vector, offset){
    var x = vector[0];
      var y = vector[1];
      var z = vector[2];

    var objNames = retrieveObjectNames(objSelector);

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    var inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''),
            Number(z !== ''));
    var coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.MathUtils.DEG2RAD);
    }

    var coordSystem = getCoordSystem();

    coordsTransform(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    coordsTransform(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (var i = 0; i < objNames.length; i++) {

        var objName = objNames[i];
        if (!objName) continue;

        var obj = getObjectByName(objName);
        if (!obj) continue;

        if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            var euler = eulerV3DToBlenderShortest(obj.rotation, _pGlob.eulerTmp);
            coordsTransform(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            var rotUI = RotationInterface.initObject(obj);
            var euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

        }

        obj.updateMatrixWorld(true);
    }

}



// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {
    var camera = appInstance.getCamera();

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = coordsTransform(worldPos, getCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = coordsTransform(worldTarget, getCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(worldPos);
        }
        camera.position.copy(worldPos);
        camera.lookAt(worldTarget);
        doSlot();
    }
}


// Describe this function...
function MAIN() {
  FADE_IN();

          setImageBackground
          (
              './img/bg_clouds_godrays_02.jpg',
          )
      setObjTransform('Lens_Flare_Point_Light', 'position', [2.75, 224638.07, 7844.53], true);
  tweenCamera('', 'Lens_Flare_Point_Light', 0.0001, function() {}, 0);
  INIT_ALL_LENS_FLARE_SETTINGS();
  CAMERA_CONSTRAINTS();
}


// objConstraintAddLimit puzzle
function objConstraintAddLimit(constraintName, objSelector, mode, min, max, targetObjName, dist, distLimitMode) {
    var objNames;
    if (mode == 'DISTANCE') {
        if (!targetObjName) return;
        var targetObj = getObjectByName(targetObjName);
        if (!targetObj) return;
    }

    objNames = retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        if (!objName) continue;

        var obj = getObjectByName(objName);
        if (!obj || !obj.constraints) continue;

        for (var j = obj.constraints.length - 1; j >= 0; j--) {
            if (obj.constraints[j].name == constraintName) {
                obj.constraints.splice(j, 1);
            }
        }

        var coordSystem = getCoordSystem();

        switch (mode) {
            case 'POS_X':
            case 'POS_Y':
            case 'POS_Z':
                var cons = new v3d.LimitLocationConstraint();
                cons.name = constraintName;

                if (coordSystem == 'Z_UP_RIGHT')
                    var compIndex = mode == 'POS_X' ? 0 : (mode == 'POS_Y' ? 2 : 1);
                else
                    var compIndex = mode == 'POS_X' ? 0 : (mode == 'POS_Y' ? 1 : 2);

                // swizzle sign and limits order
                if (coordSystem == 'Z_UP_RIGHT' && mode == 'POS_Y') {
                    cons.min.setComponent(compIndex, -max);
                    cons.max.setComponent(compIndex, -min);
                } else {
                    cons.min.setComponent(compIndex, min);
                    cons.max.setComponent(compIndex, max);
                }
                obj.constraints.push(cons);
                break;

            case 'ROT_X':
            case 'ROT_Y':
            case 'ROT_Z':
                var cons = new v3d.LimitRotationConstraint();
                cons.name = constraintName;

                if (coordSystem == 'Z_UP_RIGHT')
                    cons.axis = mode == 'ROT_X' ? 'X' : (mode == 'ROT_Y' ? 'Z' : 'Y');
                else
                    cons.axis = mode == 'ROT_X' ? 'X' : (mode == 'ROT_Y' ? 'Y' : 'Z');

                // swizzle sign and limits order
                if (coordSystem == 'Z_UP_RIGHT' && mode == 'ROT_Y') {
                    cons.min = v3d.MathUtils.degToRad(-max);
                    cons.max = v3d.MathUtils.degToRad(-min);
                } else {
                    cons.min = v3d.MathUtils.degToRad(min);
                    cons.max = v3d.MathUtils.degToRad(max);
                }

                obj.constraints.push(cons);
                break;

            case 'SCALE_X':
            case 'SCALE_Y':
            case 'SCALE_Z':
                var cons = new v3d.LimitScaleConstraint();
                cons.name = constraintName;

                if (coordSystem == 'Z_UP_RIGHT')
                    var compIndex = mode == 'SCALE_X' ? 0 : (mode == 'SCALE_Y' ? 2 : 1);
                else
                    var compIndex = mode == 'SCALE_X' ? 0 : (mode == 'SCALE_Y' ? 1 : 2);

                cons.min.setComponent(compIndex, min);
                cons.max.setComponent(compIndex, max);
                obj.constraints.push(cons);
                break;

            case 'DISTANCE':
                var cons =  new v3d.LimitDistanceConstraint(targetObj);
                cons.name = constraintName;
                cons.distance = dist;
                cons.limitMode = distLimitMode;
                obj.constraints.push(cons);
                break;
        }
    }
}


// Describe this function...
function CAMERA_CONSTRAINTS() {
  /* POSITION */
  objConstraintAddLimit('myConst_Cam_pos_X', 'Camera', 'POS_X', 80, 80, undefined, undefined, undefined);
  objConstraintAddLimit('myConst_Cam_pos_Y', 'Camera', 'POS_Y', 224540, 224540, undefined, undefined, undefined);
  objConstraintAddLimit('myConst_Cam_pos_Z', 'Camera', 'POS_Z', 7820, 7870, undefined, undefined, undefined);
  /* ROTATION */
  objConstraintAddLimit('myConst_Cam_rot_X', 'Camera', 'ROT_X', 0, 0, undefined, undefined, undefined);
  objConstraintAddLimit('myConst_Cam_rot_Y', 'Camera', 'ROT_Y', 0, 2.5, undefined, undefined, undefined);
  objConstraintAddLimit('myConst_Cam_rot_Z', 'Camera', 'ROT_Z', 6, 70, undefined, undefined, undefined);
}

// Describe this function...
function INIT_ALL_LENS_FLARE_SETTINGS() {
  INIT_RAYS_SETTINGS();
  INIT_GLOW_SETTINGS();
  INIT_BOKEH_SETTINGS();
  LENS_FLARE_DELUXE();
}


function lensFlareSettingsRAYS() {
    return (function(a,b,c,d,e,f,g,h,i,j,k){const l=new Map([["type","RAYS"],["shape","RAYS"],["rays",a],["symmetrical",b],["rayWidth",c],["raySharpness",d],["randomSeed",e],["rotate",f],["feBlur",g],["opacity",h],["size",i],["distance",j],["color",k]]);return l}).apply(null, arguments);
}


// Describe this function...
function INIT_RAYS_SETTINGS() {
  LFD_RAYS_Settings = [
      lensFlareSettingsRAYS
      (
          6,
          true,
          3,
          0,
          9,

          0,
          0.1,
          0.9,

          900,
          0,
          '#ffff66',

      )
      ,
      lensFlareSettingsRAYS
      (
          9,
          false,
          3,
          1,
          3,

          0,
          0.1,
          0.9,

          1200,
          0.001,
          '#ffcc66',

      )
      ,
      lensFlareSettingsRAYS
      (
          64,
          true,
          3,
          0,
          5,

          23,
          2,
          0.5,

          500,
          0.002,
          '#ffffcc',

      )
      ];
}


function lensFlareSettingsGLOW() {
    return (function(a,b,c,d,e,f,g,h,i,j){const k=new Map([["type","GLOW"],["shape",a],["toneCenter",b],["toneMid",c],["toneOuter",d],["rotate",e],["feBlur",f],["opacity",g],["size",h],["distance",i],["color",j]]);return k}).apply(null, arguments);
}


// Describe this function...
function INIT_GLOW_SETTINGS() {
  LFD_GLOW_Settings = [
      lensFlareSettingsGLOW
      (
          'GLOW_circle',

          0.2,
          0.7,
          1,

          0,
          0.1,
          0.9,

          1000,
          0,
          '#00ffff',
      )
      ,
      lensFlareSettingsGLOW
      (
          'GLOW_circle',

          0.2,
          0.7,
          1,

          0,
          0.1,
          0.9,

          600,
          0,
          '#00ffff',
      )
      ];
}


function lensFlareSettingsBOKEH() {
    return (function(a,b,c,d,e,f,g,h){const i=new Map([["type","BOKEH"],["shape",a],["vert",b],["rotate",c],["feBlur",d],["opacity",e],["size",f],["distance",g],["color",h]]);return i}).apply(null, arguments);
}


// Describe this function...
function INIT_BOKEH_SETTINGS() {
  LFD_BOKEH_Settings = [
      lensFlareSettingsBOKEH
      (
          'BOKEH_hexagon',

          0,

          0,
          0.2,
          0.5,

          1,
          0.9,
          '#ff9900',
      )
      ,
      lensFlareSettingsBOKEH
      (
          'BOKEH_hexagon',

          0,

          0,
          0.8,
          0.4,

          2,
          0,
          '#ffff00',
      )
      ];
}


function createLenseFlareFunction() {
    return (function(objInput,activeCheckboxRAYS,flareSettingsRAYS,flareMasterSizeRAYS,flareMasterOpacityRAYS,activeCheckboxGLOW,flareSettingsGLOW,flareMasterSizeGLOW,flareMasterOpacityGLOW,activeCheckboxBOKEH,flareSettingsBOKEH,flareMasterSizeBOKEH,flareMasterOpacityBOKEH,flareMasterSize,flareMasterOpacity){function mainFunction(){function checkboxFALSEcheck(){function e(){activeCheckboxGLOW==!1&&(readyToAddGLOW=!0);t()}function t(){activeCheckboxBOKEH==!1&&(readyToAddBOKEH=!0);init()}activeCheckboxRAYS==!1&&activeCheckboxGLOW==!1&&activeCheckboxBOKEH==!1?console.log("[ GLIFTEK ] Plugins: Lens Flare Deluxe all settings disabled."):function(){activeCheckboxRAYS==!1&&(readyToAddRAYS=!0);e()}()}function init(){loadAllLensFlareTextures(),promiseFunctionOBJ(objInput,function(e){light=scene.getObjectByName(e),checkboxTRUEcheck(),waitToAddAllFlares()})}function checkboxTRUEcheck(){if(activeCheckboxRAYS==!0)if(!flareSettingsRAYS){console.log("[ GLIFTEK ]: Lens Flare Deluxe Rays settings missing. Using default settings."),flareSettingsRAYS=[],flareSettingsRAYS.name="flareSettingsRAYS";const e=new Map([["type","RAYS"],["shape","RAYS"],["rays",12],["symmetrical",!1],["rayWidth",1],["raySharpness",.9],["randomSeed",10],["rotate",0],["feBlur",.2],["opacity",.9],["size",500],["distance",0],["color","teal"]]),t=new Map([["type","RAYS"],["shape","RAYS"],["rays",6],["symmetrical",!0],["rayWidth",1],["raySharpness",.9],["randomSeed",0],["rotate",0],["feBlur",.1],["opacity",.98],["size",600],["distance",0],["color","cyan"]]);flareSettingsRAYS.push(e),flareSettingsRAYS.push(t),makeFlares(flareSettingsRAYS)}else arrayCheck(flareSettingsRAYS);if(activeCheckboxGLOW==!0)if(!flareSettingsGLOW){console.log("[ GLIFTEK ]: Lens Flare Deluxe Glow settings missing. Using default settings."),flareSettingsGLOW=[],flareSettingsGLOW.name="flareSettingsGLOW";const e=new Map([["type","GLOW"],["shape","GLOW_circle"],["toneCenter",.2],["toneMid",.3],["toneOuter",.99],["rotate",0],["feBlur",0],["opacity",.6],["size",300],["distance",1e-4],["color","darkorange"]]),t=new Map([["type","GLOW"],["shape","GLOW_circle"],["toneCenter",.1],["toneMid",.2],["toneOuter",.99],["rotate",0],["feBlur",0],["opacity",.5],["size",700],["distance",0],["color","yellow"]]);flareSettingsGLOW.push(e),flareSettingsGLOW.push(t),makeFlares(flareSettingsGLOW)}else arrayCheck(flareSettingsGLOW);if(activeCheckboxBOKEH==!0)if(!flareSettingsBOKEH){console.log("[ GLIFTEK ]: Lens Flare Deluxe Bokeh settings missing. Using default settings."),flareSettingsBOKEH=[],flareSettingsBOKEH.name="flareSettingsBOKEH";const e=new Map([["type","BOKEH"],["shape","BOKEH_hexagon"],["vert",0],["rotate",0],["feBlur",.2],["opacity",.6],["size",1],["distance",.9],["color","cyan"]]),t=new Map([["type","BOKEH"],["shape","BOKEH_hexagon"],["vert",2],["rotate",0],["feBlur",.2],["opacity",.6],["size",1],["distance",0],["color","cyan"]]);flareSettingsBOKEH.push(e),flareSettingsBOKEH.push(t),makeFlares(flareSettingsBOKEH)}else arrayCheck(flareSettingsBOKEH)}function arrayCheck(e){if(!Array.isArray(e)){const t=[];t.name="flareSettings"+e.get("type"),t.push(e),console.log("settings:",t),makeFlares(t)}else Array.isArray(e)&&(e.name="flareSettings"+e[0].get("type"),makeFlares(e))}function svgUriEncode(e){let t=encodeURIComponent(" <svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' "+e+"</svg>"),a="data:image/svg+xml,".concat(t);return a}function makeFlares(flareSettings){console.log("running makeFlares for: ",flareSettings.name);let textureFlare,flareSettingsIterations=flareSettings.length;for(let i=0;i<flareSettingsIterations;i++){function makeArgsList(e,t){return e.forEach(e=>t.push(item.get(e))),t}function flareCaseFunction(flareType){makeFlareElement(makeTextureFlare(makeArgsList(eval(`LIST_flareArgs${flareType}`),eval(`flareArgs${flareType}`))),eval(`flareMasterSize${flareType}`)*flareMasterSize,itemDistance,ifLastSettingsIteration)}function makeTextureFlare(args){console.log(itemType,"args IN MAKE TEXTURE:",args);let shapeOrType="BOKEH"==itemType?"type":"shape";const svgCodeName="svgCode_"+item.get(shapeOrType),svgData=eval(svgCodeName)(...args),textureFlare=textureLoader.load(svgData);return textureFlare.name="textureFlare"+itemType+"_"+i,textureFlare}function makeFlareElement(textureFlare,sizeMultiplier,itemDistance,callback,iteration){const flareColor=new THREE.Color(item.get("color")),newFlare=new THREE.LensflareElement(textureFlare,item.get("size")*sizeMultiplier,itemDistance,flareColor);"BOKEH"!==itemType&&(iteration=i),newFlare.name="lensFlare"+itemType+"_"+iteration;let list="LIST_lensFlare"+itemType;eval(list).push(newFlare),callback(itemType)}function ifLastSettingsIteration(){i+1==flareSettingsIterations&&readyToAddFunc(itemType)}function readyToAddFunc(e){"RAYS"===e?readyToAddRAYS=!0:"GLOW"===e?readyToAddGLOW=!0:"BOKEH"===e?readyToAddBOKEH=!0:void 0}const item=flareSettings[i],itemType=item.get("type"),itemDistance=item.get("distance");let args,flareArgsRAYS=[],flareArgsGLOW=[],flareArgsBOKEH=[];switch(itemType){case"RAYS":case"GLOW":flareCaseFunction(itemType);break;case"BOKEH":const e=[60,70,120,70];let t=0===itemDistance?[.6,.7,.9,2]:[.6*itemDistance,.7*itemDistance,.9*itemDistance,2*itemDistance];;const a=e.length;for(let i=0;i<a;i++)makeFlareElement(makeTextureFlare(makeArgsList(LIST_flareArgsBOKEH,flareArgsBOKEH)),1.5*(e[i]*flareMasterSizeBOKEH*flareMasterSize),t[i],ifLastSettingsIteration,i);}}}function createLensFlareObject(){lensflare=new THREE.Lensflare,"undefined"==typeof window.lensflareCount?window.lensflareCount=1:lensflareCount+=1,lensflare.name="lensflare_"+lensflareCount,light.add(lensflare)}function waitToAddAllFlares(){function e(){function e(){activeCheckboxGLOW==!0?i():t()}function t(){activeCheckboxBOKEH==!0?r():done()}function a(){console.log("adding RAYS flares using: LIST_lensFlareRAYS:",LIST_lensFlareRAYS),addLensFlareElementsToLensFlareObject(LIST_lensFlareRAYS,t)}function i(){console.log("adding GLOW flares using: LIST_lensFlareGLOW:",LIST_lensFlareGLOW),addLensFlareElementsToLensFlareObject(LIST_lensFlareGLOW,t)}function r(){console.log("adding BOKEH flares using: LIST_lensFlareBOKEH:",LIST_lensFlareBOKEH),addLensFlareElementsToLensFlareObject(LIST_lensFlareBOKEH,done)}console.log("adding all flares"),function(){activeCheckboxRAYS==!0?a():e()}()}createLensFlareObject();var t=setInterval(()=>{readyToAddRAYS==!0&&readyToAddGLOW==!0&&readyToAddBOKEH==!0&&(clearInterval(t),e())},100)}function addLensFlareElementsToLensFlareObject(e,t){for(let a,i=0;i<e.length;i++)a=e[i],lensflare.addElement(a),console.log(a.name,"added to lensflare object:",a),i==e.length-1&&(console.log(e.name," length met. running next function."),t())}function done(){console.log("done")}function svgCode_RAYS(e,t,a,i,r,l,s,o){function n(e){if(0==e){return 1}if(10<e||1>e){return 1}else{const t=.1*(Math.floor(Math.random()*e)+1);return t}}function d(t){let i=360/e;const l=n(r);return"<g transform=\n\t\t\t\t'rotate("+i*t+",300,300)'>\n\t\t\t\t<use \n\t\t\t\tclass='rayUse' \n\t\t\t\txlink:href='#raySymbol'\t\t\t\t\n\t\t\t\ttransform='scale("+l+","+a+")'/>\n\t\t\t\t</g>"}0!==r&&(10<r||1>r)&&(console.log("[ GLIFTEK ]: Lens Flare Rays Settings puzzle \"random ray lengths\" input must be between 1 and 10. Set to 0 to disable. Setting to 0."),alert("[ GLIFTEK ]: Lens Flare Rays Settings puzzle \"random ray lengths\" input must be between 1 and 10. Set to 0 to disable. Setting to 0"));let p="",f="";if(t==!0){f="",0!=e%2&&(e++,console.log("[ GLIFTEK ] Lens Flare Rays Settings: Only an even number of rays can be symmetrical. Changing \"ray count\" up to: ",e));for(let t=0;t<e/2;t++)p+=d(t)}else if(!1==t){f="mask:url(#mask)";for(let t=0;t<e;t++)p+=d(t)}let c=svgUriEncode("\n\t\t\t\twidth='600'\n\t\t\t\theight='600' \n\t\t\t\tviewBox='0 0 600 600'>\n\n\t\t\t\t<style type=\"text/css\"> \n\t\t\t\t.rayUse {\n\t\t\t\t\ttransform-origin: center;\n\t\t\t\t}\n\t\t\t\t.rayElipse {\n\t\t\t\t\tmix-blend-mode:screen;\n\t\t\t\t\tfill:url(#radial-gradient);\n\t\t\t\t}\n\t\t\t\t</style>\n\n\t\t\t\t\t<defs>\n\n\t\t\t\t\t\t<mask id=\"mask\"> \n\t\t\t\t\t\t\t<rect x='0' y='285' width='300' height='30' fill='#ffffff' /> \n\t\t\t\t\t\t</mask>\n\n\t\t\t\t\t\t<radialGradient id='radial-gradient' \n\n\t\t\t\t\t\t\tcx='300' \n\t\t\t\t\t\t\tcy='300' \n\t\t\t\t\t\t\tr='150'\n\n\t\t\t\t\t\t\tgradientTransform='translate(-300 290.9) scale(2 0.03)' gradientUnits='userSpaceOnUse'\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t<stop offset='0.15' \n\t\t\t\t\t\t\tstop-color='#fff' \n\t\t\t\t\t\t\tstop-opacity='1'\n\t\t\t\t\t\t\t/>\n\n\t\t\t\t\t\t\t<stop offset='"+(1-.1*i)+"' \n\t\t\t\t\t\t\tstop-color='#fff' \n\t\t\t\t\t\t\tstop-opacity='0'\n\t\t\t\t\t\t\t/>\n\n\t\t\t\t\t\t</radialGradient>\n\t\t\t\t\t\n\t\t\t\t\t\t<filter id='blur' x='-.1' y='-.1' >\n\t\t\t\t\t\t<feGaussianBlur in='SourceGraphic' stdDeviation='"+s+"' />\n\t\t\t\t\t\t</filter>\n\t\t\t\t\t</defs>\n\t\t\t\t\t<g style=\"isolation:isolate\">\n\t\t\t\t\t\t<symbol id='raySymbol' viewBox='0 0 600 600' >\n\t\t\t\t\t\t\t<g style='"+f+"' \n\t\t\t\t\t\t\ttransform='\n\t\t\t\t\t\t\ttranslate("+"0"+","+"0"+")\n\t\t\t\t\t\t\t'>\n\t\t\t\t\t\t\t\t<ellipse class='rayElipse' cx='300' cy='300' rx='300' ry='5' />\n\t\t\t\t\t\t\t</g>\n\t\t\t\t\t\t</symbol>\n\t\t\t\t\t</g>\n\t\t\t\t\t\n\t\t\t\t\t<g "+("transform='rotate("+l+",300,300)' opacity='"+o*flareMasterOpacityRAYS*flareMasterOpacity+"' filter='url(#blur)'")+"> "+p+" </g>\n\t\t\t\t\n\t\t\t");return console.log("result from svgCode_RAYS: ",c),c}function svgCode_GLOW_hexagon(e,t,a,i,r,l){let s=svgUriEncode("\n\n\t\t\twidth='100'\n\t\t\theight='100'\n\t\t\tviewBox='0 0 100 100'>\n\n\t\t\t<defs>\n\t\t\t<filter id='blur' x='-.1' y='-.1' >\n\t\t\t<feGaussianBlur in='SourceGraphic' stdDeviation='"+r+"' />\n\t\t\t</filter>\n\t\t\t</defs>\n\t\t\t"+BOKEH_hexagon+"\n\t\t\t\n\t\t\tid='glow' \n\t\t\tstyle='fill:gray'\n\t\t\tfilter='url(#blur)' \n\t\t\ttransform='rotate("+i+",50,50)'\n\t\t\topacity='"+l*flareMasterOpacityGLOW*flareMasterOpacity+"'\t\t\n\t\t\t/>\n\n\t\t\t<g "+""+"> "+"<use xlink:href='#glow' />"+" </g>\n\t\t\t\t\n\t\t\t");return console.log("result from svgCode_GLOW_hexagon: ",s),s}function svgCode_GLOW_circle(e,t,a,i,r,l){let s=svgUriEncode("\n\n\t\t\twidth='100'\n\t\t\theight='100'\n\t\t\tviewBox='0 0 100 100'>\n\n\t\t\t<defs>\n\t\t\t<radialGradient id='radial-gradient' cx='50' cy='50' r='50' gradientUnits='userSpaceOnUse'>\n\n\t\t\t<stop offset='"+e+"' style='stop-color: #fff; stop-opacity: 1'/>\n\t\t\t<stop offset='"+t+"' style='stop-color: #fff; stop-opacity: 5'/>\n\t\t\t<stop offset='"+a+"' style='stop-color: #fff; stop-opacity: 0'/>\n\n\t\t\t</radialGradient>\n\n\t\t\t<g style='isolation:isolate'>\n\n\t\t\t\t<g id='glow'>\n\n\t\t\t\t\t<circle cx='50' cy='50' r='50' style='mix-blend-mode:screen;fill:url(#radial-gradient)' />\n\n\t\t\t\t</g>\n\n\t\t\t</g>\n\n\t\t\t</defs>\n\t\t\t<g "+""+"> "+("<use xlink:href='#glow' opacity='"+l*flareMasterOpacityGLOW+"'/>")+" </g>\n\t\t\t\t\n\t\t\t");return s}function svgCode_GLOW_square(e,t,a,i,r,l){let s=svgUriEncode("\n\n\t\t\twidth='100'\n\t\t\theight='100'\n\t\t\tviewBox='0 0 100 100'>\n\n\t\t\t<defs>\n\t\t\t<radialGradient id='radial-gradient' cx='50' cy='50' r='50' gradientUnits='userSpaceOnUse'>\n\n\t\t\t<stop offset='"+e+"' stop-color='#fff' />\n\t\t\t<stop offset='"+t+"' stop-color='#575757' />\n\t\t\t<stop offset='"+a+"' stop-color='#000' />\n\t\t\t</radialGradient>\n\n\t\t\t<g style='isolation:isolate'>\n\t\t\t<g id='glow'>\n\n\t\t\t<rect cx='50' cy='50' r='50' style='mix-blend-mode:screen;fill:url(#radial-gradient)' />\n\n\t\t\t</g>\n\t\t\t</g>\n\t\t\t</defs>\n\t\t\t<g "+""+"> "+("<use xlink:href='#glow' opacity='"+l*flareMasterOpacityGLOW*flareMasterOpacity+"'/>")+" </g>\n\t\t\t\t\n\t\t\t");return s}function svgCode_BOKEH(_0x3fc6bc,_0x4acbd4,_0x434d32,_0x1bc144,_0x4edafb,_0x4dd9c6){const _0x6ff1a1=100,_0x4fc42d=100,_0x42553a=0,_0x5183ad=0,_0x440642=100,_0x53a3e8=100,_0x5a9d3e=0,_0x3b62fd=0,_0x53cc4c=1,_0x386b09=1;let _0x2da960=svgUriEncode("\n\t\t\t\twidth='100'\n\t\t\t\theight='100'\n\t\t\t\tviewBox='0 0\n\t\t\t\t100 100'>\n\t\t\t\t<defs>\n\t\t\t\t\t<filter id=\"blur\" x=\"-.1\" y=\"-.1\" >\n\t\t\t\t\t<feGaussianBlur in='SourceGraphic' stdDeviation='"+_0x4edafb+"' />\n\t\t\t\t\t</filter>\n\t\t\t\t</defs>\n\t\t\t\t"+eval(_0x3fc6bc)+" \n\t\t\t\tstyle='fill:"+_0x4acbd4+"'\n\t\t\t\topacity='\n\t\t\t\t"+_0x4dd9c6*flareMasterOpacityBOKEH*flareMasterOpacity+"'\n\t\t\t\tfilter='url(#blur)'\n\t\t\t\ttransform='\n\t\t\t\ttranslate("+0+","+0+")\n\t\t\t\tscale("+1+","+1+")\n\t\t\t\trotate("+_0x1bc144+","+50+","+50+")\n\t\t\t'/>\n\t\t\t");return _0x2da960}function loadAllLensFlareTextures(){MAP_LF_Bokeh_Polygons.set("line","<line x1='50' y1='20' x2='80' y2='50' style ='stroke:gray;stroke-width:5'"),MAP_LF_Bokeh_Polygons.set("circle","<circle cx='50' cy='50' r='50' "),MAP_LF_Bokeh_Polygons.set("triangle","<polygon points='50 20 84.64 80 15.36 80 50 20'"),MAP_LF_Bokeh_Polygons.set("square","<rect x='20' y='20' width='60' height='60'"),MAP_LF_Bokeh_Polygons.set("pentagon","<polygon points='50 13.82 88.04 41.46 73.51 86.18 26.49 86.18 11.96 41.46 50 13.82'"),MAP_LF_Bokeh_Polygons.set("hexagon","<polygon points = '50.04 10 84.66 30.04 84.62 70.04 49.96 90 15.34 69.96 15.38 29.96 50.04 10'"),MAP_LF_Bokeh_Polygons.set("heptagon","<polygon points='50 11.98 81.27 27.04 89 60.88 67.36 88.02 32.65 88.02 11 60.88 18.73 27.04 50 11.98'"),MAP_LF_Bokeh_Polygons.set("octagon","<polygon points='65.31 13.04 86.95 34.69 86.95 65.31 65.31 86.95 34.69 86.95 13.04 65.31 13.04 34.69 34.69 13.04 65.31 13.04'"),MAP_LF_Bokeh_Polygons.set("nonagon","<polygon points='50 11.21 75.71 20.56 89.39 44.26 84.64 71.21 63.68 88.79 36.32 88.79 15.36 71.21 10.61 44.26 24.29 20.56 50 11.21'"),BOKEH_line=MAP_LF_Bokeh_Polygons.get("line"),BOKEH_circle=MAP_LF_Bokeh_Polygons.get("circle"),BOKEH_triangle=MAP_LF_Bokeh_Polygons.get("triangle"),BOKEH_square=MAP_LF_Bokeh_Polygons.get("square"),BOKEH_pentagon=MAP_LF_Bokeh_Polygons.get("pentagon"),BOKEH_hexagon=MAP_LF_Bokeh_Polygons.get("hexagon"),BOKEH_heptagon=MAP_LF_Bokeh_Polygons.get("heptagon"),BOKEH_octagon=MAP_LF_Bokeh_Polygons.get("octagon"),BOKEH_nonagon=MAP_LF_Bokeh_Polygons.get("nonagon")}function lenseFlareJS(){(function(){class e extends THREE.Mesh{constructor(){super(e.Geometry,new THREE.MeshBasicMaterial({opacity:0,transparent:!0})),this.type="Lensflare",this.frustumCulled=!1,this.renderOrder=1/0;const a=new THREE.Vector3,i=new THREE.Vector3,r=new THREE.DataTexture(new Uint8Array(768),16,16,THREE.RGBFormat);r.minFilter=THREE.NearestFilter,r.magFilter=THREE.NearestFilter,r.wrapS=THREE.ClampToEdgeWrapping,r.wrapT=THREE.ClampToEdgeWrapping;const l=new THREE.DataTexture(new Uint8Array(768),16,16,THREE.RGBFormat);l.minFilter=THREE.NearestFilter,l.magFilter=THREE.NearestFilter,l.wrapS=THREE.ClampToEdgeWrapping,l.wrapT=THREE.ClampToEdgeWrapping;const s=e.Geometry,o=new THREE.RawShaderMaterial({uniforms:{scale:{value:null},screenPosition:{value:null}},vertexShader:"\n\n\t\t\t\t\t\tprecision highp float;\n\n\t\t\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\t\t\tuniform vec2 scale;\n\n\t\t\t\t\t\tattribute vec3 position;\n\n\t\t\t\t\t\tvoid main() {\n\n\t\t\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t\t\t}",fragmentShader:"\n\n\t\t\t\t\t\tprecision highp float;\n\n\t\t\t\t\t\tvoid main() {\n\n\t\t\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t\t\t}",depthTest:!0,depthWrite:!1,transparent:!1}),n=new THREE.RawShaderMaterial({uniforms:{map:{value:r},scale:{value:null},screenPosition:{value:null}},vertexShader:"\n\n\t\t\t\t\t\tprecision highp float;\n\n\t\t\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\t\t\tuniform vec2 scale;\n\n\t\t\t\t\t\tattribute vec3 position;\n\t\t\t\t\t\tattribute vec2 uv;\n\n\t\t\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\t\t\tvoid main() {\n\n\t\t\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t\t\t}",fragmentShader:"\n\n\t\t\t\t\t\tprecision highp float;\n\n\t\t\t\t\t\tuniform sampler2D map;\n\n\t\t\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\t\t\tvoid main() {\n\n\t\t\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t\t\t}",depthTest:!1,depthWrite:!1,transparent:!1}),d=new THREE.Mesh(s,o),p=[],f=t.Shader,c=new THREE.RawShaderMaterial({uniforms:{map:{value:null},occlusionMap:{value:l},color:{value:new THREE.Color(16777215)},scale:{value:new THREE.Vector2},screenPosition:{value:new THREE.Vector3}},vertexShader:f.vertexShader,fragmentShader:f.fragmentShader,blending:THREE.AdditiveBlending,transparent:!0,depthWrite:!1}),g=new THREE.Mesh(s,c);this.addElement=function(e){p.push(e)};const m=new THREE.Vector2,u=new THREE.Vector2,h=new THREE.Box2,y=new THREE.Vector4;this.onBeforeRender=function(e,t,f){e.getCurrentViewport(y);const E=y.w/y.z,C=y.z/2,v=y.w/2;let x=16/y.w;if((m.set(x*E,x),h.min.set(y.x,y.y),h.max.set(y.x+(y.z-16),y.y+(y.w-16)),i.setFromMatrixPosition(this.matrixWorld),i.applyMatrix4(f.matrixWorldInverse),!(0<i.z))&&(a.copy(i).applyMatrix4(f.projectionMatrix),u.x=y.x+a.x*C+C-8,u.y=y.y+a.y*v+v-8,h.containsPoint(u))){e.copyFramebufferToTexture(u,r);let t=o.uniforms;t.scale.value=m,t.screenPosition.value=a,e.renderBufferDirect(f,null,s,o,d,null),e.copyFramebufferToTexture(u,l),t=n.uniforms,t.scale.value=m,t.screenPosition.value=a,e.renderBufferDirect(f,null,s,n,d,null);const i=2*-a.x,h=2*-a.y;for(let t=0,r=p.length;t<r;t++){const r=p[t],l=c.uniforms;l.color.value.copy(r.color),l.map.value=r.texture,l.screenPosition.value.x=a.x+i*r.distance,l.screenPosition.value.y=a.y+h*r.distance,x=r.size/y.w;const o=y.w/y.z;l.scale.value.set(x*o,x),c.uniformsNeedUpdate=!0,e.renderBufferDirect(f,null,s,c,g,null)}}},this.dispose=function(){o.dispose(),n.dispose(),c.dispose(),r.dispose(),l.dispose();for(let e=0,t=p.length;e<t;e++)p[e].texture.dispose()}}}e.prototype.isLensflare=!0;class t{constructor(e,t=1,a=0,i=new THREE.Color(16777215)){this.texture=e,this.size=t,this.distance=a,this.color=i}}t.Shader={uniforms:{map:{value:null},occlusionMap:{value:null},color:{value:null},scale:{value:null},screenPosition:{value:null}},vertexShader:"\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tuniform sampler2D occlusionMap;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\t\t\t\tvarying float vVisibility;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tvec2 pos = position.xy;\n\n\t\t\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}",fragmentShader:"\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform vec3 color;\n\n\t\t\t\tvarying vec2 vUV;\n\t\t\t\tvarying float vVisibility;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\t\t\ttexture.a *= vVisibility;\n\t\t\t\t\tgl_FragColor = texture;\n\t\t\t\t\tgl_FragColor.rgb *= color;\n\n\t\t\t\t}"},e.Geometry=function(){const e=new THREE.BufferGeometry,t=new Float32Array([-1,-1,0,0,0,1,-1,0,1,0,1,1,0,1,1,-1,1,0,0,1]),a=new THREE.InterleavedBuffer(t,5);return e.setIndex([0,1,2,0,2,3]),e.setAttribute("position",new THREE.InterleavedBufferAttribute(a,3,0,!1)),e.setAttribute("uv",new THREE.InterleavedBufferAttribute(a,2,3,!1)),e}(),THREE.Lensflare=e,THREE.LensflareElement=t})()}function promiseFunctionOBJ(e,t){(function(t){function a(r,l){console.log("[ GLIFTEK Plugins ]:\n'",puzzleName,"'puzzle is looking for",e),app.scene.getObjectByName(e)?r(app.scene.getObjectByName(e)):t&&Date.now()-i>=t?(l(new Error("timeout.",e,"not found!")),console.log("[ GLIFTEK Plugins ]:\n 'timeout.'",e,"not found!"),alert("[ GLIFTEK Plugins ]:\n 'timeout.'",e,"not found!")):setTimeout(a.bind(this,r,l),30)}var i=Date.now();return new Promise(a)})(10000).then(function(){t(e)})}function promiseFunctionVAR(e,t){(function(t){function a(r,l){if(console.log("[ GLIFTEK Plugins ]:\n'",puzzleName,"'puzzle is looking for",e),"undefined"!==e){r(e);console.log("[ GLIFTEK Plugins ]:",e.name,"found!")}else t&&Date.now()-i>=t?(l(new Error("timeout.",e,"not found!")),console.log("[ GLIFTEK Plugins ]:\n 'timeout.'",e,"not found!"),alert("[ GLIFTEK Plugins ]:\n 'timeout.'",e,"not found!")):setTimeout(a.bind(this,r,l),30)}var i=Date.now();return new Promise(a)})(10000).then(function(){t(e)})}window.lensflareJS_var||(window.lensflareJS_var=lenseFlareJS()),checkboxFALSEcheck()}const puzzleName="Lense Flare Deluxe";let readyToAddRAYS=!1,readyToAddGLOW=!1,readyToAddBOKEH=!1;const LIST_flareArgsRAYS=["rays","symmetrical","rayWidth","raySharpness","randomSeed","rotate","feBlur","opacity"],LIST_flareArgsGLOW=["toneCenter","toneMid","toneOuter","rotate","feBlur","opacity"],LIST_flareArgsBOKEH=["shape","color","vert","rotate","feBlur","opacity"],varToString=e=>Object.keys(e)[0],renderer=app.renderer;renderer.outputEncoding=THREE.sRGBEncoding,renderer.antialias=!0;const scene=app.scene,camera=app.camera;let textureLoader=new THREE.TextureLoader,clock=new THREE.Clock,LIST_lensFlareRAYS=[];LIST_lensFlareRAYS.name="LIST_lensFlareRAYS";let LIST_lensFlareGLOW=[];LIST_lensFlareGLOW.name="LIST_lensFlareGLOW";let LIST_lensFlareBOKEH=[];LIST_lensFlareBOKEH.name="LIST_lensFlareBOKEH";let lensflare,light,selectedLight,BOKEH_line,BOKEH_circle,BOKEH_triangle,BOKEH_square,BOKEH_pentagon,BOKEH_hexagon,BOKEH_heptagon,BOKEH_octagon,BOKEH_nonagon,LIST_lensFlareALL=[LIST_lensFlareRAYS,LIST_lensFlareGLOW,LIST_lensFlareBOKEH],MAP_LF_Bokeh_Polygons=new Map;objInput&&"<none>"!=objInput?mainFunction():console.log("[ GLIFTEK ]: The ","Lense Flare Deluxe","plugin puzzle is missing an input!")}).apply(null, arguments);
}


// Describe this function...
function LENS_FLARE_DELUXE() {

  		createLenseFlareFunction
  		(
  			'Lens_Flare_Point_Light',

  			true,
  			LFD_RAYS_Settings,
  			1.5,
  			0.95,

  			true,
  			LFD_GLOW_Settings,
  			1,
  			0.95,

  			true,
  			LFD_BOKEH_Settings,
  			0.75,
  			0.95,

  			1,
  			0.95

  		);
  	}


MAIN();



} // end of PL.init function

})(); // end of closure

/* ================================ end of code ============================= */
