/**
 * Generated by Verge3D Puzzles v.3.8.0 pre4
 * Wed Aug 25 2021 16:34:28 GMT-0400 (Eastern Daylight Time)
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */

'use strict';

(function() {

// global variables/constants used by puzzles' functions

var LIST_NONE = '<none>';

var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster();

var PL = v3d.PL = v3d.PL || {};

// a more readable alias for PL (stands for "Puzzle Logic")
v3d.puzzles = PL;

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        }
    }

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    this.procedures["INIT"] = INIT;
this.procedures["SET_BG_GRADIENT"] = SET_BG_GRADIENT;
this.procedures["LOAD_BG_SKY_IMAGE_GRADIENT"] = LOAD_BG_SKY_IMAGE_GRADIENT;

    var PROC = {
    "INIT": INIT,
    "SET_BG_GRADIENT": SET_BG_GRADIENT,
    "LOAD_BG_SKY_IMAGE_GRADIENT": LOAD_BG_SKY_IMAGE_GRADIENT,
};

var color_1, EXEC_load_bg, color_2, bg_gradient;

// Describe this function...
function INIT() {
  LOAD_BG_SKY_IMAGE_GRADIENT();
}


// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}



// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}


// Describe this function...
function SET_BG_GRADIENT() {
  color_1 = '#0d427b';
  color_2 = ' #dc8f17';
  bg_gradient = ['linear-gradient(',color_1,',',color_2,')'].join('');
  console.log('bg-gradient: ' + String(bg_gradient));
  setHTMLElemStyle('backgroundImage', bg_gradient, ['CONTAINER'], true);
}

// Describe this function...
function LOAD_BG_SKY_IMAGE_GRADIENT() {
  EXEC_load_bg = ('// var bgTexture = new THREE.TextureLoader().load("images/background/space.png");' + '\n' +
  '// bgTexture.minFilter = THREE.LinearFilter;' + '\n' +
  '// scene.background = bgTexture;' + '\n' +
  'var bgTexture = new THREE.TextureLoader()' + '\n' +
  '.load(window.gliftek_SVGs.lensflare.bg_sky_gradient);' + '\n' +
  '' + '\n' +
  'bgTexture.minFilter = THREE.LinearFilter;' + '\n' +
  'app.scene.background = bgTexture;');
  var VARS = Object.defineProperties({}, {
    "color_1": { get: function() { return color_1; }, set: function(val) { color_1 = val; } },
    "EXEC_load_bg": { get: function() { return EXEC_load_bg; }, set: function(val) { EXEC_load_bg = val; } },
    "color_2": { get: function() { return color_2; }, set: function(val) { color_2 = val; } },
    "bg-gradient": { get: function() { return bg_gradient; }, set: function(val) { bg_gradient = val; } },
});

  Function('app', 'v3d', 'VARS', 'PROC', EXEC_load_bg)(appInstance, v3d, VARS, PROC);

}



// initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = true;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = false;
_initGlob.output.initOptions.useFullscreen = true;

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["SET_BUTTONS"] = SET_BUTTONS;
this.procedures["MAIN"] = MAIN;
this.procedures["FADE_IN"] = FADE_IN;
this.procedures["CLICK_NEXTFLARE_3D_HITBOX"] = CLICK_NEXTFLARE_3D_HITBOX;
this.procedures["LENS_FLARE_DELUXE_ALL"] = LENS_FLARE_DELUXE_ALL;
this.procedures["INIT_ALL_LENS_FLARE_SETTINGS"] = INIT_ALL_LENS_FLARE_SETTINGS;
this.procedures["CAMERA_CONSTRAINTS"] = CAMERA_CONSTRAINTS;
this.procedures["LENS_FLARE_SETTINGS"] = LENS_FLARE_SETTINGS;
this.procedures["LENS_FLARE_DELUXE_1"] = LENS_FLARE_DELUXE_1;
this.procedures["INIT_RAYS_SETTINGS_1"] = INIT_RAYS_SETTINGS_1;
this.procedures["SWITCH_FLARE_3"] = SWITCH_FLARE_3;
this.procedures["SWITCH_FLARE"] = SWITCH_FLARE;
this.procedures["CHANGE_BG_AND_FLARE"] = CHANGE_BG_AND_FLARE;
this.procedures["INIT_GLOW_SETTINGS_1"] = INIT_GLOW_SETTINGS_1;
this.procedures["INIT_BOKEH_SETTINGS_1"] = INIT_BOKEH_SETTINGS_1;
this.procedures["SWITCH_FLARE_4"] = SWITCH_FLARE_4;
this.procedures["LENS_FLARE_DELUXE_2"] = LENS_FLARE_DELUXE_2;
this.procedures["INIT_RAYS_SETTINGS_2"] = INIT_RAYS_SETTINGS_2;
this.procedures["INIT_GLOW_SETTINGS_2"] = INIT_GLOW_SETTINGS_2;
this.procedures["INIT_BOKEH_SETTINGS_2"] = INIT_BOKEH_SETTINGS_2;
this.procedures["LENS_FLARE_DELUXE_3"] = LENS_FLARE_DELUXE_3;
this.procedures["INIT_RAYS_SETTINGS_3"] = INIT_RAYS_SETTINGS_3;
this.procedures["INIT_GLOW_SETTINGS_3"] = INIT_GLOW_SETTINGS_3;
this.procedures["INIT_BOKEH_SETTINGS_3"] = INIT_BOKEH_SETTINGS_3;

var PROC = {
    "SET_BUTTONS": SET_BUTTONS,
    "MAIN": MAIN,
    "FADE_IN": FADE_IN,
    "CLICK_NEXTFLARE_3D_HITBOX": CLICK_NEXTFLARE_3D_HITBOX,
    "LENS_FLARE_DELUXE_ALL": LENS_FLARE_DELUXE_ALL,
    "INIT_ALL_LENS_FLARE_SETTINGS": INIT_ALL_LENS_FLARE_SETTINGS,
    "CAMERA_CONSTRAINTS": CAMERA_CONSTRAINTS,
    "LENS_FLARE_SETTINGS": LENS_FLARE_SETTINGS,
    "LENS_FLARE_DELUXE_1": LENS_FLARE_DELUXE_1,
    "INIT_RAYS_SETTINGS_1": INIT_RAYS_SETTINGS_1,
    "SWITCH_FLARE_3": SWITCH_FLARE_3,
    "SWITCH_FLARE": SWITCH_FLARE,
    "CHANGE_BG_AND_FLARE": CHANGE_BG_AND_FLARE,
    "INIT_GLOW_SETTINGS_1": INIT_GLOW_SETTINGS_1,
    "INIT_BOKEH_SETTINGS_1": INIT_BOKEH_SETTINGS_1,
    "SWITCH_FLARE_4": SWITCH_FLARE_4,
    "LENS_FLARE_DELUXE_2": LENS_FLARE_DELUXE_2,
    "INIT_RAYS_SETTINGS_2": INIT_RAYS_SETTINGS_2,
    "INIT_GLOW_SETTINGS_2": INIT_GLOW_SETTINGS_2,
    "INIT_BOKEH_SETTINGS_2": INIT_BOKEH_SETTINGS_2,
    "LENS_FLARE_DELUXE_3": LENS_FLARE_DELUXE_3,
    "INIT_RAYS_SETTINGS_3": INIT_RAYS_SETTINGS_3,
    "INIT_GLOW_SETTINGS_3": INIT_GLOW_SETTINGS_3,
    "INIT_BOKEH_SETTINGS_3": INIT_BOKEH_SETTINGS_3,
};

var LIST_lens_flares, LFD_RAYS_Settings_01, lens_flare_counter, LFD_GLOW_Settings_01, LFD_BOKEH_Settings_01, LFD_RAYS_Settings_02, LFD_GLOW_Settings_02, LFD_BOKEH_Settings_02, LFD_RAYS_Settings_03, LFD_GLOW_Settings_03, LFD_BOKEH_Settings_03, button_1_InnerHTML, current_lens_flare, LIST_bg_images, center_alpha_distance_02;


// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}



// addHTMLElement puzzle
function addHTMLElement(elemType, id, mode, targetId, isParent) {

    var win = isParent ? window.parent : window;

    var elem = win.document.createElement(elemType);
    if (id !== '')
        elem.id = id;

    var targetElem = getElement(targetId, isParent);
    if (targetElem instanceof win.Element) {
        switch (mode) {
            case 'TO':
                targetElem.appendChild(elem);
                break;
            case 'BEFORE':
                targetElem.insertAdjacentElement('beforebegin', elem);
                break;
            case 'AFTER':
                targetElem.insertAdjacentElement('afterend', elem);
                break;
        }
    }
}



// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if (attr === 'style') {
            // NOTE: setting an attribute 'style' instead of a property 'style'
            // fixes IE11 wrong behavior
            elem.setAttribute(attr, value);
        } else if ((attr == 'href' || attr == 'src') && value instanceof Promise) {
            // resolve promise value for url-based attributes
            value.then(function(response) {
                elem[attr] = response;
            });
        } else {
            elem[attr] = value;
        }
    }
}



// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}



// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;
        elem.addEventListener(eventType, callback);
        if (v3d.PL.editorEventListeners)
            v3d.PL.editorEventListeners.push([elem, eventType, callback]);
    }
}


// Describe this function...
function SET_BUTTONS() {
  addHTMLElement('button', 'nextFlare', 'TO', ['CONTAINER'], true);
  button_1_InnerHTML = ('<div' + '\n' +
  'id="nextFlare" ' + '\n' +
  'style="' + '\n' +
  'width: 60px;' + '\n' +
  'height: 20px;' + '\n' +
  'top: 0px;' + '\n' +
  'right: 100px;' + '\n' +
  'display:block' + '\n' +
  '">' + '\n' +
  'next flare' + '\n' +
  '</div>');
  setHTMLElemAttribute('innerHTML', button_1_InnerHTML, 'nextFlare', false);
  eventHTMLElem('pointerover', 'nextFlare', false, function(event) {
    setHTMLElemStyle('cursor', 'pointer', 'nextFlare', false);
  });
  eventHTMLElem('pointerdown', 'nextFlare', false, function(event) {
    console.log('next flare BUTTON CLICKED!');
    SWITCH_FLARE();
  });
}



// utility function envoked by almost all V3D-specific puzzles
// filter off some non-mesh types
function notIgnoredObj(obj) {
    return obj.type !== 'AmbientLight' &&
           obj.name !== '' &&
           !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
           !obj.isAuxClippingMesh;
}


// utility function envoked by almost all V3D-specific puzzles
// find first occurence of the object by its name
function getObjectByName(objName) {
    var objFound;
    var runTime = _pGlob !== undefined;
    objFound = runTime ? _pGlob.objCache[objName] : null;

    if (objFound && objFound.name === objName)
        return objFound;

    appInstance.scene.traverse(function(obj) {
        if (!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
            objFound = obj;
            if (runTime) {
                _pGlob.objCache[objName] = objFound;
            }
        }
    });
    return objFound;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects on the scene
function getAllObjectNames() {
    var objNameList = [];
    appInstance.scene.traverse(function(obj) {
        if (notIgnoredObj(obj))
            objNameList.push(obj.name)
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects which belong to the group
function getObjectNamesByGroupName(targetGroupName) {
    var objNameList = [];
    appInstance.scene.traverse(function(obj){
        if (notIgnoredObj(obj)) {
            var groupNames = obj.groupNames;
            if (!groupNames)
                return;
            for (var i = 0; i < groupNames.length; i++) {
                var groupName = groupNames[i];
                if (groupName == targetGroupName) {
                    objNameList.push(obj.name);
                }
            }
        }
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// process object input, which can be either single obj or array of objects, or a group
function retrieveObjectNames(objNames) {
    var acc = [];
    retrieveObjectNamesAcc(objNames, acc);
    return acc.filter(function(name) {
        return name;
    });
}

function retrieveObjectNamesAcc(currObjNames, acc) {
    if (typeof currObjNames == "string") {
        acc.push(currObjNames);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
        var newObj = getObjectNamesByGroupName(currObjNames[1]);
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "ALL_OBJECTS") {
        var newObj = getAllObjectNames();
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames)) {
        for (var i = 0; i < currObjNames.length; i++)
            retrieveObjectNamesAcc(currObjNames[i], acc);
    }
}





/**
 * Retrieve coordinate system from the loaded scene
 */
function getCoordSystem() {
    var scene = appInstance.scene;

    if (scene && "v3d" in scene.userData && "coordSystem" in scene.userData.v3d) {
        return scene.userData.v3d.coordSystem;
    } else {
        // COMPAT: <2.17, consider replacing to 'Y_UP_RIGHT' for scenes with unknown origin
        return 'Z_UP_RIGHT';
    }
}


/**
 * Transform coordinates from one space to another
 * Can be used with Vector3 or Euler.
 */
function coordsTransform(coords, from, to, noSignChange) {

    if (from == to)
        return coords;

    var y = coords.y, z = coords.z;

    if (from == 'Z_UP_RIGHT' && to == 'Y_UP_RIGHT') {
        coords.y = z;
        coords.z = noSignChange ? y : -y;
    } else if (from == 'Y_UP_RIGHT' && to == 'Z_UP_RIGHT') {
        coords.y = noSignChange ? z : -z;
        coords.z = y;
    } else {
        console.error('coordsTransform: Unsupported coordinate space');
    }

    return coords;
}


/**
 * Verge3D euler rotation to Blender/Max shortest.
 * 1) Convert from intrinsic rotation (v3d) to extrinsic XYZ (Blender/Max default
 *    order) via reversion: XYZ -> ZYX
 * 2) swizzle ZYX->YZX
 * 3) choose the shortest rotation to resemble Blender's behavior
 */
var eulerV3DToBlenderShortest = function() {

    var eulerTmp = new v3d.Euler();
    var eulerTmp2 = new v3d.Euler();
    var vec3Tmp = new v3d.Vector3();

    return function(euler, dest) {

        var eulerBlender = eulerTmp.copy(euler).reorder('YZX');
        var eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();

        var len = eulerBlender.toVector3(vec3Tmp).lengthSq();
        var lenAlt = eulerBlenderAlt.toVector3(vec3Tmp).lengthSq();

        dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
        return coordsTransform(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
    }

}();




function RotationInterface() {
    /**
     * For user manipulations use XYZ extrinsic rotations (which
     * are the same as ZYX intrinsic rotations)
     *     - Blender/Max/Maya use extrinsic rotations in the UI
     *     - XYZ is the default option, but could be set from
     *       some order hint if exported
     */
    this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
    this._actualRotation = new v3d.Euler();
}

Object.assign(RotationInterface, {
    initObject: function(obj) {
        if (obj.userData.v3d.puzzles === undefined) {
            obj.userData.v3d.puzzles = {}
        }
        if (obj.userData.v3d.puzzles.rotationInterface === undefined) {
            obj.userData.v3d.puzzles.rotationInterface = new RotationInterface();
        }

        var rotUI = obj.userData.v3d.puzzles.rotationInterface;
        rotUI.updateFromObject(obj);
        return rotUI;
    }
});

Object.assign(RotationInterface.prototype, {

    updateFromObject: function(obj) {
        var SYNC_ROT_EPS = 1e-8;

        if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
            this._actualRotation.copy(obj.rotation);
            this._updateUserRotFromActualRot();
        }
    },

    getActualRotation: function(euler) {
        return euler.copy(this._actualRotation);
    },

    setUserRotation: function(euler) {
        // don't copy the order, since it's fixed to ZYX for now
        this._userRotation.set(euler.x, euler.y, euler.z);
        this._updateActualRotFromUserRot();
    },

    getUserRotation: function(euler) {
        return euler.copy(this._userRotation);
    },

    _updateUserRotFromActualRot: function() {
        var order = this._userRotation.order;
        this._userRotation.copy(this._actualRotation).reorder(order);
    },

    _updateActualRotFromUserRot: function() {
        var order = this._actualRotation.order;
        this._actualRotation.copy(this._userRotation).reorder(order);
    }

});




// setObjTransform puzzle
function setObjTransform(objSelector, mode, vector, offset){
    var x = vector[0];
      var y = vector[1];
      var z = vector[2];

    var objNames = retrieveObjectNames(objSelector);

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    var inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''),
            Number(z !== ''));
    var coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.MathUtils.DEG2RAD);
    }

    var coordSystem = getCoordSystem();

    coordsTransform(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    coordsTransform(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (var i = 0; i < objNames.length; i++) {

        var objName = objNames[i];
        if (!objName) continue;

        var obj = getObjectByName(objName);
        if (!obj) continue;

        if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            var euler = eulerV3DToBlenderShortest(obj.rotation, _pGlob.eulerTmp);
            coordsTransform(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            var rotUI = RotationInterface.initObject(obj);
            var euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

        }

        obj.updateMatrixWorld(true);
    }

}



// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {
    var camera = appInstance.getCamera();

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = coordsTransform(worldPos, getCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = coordsTransform(worldTarget, getCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(worldPos);
        }
        camera.position.copy(worldPos);
        camera.lookAt(worldTarget);
        doSlot();
    }
}



function setObjectSelectability() {
    return (function

//____________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        objInput,
        selectabilityDropdown
    )
    {

//________________________________________________________________________________
//  DECLARE VARIABLES

    const puzzleName = 'Set Object Selectability';
//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !objInput ) {
            console.log('[ GLIFTEK ]: The',puzzleName,'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

        function mainFunction()
        {

//________________________________________________________________________________
//____________________________________________________________________________________
//  PUZZLE CORE CODE

            let objArray;

            arrayCheck();

            function arrayCheck()
            {

                //	if not array make array and insert object, name and insert to list.
                if ( !Array.isArray(objInput) )
                {
                    const objArray = [];
                    objArray.push(objInput);
                    objArray.forEach(setSelectability);
                }

                //	if array name and insert to list
                else if( Array.isArray(objInput) )
                {
                    objArray = objInput;
                    objArray.forEach(setSelectability);
                }

            };	//	END	arrayCheck



            function setSelectability( element )
            {

                let objInputObj;

                if ( element instanceof v3d.Mesh ) {
                    objInputObj = element;
                }   else {
                    objInputObj = app.scene.getObjectByName(element);
                }

                if ( !window.raycastFunction )
                {
                    window.raycastFunction = objInputObj.raycast;
                };

                if ( selectabilityDropdown == 'selectable' )
                {
                    objInputObj.raycast = window.raycastFunction;
                }
                else if ( selectabilityDropdown == 'unselectable' )
                {
                    objInputObj.raycast = function() {};
                }

            };  //  END setSelectability

//________________________________________________________________________________
        }; // END mainFunction
//____________________________________________________________________________________
// PUZZLE OUTPUT

    }).apply(null, arguments);
}


// Describe this function...
function MAIN() {
  FADE_IN();
  lens_flare_counter = 1;
  LIST_bg_images = ['./img/bg_clouds_pink_purple.jpg', './img/bg_blue_dark_cloudy.jpg', './img/bg_clouds_godrays_02.jpg'];
  LFD_GLOW_Settings_02 = null;
  center_alpha_distance_02 = null;
  setObjTransform('Lens_Flare_Point_Light', 'position', [2.75, 224638.07, 7844.53], true);
  tweenCamera('', 'Lens_Flare_Point_Light', 0.0001, function() {}, 0);

          setObjectSelectability
          (
              'Text',
              'unselectable'
          );
      CAMERA_CONSTRAINTS();
  CLICK_NEXTFLARE_3D_HITBOX();
  INIT_ALL_LENS_FLARE_SETTINGS();
  LENS_FLARE_DELUXE_1();
}


function screenFade() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        screenFade_ID_Input,
        screenFade_Z_Index_Input,
        typeDropdown,
        screenFade_Pause_Input,
        screenFade_Duration_Input,
        colorInput_1_PICKER,
        colorInput_1_TEXT,
        delete_When_Done_Checkbox,
        whenDone_Statement_Input,
    )
    {   //  BEGIN Plug.provide Function


//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Print To Modal Card';

        eval(`window.${screenFade_ID_Input} = { faded: null };`);

//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !screenFade_ID_Input ) {
            console.log('[ GLIFTEK ]: The',puzzleName, 'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

        // mainFunction();
        function mainFunction()
        {

//________________________________________________________________________________
//  PUZZLE CORE CODE


            function setColorFromInputs(colorInput_TEXT, colorInput_PICKER)
            {
                let colorInput_esc;

                if ( typeof colorInput_TEXT == 'undefined' || typeof colorInput_TEXT == null || colorInput_TEXT == '' )
                {
                    // colorInput_esc = colorInput_PICKER.substring(1);
                    colorInput_esc = colorInput_PICKER;
                    console.log(colorInput_PICKER,'supplied. using PICKER.');
                }
                else
                {
                    // colorInput_esc = colorInput_TEXT.substring(1);
                    colorInput_esc = colorInput_TEXT;
                    console.log(colorInput_TEXT,'supplied. using TEXT.');
                }

                return colorInput_esc
            };

            const colorInput_1esc = setColorFromInputs(colorInput_1_TEXT, colorInput_1_PICKER);

            console.log('colorInput_1esc:',colorInput_1esc);




            let computedColorDiv = document.createElement("div");
            computedColorDiv.id = 'computedColorDiv-' + screenFade_ID_Input;
            document.body.appendChild(computedColorDiv);



            function RGBA_from_color_input(color,alpha)
            {
                if
                (
                        color == 'transparent'
                    ||  color == null
                    ||  typeof color == 'undefined'
                )
                {
                    return 'rgba(0, 0, 0, 0)';
                }
                else
                {
                    computedColorDiv.style.color = color;
                    let computedColor = window.getComputedStyle(computedColorDiv).color;

                    console.log('computedColor for: ',color,':',computedColor);

                    let len = computedColor.length;
                    let computedColor_RGBA =
                    'rgba(' + computedColor.substring(4, len-1) + ", " + alpha +')';

                    console.log('computedColor_RGBA for: ',color,':',computedColor_RGBA);

                    return computedColor_RGBA;
                };
            };


            const screenFadeColor = RGBA_from_color_input ( colorInput_1esc, 1 );
            console.log('screenFadeColor: ',screenFadeColor);

            computedColorDiv.remove();


//________________________________________________________________________________
//  SET CSS


            let styleVar = setstyleVar();  //  sets all modal styles

            let style = document.createElement('style');

            style.id = 'screenFade-' + screenFade_ID_Input;

            style.innerHTML = styleVar;

            document.head.appendChild(style);



//________________________________________________________________________________
//  MAKE SCREEN FADE DIV


            let screenFade_Div = document.createElement('div');

            screenFade_Div.id = screenFade_ID_Input;

            screenFade_Div.className = 'screenFade-' + screenFade_ID_Input;



            getBGcolor();

            function getBGcolor()
            {
                if ( typeDropdown  == 'in' )
                    {
                        screenFade_Div.style.backgroundColor = 'rgba(0,0,0,0)';
                        console.log('screenFade_Div.style.backgroundColor:',screenFade_Div.style.backgroundColor);
                    }
                    else if ( typeDropdown  == 'out' )
                    {
                        screenFade_Div.style.backgroundColor = screenFadeColor;
                        console.log('screenFade_Div.style.backgroundColor:',screenFade_Div.style.backgroundColor);
                    }

            }



            const container = document.getElementById('v3d-container');

            container.appendChild(screenFade_Div);



//________________________________________________________________________________
//  SCREEN FADE ANIMATION

            setTimeout(function(){ animateScreenFade(); }, ( screenFade_Pause_Input * 1000 ) );


            function animateScreenFade()
            {
                const animationType = 'animation-screen-fade-' + typeDropdown + '-' + screenFade_ID_Input;

                screenFade_Div.style.animationName = animationType;

                console.log('screenFade_Div.style.animationName:',screenFade_Div.style.animationName);

                screenFade_Div.addEventListener('animationend', function(event)

                {
                    if ( event.animationName == animationType );
                    {
                        screenFade_Div.removeEventListener('animationend',null);

                        screenFadeDisplay();

                        let screenFadeState = eval(`${screenFade_ID_Input}.faded = '${typeDropdown}';`);
                        console.log('screenFadeState:',screenFadeState);

                        whenDone_Statement_Input();
                    }
                });


                function screenFadeDisplay()
                {
                    if ( typeDropdown  == 'in' )
                    {
                        screenFade_Div.style.display = 'block';
                        console.log('screenFade_Div.style.display:',screenFade_Div.style.display);
                        deleteWhenDone();
                    }
                    else if ( typeDropdown  == 'out' )
                    {
                        screenFade_Div.style.display = 'none';
                        console.log('screenFade_Div.style.display:',screenFade_Div.style.display);
                        deleteWhenDone();
                    }

                }

                function deleteWhenDone()
                {
                    if ( delete_When_Done_Checkbox == true )
                    {
                        screenFade_Div.remove();
                    }
                }

            };

//________________________________________________________________________________
//  SCREEN FADE DIV CSS

            function setstyleVar()
            {
                let result =
                `
                #computedColorDiv-${screenFade_ID_Input}
                {
                    height: 0px;
                    width: 0px;
                    display: none;
                    z-index = -10;
                }

                .screenFade-${screenFade_ID_Input}
                {
                    display: block;
                    position: fixed;
                    z-index: ${screenFade_Z_Index_Input};
                    left: 0;
                    top: 0;
                    height: 100%;
                    width: 100%;
                    overflow: hidden;
                    pointer-events: none;

                    animation-duration: ${screenFade_Duration_Input}s;
                    animation-timing-function: ease-in-out;
                }


                @keyframes animation-screen-fade-in-${screenFade_ID_Input}
                {
                    from {
                        background-color: rgba(0,0,0,0);
                    }
                    to {
                        background-color: ${screenFadeColor};
                    }
                }


                @keyframes animation-screen-fade-out-${screenFade_ID_Input}
                {
                    from {
                        background-color: ${screenFadeColor};
                    }
                    to {
                        background-color: rgba(0,0,0,0);
                    }
                }

                `;

                return result;
            };

//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}



function setImageBackground() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        // sundiskCheckbox,
        imageURLInput,
    )
    {   //  BEGIN Plug.provide Function


//________________________________________________________________________________
//  MAIN FUNCTION

        mainFunction();
        function mainFunction()
        {

//________________________________________________________________________________
//  PUZZLE CORE CODE

            let bgTexture = new THREE.TextureLoader()
            .load(imageURLInput);

            bgTexture.minFilter = THREE.LinearFilter;

            app.scene.background = bgTexture;

            app.scene.background.encoding = THREE.sRGBEncoding;

//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function FADE_IN() {

          screenFade
          (
              'screenFade_1',
              10,
              'out',
              1.5,
              1,
              '#000000',
              '',
              true,
              function() {},
          )

          setImageBackground
          (
              './img/bg_clouds_pink_purple.jpg',
          )
      }


// utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
function initObjectPicking(callback, eventType, mouseDownUseTouchStart, mouseButtons) {

    var elem = appInstance.renderer.domElement;
    elem.addEventListener(eventType, pickListener);
    if (v3d.PL.editorEventListeners)
        v3d.PL.editorEventListeners.push([elem, eventType, pickListener]);

    if (eventType == 'mousedown') {

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        elem.addEventListener(touchEventName, pickListener);
        if (v3d.PL.editorEventListeners)
            v3d.PL.editorEventListeners.push([elem, touchEventName, pickListener]);

    } else if (eventType == 'dblclick') {

        var prevTapTime = 0;

        function doubleTapCallback(event) {

            var now = new Date().getTime();
            var timesince = now - prevTapTime;

            if (timesince < 600 && timesince > 0) {

                pickListener(event);
                prevTapTime = 0;
                return;

            }

            prevTapTime = new Date().getTime();
        }

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        elem.addEventListener(touchEventName, doubleTapCallback);
        if (v3d.PL.editorEventListeners)
            v3d.PL.editorEventListeners.push([elem, touchEventName, doubleTapCallback]);
    }

    var raycaster = new v3d.Raycaster();

    function pickListener(event) {

        // to handle unload in loadScene puzzle
        if (!appInstance.getCamera())
            return;

        event.preventDefault();

        var xNorm = 0, yNorm = 0;
        if (event instanceof MouseEvent) {
            if (mouseButtons && mouseButtons.indexOf(event.button) == -1)
                return;
            xNorm = event.offsetX / elem.clientWidth;
            yNorm = event.offsetY / elem.clientHeight;
        } else if (event instanceof TouchEvent) {
            var rect = elem.getBoundingClientRect();
            xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
            yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
        }

        _pGlob.screenCoords.x = xNorm * 2 - 1;
        _pGlob.screenCoords.y = -yNorm * 2 + 1;
        raycaster.setFromCamera(_pGlob.screenCoords, appInstance.getCamera(true));
        var objList = [];
        appInstance.scene.traverse(function(obj){objList.push(obj);});
        var intersects = raycaster.intersectObjects(objList);
        callback(intersects, event);
    }
}

function objectsIncludeObj(objNames, testedObjName) {
    if (!testedObjName) return false;

    for (var i = 0; i < objNames.length; i++) {
        if (testedObjName == objNames[i]) {
            return true;
        } else {
            // also check children which are auto-generated for multi-material objects
            var obj = getObjectByName(objNames[i]);
            if (obj && obj.type == "Group") {
                for (var j = 0; j < obj.children.length; j++) {
                    if (testedObjName == obj.children[j].name) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

// utility function used by the whenClicked, whenHovered, whenDraggedOver, and raycast puzzles
function getPickedObjectName(obj) {
    // auto-generated from a multi-material object, use parent name instead
    if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
        return obj.parent.name;
    } else {
        return obj.name;
    }
}



// whenClicked puzzle
function registerOnClick(objSelector, xRay, doubleClick, mouseButtons, cbDo, cbIfMissedDo) {

    // for AR/VR
    _pGlob.objClickInfo = _pGlob.objClickInfo || [];

    _pGlob.objClickInfo.push({
        objSelector: objSelector,
        callbacks: [cbDo, cbIfMissedDo]
    });

    initObjectPicking(function(intersects, event) {

        var isPicked = false;

        var maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);
            var objNames = retrieveObjectNames(objSelector);

            if (objectsIncludeObj(objNames, objName)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = objName;
                isPicked = true;
                cbDo(event);
            }
        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo(event);
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}


// Describe this function...
function CLICK_NEXTFLARE_3D_HITBOX() {
  registerOnClick('Plane', false, false, [0,1,2], function() {
    SWITCH_FLARE();
  }, function() {});
}


// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
    }
}


// Describe this function...
function LENS_FLARE_DELUXE_ALL() {
  LIST_lens_flares = ['myLensFlare_01', 'myLensFlare_02'];
  current_lens_flare = 'myLensFlare_01';
  changeVis('myLensFlare_01', false);
  changeVis('myLensFlare_02', false);
}

// Describe this function...
function INIT_ALL_LENS_FLARE_SETTINGS() {
  LENS_FLARE_SETTINGS();
}


// objConstraintAddLimit puzzle
function objConstraintAddLimit(constraintName, objSelector, mode, min, max, targetObjName, dist, distLimitMode) {
    var objNames;
    if (mode == 'DISTANCE') {
        if (!targetObjName) return;
        var targetObj = getObjectByName(targetObjName);
        if (!targetObj) return;
    }

    objNames = retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        if (!objName) continue;

        var obj = getObjectByName(objName);
        if (!obj || !obj.constraints) continue;

        for (var j = obj.constraints.length - 1; j >= 0; j--) {
            if (obj.constraints[j].name == constraintName) {
                obj.constraints.splice(j, 1);
            }
        }

        var coordSystem = getCoordSystem();

        switch (mode) {
            case 'POS_X':
            case 'POS_Y':
            case 'POS_Z':
                var cons = new v3d.LimitLocationConstraint();
                cons.name = constraintName;

                if (coordSystem == 'Z_UP_RIGHT')
                    var compIndex = mode == 'POS_X' ? 0 : (mode == 'POS_Y' ? 2 : 1);
                else
                    var compIndex = mode == 'POS_X' ? 0 : (mode == 'POS_Y' ? 1 : 2);

                // swizzle sign and limits order
                if (coordSystem == 'Z_UP_RIGHT' && mode == 'POS_Y') {
                    cons.min.setComponent(compIndex, -max);
                    cons.max.setComponent(compIndex, -min);
                } else {
                    cons.min.setComponent(compIndex, min);
                    cons.max.setComponent(compIndex, max);
                }
                obj.constraints.push(cons);
                break;

            case 'ROT_X':
            case 'ROT_Y':
            case 'ROT_Z':
                var cons = new v3d.LimitRotationConstraint();
                cons.name = constraintName;

                if (coordSystem == 'Z_UP_RIGHT')
                    cons.axis = mode == 'ROT_X' ? 'X' : (mode == 'ROT_Y' ? 'Z' : 'Y');
                else
                    cons.axis = mode == 'ROT_X' ? 'X' : (mode == 'ROT_Y' ? 'Y' : 'Z');

                // swizzle sign and limits order
                if (coordSystem == 'Z_UP_RIGHT' && mode == 'ROT_Y') {
                    cons.min = v3d.MathUtils.degToRad(-max);
                    cons.max = v3d.MathUtils.degToRad(-min);
                } else {
                    cons.min = v3d.MathUtils.degToRad(min);
                    cons.max = v3d.MathUtils.degToRad(max);
                }

                obj.constraints.push(cons);
                break;

            case 'SCALE_X':
            case 'SCALE_Y':
            case 'SCALE_Z':
                var cons = new v3d.LimitScaleConstraint();
                cons.name = constraintName;

                if (coordSystem == 'Z_UP_RIGHT')
                    var compIndex = mode == 'SCALE_X' ? 0 : (mode == 'SCALE_Y' ? 2 : 1);
                else
                    var compIndex = mode == 'SCALE_X' ? 0 : (mode == 'SCALE_Y' ? 1 : 2);

                cons.min.setComponent(compIndex, min);
                cons.max.setComponent(compIndex, max);
                obj.constraints.push(cons);
                break;

            case 'DISTANCE':
                var cons =  new v3d.LimitDistanceConstraint(targetObj);
                cons.name = constraintName;
                cons.distance = dist;
                cons.limitMode = distLimitMode;
                obj.constraints.push(cons);
                break;
        }
    }
}


// Describe this function...
function CAMERA_CONSTRAINTS() {
  /* POSITION */
  objConstraintAddLimit('myConst_Cam_pos_X', 'Camera', 'POS_X', 80, 80, undefined, undefined, undefined);
  objConstraintAddLimit('myConst_Cam_pos_Y', 'Camera', 'POS_Y', 224540, 224540, undefined, undefined, undefined);
  objConstraintAddLimit('myConst_Cam_pos_Z', 'Camera', 'POS_Z', 7820, 7870, undefined, undefined, undefined);
  /* ROTATION */
  objConstraintAddLimit('myConst_Cam_rot_X', 'Camera', 'ROT_X', 0, 0, undefined, undefined, undefined);
  objConstraintAddLimit('myConst_Cam_rot_Y', 'Camera', 'ROT_Y', 0, 2.5, undefined, undefined, undefined);
  objConstraintAddLimit('myConst_Cam_rot_Z', 'Camera', 'ROT_Z', 6, 70, undefined, undefined, undefined);
}

// Describe this function...
function LENS_FLARE_SETTINGS() {
  INIT_RAYS_SETTINGS_1();
  INIT_GLOW_SETTINGS_1();
  INIT_BOKEH_SETTINGS_1();
  INIT_RAYS_SETTINGS_2();
  INIT_GLOW_SETTINGS_2();
  INIT_BOKEH_SETTINGS_2();
  INIT_RAYS_SETTINGS_3();
  INIT_GLOW_SETTINGS_3();
  INIT_BOKEH_SETTINGS_3();
}


function createLenseFlareFunction() {
    return (function
//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

(
    nameInput,
    objInput,

    activeCheckboxRAYS,
    flareSettingsRAYS,
    flareMasterSizeRAYS,
    flareMasterOpacityRAYS,

    activeCheckboxGLOW,
    flareSettingsGLOW,
    flareMasterSizeGLOW,
    flareMasterOpacityGLOW,

    activeCheckboxBOKEH,
    flareSettingsBOKEH,
    flareMasterSizeBOKEH,
    flareMasterOpacityBOKEH,

    flareMasterSize,
    flareMasterOpacity,

)
{   //  BEGIN Plug.provide Function


//________________________________________________________________________________
//  DECLARE VARIABLES

    const puzzleName = 'Lense Flare Deluxe';

    let readyToAddRAYS = false;
    let readyToAddGLOW = false;
    let readyToAddBOKEH = false;

    const LIST_flareArgsRAYS = [
        'rays','symmetrical','rayWidth','raySharpness','randomSeed','rotate', 'feBlur', 'opacity'
    ];
    const LIST_flareArgsGLOW = [
        'toneCenter', 'toneInner', 'toneMid','toneOuter', 'toneEdge', 'rotate', 'feBlur', 'opacity'
    ];
    const LIST_flareArgsBOKEH = [
        'shape', 'color', 'vert', 'rotate', 'feBlur', 'opacity'
    ];

    const varToString = varObj => Object.keys(varObj)[0]

    const renderer = app.renderer;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.antialias = true;

    const scene = app.scene;
    const camera = app.camera;

    let textureLoader = new THREE.TextureLoader();
    let clock = new THREE.Clock();

    let LIST_lensFlareRAYS = [];
    LIST_lensFlareRAYS.name = 'LIST_lensFlareRAYS';
    let LIST_lensFlareGLOW = [];
    LIST_lensFlareGLOW.name = 'LIST_lensFlareGLOW';
    let LIST_lensFlareBOKEH = [];
    LIST_lensFlareBOKEH.name = 'LIST_lensFlareBOKEH';

    let LIST_lensFlareALL =
    [
        LIST_lensFlareRAYS,
        LIST_lensFlareGLOW,
        LIST_lensFlareBOKEH,
    ];

    let lensflare;
    let light;
    let selectedLight;

    let MAP_LF_Bokeh_Polygons = new Map();

    let BOKEH_line,
    BOKEH_circle,
    BOKEH_ellipse,
    BOKEH_triangle,
    BOKEH_square,
    BOKEH_pentagon,
    BOKEH_hexagon,
    BOKEH_heptagon,
    BOKEH_octagon,
    BOKEH_nonagon;


//________________________________________________________________________________
//  NO INPUT ERROR CHECK

    if ( !objInput || objInput == '<none>' ) {
        console.log('[ GLIFTEK ]: The ',puzzleName, 'plugin puzzle is missing an input!');
    }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

    // mainFunction ();
    function mainFunction()
    {
//________________________________________________________________________________

        if ( !window.lensflareJS_var )
        {
            window.lensflareJS_var = lensFlareJS();
        }


        checkboxFALSEcheck();

        function checkboxFALSEcheck()
        {

            if
            (
                activeCheckboxRAYS == false &&
                activeCheckboxGLOW == false &&
                activeCheckboxBOKEH == false
            )
            { console.log('[ GLIFTEK ] Plugins: Lens Flare Deluxe all settings disabled.')}
            else { checkboxRAYScheck(); }


            function checkboxRAYScheck()
            {
                if (activeCheckboxRAYS == false) {readyToAddRAYS = true;
                    // console.log("'RAYS' readyToAdd is true.")
                };
                checkboxGLOWcheck();
            }

            function checkboxGLOWcheck()
            {
                if (activeCheckboxGLOW == false) {readyToAddGLOW = true
                    // console.log("'GLOW' readyToAdd is true.")
                };
                checkboxBOKEHcheck();
            }

            function checkboxBOKEHcheck()
            {
                if (activeCheckboxBOKEH == false) {readyToAddBOKEH = true
                    // console.log("'BOKEH' readyToAdd is true.")
                };

                init();
            }


        };	//	END	checkboxFALSEcheck()


        function init()
        {

            loadAllLensFlareTextures();

            promiseFunctionOBJ(objInput, loadJSandTextures );

            function loadJSandTextures(selectedLight)
            {
                light = scene.getObjectByName(selectedLight);
                // console.log('selectedLight in makeLensFlare:', selectedLight);
                checkboxTRUEcheck();
                waitToAddAllFlares();
            };
        };	//	END init;


        function checkboxTRUEcheck()
        {

            if (activeCheckboxRAYS == true)
            {

                if ( !flareSettingsRAYS ) {

                    console.log('[ GLIFTEK ]: Lens Flare Deluxe Rays settings missing. Using default settings.');
                    flareSettingsRAYS = [];
                    flareSettingsRAYS.name = 'flareSettingsRAYS';

                    const MAP_LF_Settings_RAYS_DEFAULT_item_1 =
                    new Map
                    ([
                        ['type' , 'RAYS'],
                        ['shape' , 'RAYS'],

                        ['rays' , 12],
                        ['nameInput' , 'default_rays_01'],
                        ['symmetrical' , false],
                        ['rayWidth' , 1],
                        ['raySharpness' , .9],
                        ['randomSeed' , 10],

                        ['rotate' , 0],
                        ['feBlur' , 0.2],
                        ['opacity' , 0.9],

                        ['size' , 500],
                        ['distance' , 0],
                        ['color' , 'teal'],
                    ]);

                    const MAP_LF_Settings_RAYS_DEFAULT_item_2 =
                    new Map
                    ([
                        ['type' , 'RAYS'],
                        ['shape' , 'RAYS'],

                        ['rays' , 6],
                        ['nameInput' , 'default_rays_01'],
                        ['symmetrical' , true],
                        ['rayWidth' , 1],
                        ['raySharpness' , .9],
                        ['randomSeed' , 0],

                        ['rotate' , 0],
                        ['feBlur' , 0.1],
                        ['opacity' , 0.98],

                        ['size' , 600],
                        ['distance' , 0],
                        ['color' , 'cyan'],
                    ]);

                    flareSettingsRAYS.push(MAP_LF_Settings_RAYS_DEFAULT_item_1);
                    flareSettingsRAYS.push(MAP_LF_Settings_RAYS_DEFAULT_item_2);
                    makeFlares( flareSettingsRAYS );
                }
                else
                {
                    arrayCheck( flareSettingsRAYS );
                };
            };



            if (activeCheckboxGLOW == true)
            {
                if ( !flareSettingsGLOW ) {

                    console.log('[ GLIFTEK ]: Lens Flare Deluxe Glow settings missing. Using default settings.');
                    flareSettingsGLOW = [];
                    flareSettingsGLOW.name = 'flareSettingsGLOW';

                    const MAP_LF_Settings_GLOW_DEFAULT_item_1 =
                    new Map
                    ([
                        ['type' , 'GLOW'],
                        ['shape' , 'GLOW_circle'],

                        ['toneCenter' , 0],

                        ['toneInner' , 0.2],
                        ['toneMid' , 0.3],
                        ['toneOuter' , 0.99],

                        ['toneEdge' , 1],

                        ['rotate' , 0],
                        ['feBlur' , 0],
                        ['opacity' , 0.6],

                        ['size' , 300],
                        ['distance' , .0001],
                        ['color' , 'darkorange'],
                    ]);

                    const MAP_LF_Settings_GLOW_DEFAULT_item_2 =
                    new Map
                    ([
                        ['type' , 'GLOW'],
                        ['shape' , 'GLOW_circle'],

                        ['toneCenter' , 0],

                        ['toneInner' , 0.1],
                        ['toneMid' , 0.2],
                        ['toneOuter' , 0.99],

                        ['toneEdge' , 1],

                        ['rotate' , 0],
                        ['feBlur' , 0],
                        ['opacity' , 0.5],

                        ['size' , 700],
                        ['distance' , 0],
                        ['color' , 'yellow'],
                    ]);

                    flareSettingsGLOW.push(MAP_LF_Settings_GLOW_DEFAULT_item_1);
                    flareSettingsGLOW.push(MAP_LF_Settings_GLOW_DEFAULT_item_2);
                    makeFlares( flareSettingsGLOW );
                }
                else
                {
                    arrayCheck(flareSettingsGLOW);
                };
            };



            if (activeCheckboxBOKEH == true)
            {

                if ( !flareSettingsBOKEH ) {

                    console.log('[ GLIFTEK ]: Lens Flare Deluxe Bokeh settings missing. Using default settings.');
                    flareSettingsBOKEH = [];
                    flareSettingsBOKEH.name = 'flareSettingsBOKEH';

                    const MAP_LF_Settings_BOKEH_DEFAULT_item_1 =
                    new Map
                    ([
                        ['type' , 'BOKEH'],
                        ['shape' , 'BOKEH_hexagon'],

                        ['vert' , 0],

                        ['rotate' , 0],
                        ['feBlur' , 0.2],
                        ['opacity' , 0.6],

                        ['size' , 1],
                        ['distance' , 0.9 ],
                        ['color' , 'cyan'],
                    ]);

                    const MAP_LF_Settings_BOKEH_DEFAULT_item_2 =
                    new Map
                    ([
                        ['type' , 'BOKEH'],
                        ['shape' , 'BOKEH_hexagon'],

                        ['vert' , 2],

                        ['rotate' , 0],
                        ['feBlur' , 0.2],
                        ['opacity' , 0.6],

                        ['size' , 1],
                        ['distance' , 0],
                        ['color' , 'cyan'],
                    ]);

                    flareSettingsBOKEH.push(MAP_LF_Settings_BOKEH_DEFAULT_item_1);
                    flareSettingsBOKEH.push(MAP_LF_Settings_BOKEH_DEFAULT_item_2);
                    makeFlares( flareSettingsBOKEH );
                }
                else
                {
                    arrayCheck(flareSettingsBOKEH);
                };
            };
        };	//	END checkboxTRUEcheck()



        function arrayCheck(input)
        {

            //	if not array make array and insert object, name and insert to list.
            if ( !Array.isArray(input) )
            {
                const settings = [];
                settings.name = 'flareSettings' + input.get('type');
                settings.push(input);

                console.log('settings:',settings);
                makeFlares( settings );
            }

            //	if array name and insert to list
            else if( Array.isArray(input) )
            {
                input.name = 'flareSettings' + input[0].get('type');
                makeFlares( input );
            }

        };	//	END	arrayCheck

//________________________________________________________________________________


    function svgUriEncode(svgCode)
    {
        const svgDataHeader =
        'data:image/svg+xml,';

        const svgXmlnsHeader =
        " <svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' ";

        const svgFooter = "</svg>";

        let svgDataURIEncoded =
        encodeURIComponent(svgXmlnsHeader + svgCode + svgFooter);

        let svgDataOutput =
        svgDataHeader.concat(svgDataURIEncoded);

        return svgDataOutput;
    };


//________________________________________________________________________________

    // console.log('objInput: ',objInput);

    // if ( typeof objInput !== undefined ) {
        // let objInputObj;
        // if ( objInput instanceof v3d.Light ) {
        //     objInputObj = objInput;
        // }   else {
        //     objInputObj = app.scene.getObjectByName(objInput);
        // };
    // }
    // console.log('objInputObj: ',objInputObj);

//________________________________________________________________________________
// MAKE LENS FLARE

    //	TODO! get window width and height and recompute flareSize to be responsive!


    //	THREE.js Lenseflare instructions
    // 	LensflareElement( texture : Texture, size : Float, distance : Float, color : Color )
    // 	texture - THREE.Texture to use for the flare.
    // 	size - (optional) size in pixels
    // 	distance - (optional) (0-1) from light source (0 = at light source)
    // 	color - (optional) the Color of the lens flare

//________________________________________________________________________________
// MAKE LENSE FLARE ELEMENTS

    function makeFlares(flareSettings)
    {

        // console.log('running makeFlares for: ',flareSettings.name);

        let textureFlare;

        let flareSettingsIterations = flareSettings.length;

        for (let i = 0; i < flareSettingsIterations; i++)
        {

            const item = flareSettings[i];
            const itemType = item.get('type');
            const itemDistance = item.get('distance');
            let args;


            let flareArgsRAYS = [];
            let flareArgsGLOW = [];
            let flareArgsBOKEH = [];

            function makeArgsList(inputList, ArgList)
            {
                inputList.forEach(element => ArgList.push( item.get(element) )   );
                return ArgList
            };

            function flareCaseFunction(flareType)
            {
                makeFlareElement(
                    makeTextureFlare(
                        makeArgsList 	(
                            eval(`LIST_flareArgs${flareType}`),	// inputList
                            eval(`flareArgs${flareType}`)	//	ArgList
                                        )
                                    ),
                            eval(`flareMasterSize${flareType}`) * flareMasterSize,
                            itemDistance,
                            ifLastSettingsIteration
                                );
            };


            switch(itemType) {

                case 'RAYS' : case 'GLOW' : flareCaseFunction(itemType); break;

                case 'BOKEH' :

                    // const LIST_flareSizesBOKEH =
                    // 	[
                    // 		60, 70, 120, 70
                    // 	];

                    // const LIST_flareDistancesBOKEH =
                    // 	[
                    // 		0.6, 0.7, 0.9, 2
                    // 	];

                    const LIST_flareSizesBOKEH =
                        [
                            60, 70, 120, 70
                        ];

                    // console.log('itemDistance:',itemDistance);
                    let LIST_flareDistancesBOKEH;

                    if ( itemDistance !== 0)
                    {
                        LIST_flareDistancesBOKEH =
                        [
                            0.6 * itemDistance,
                            0.7 * itemDistance,
                            0.9 * itemDistance,
                            2 * itemDistance,
                        ];
                    }
                    else
                    {
                        LIST_flareDistancesBOKEH =
                            [
                                0.6, 0.7, 0.9, 2
                            ];
                    };

                    const amountBOKEH = LIST_flareSizesBOKEH.length;

                    for (let j = 0; j < amountBOKEH ; j++)
                        {
                            makeFlareElement (
                                makeTextureFlare (
                                    makeArgsList(LIST_flareArgsBOKEH, flareArgsBOKEH) ),
                                    1.5 * (LIST_flareSizesBOKEH[j] * flareMasterSizeBOKEH * flareMasterSize),
                            LIST_flareDistancesBOKEH[j],
                            ifLastSettingsIteration, j );
                        }

            };	//	END switch



            function makeTextureFlare(args)
            {
                // console.log(itemType,'args IN MAKE TEXTURE:',args);

                let shapeOrType;
                if (itemType == 'BOKEH') { shapeOrType = 'type' }
                else { shapeOrType = 'shape'};

                const svgCodeName = 'svgCode_' + item.get(shapeOrType);
                console.log('svgCodeName, args',svgCodeName,...args);

                const svgData = eval(svgCodeName)( ...args ); /// "..." spreads array

                const textureFlare = textureLoader.load( svgData );
                textureFlare.name = 'textureFlare' + itemType + '_' + i;

                return textureFlare;
            };



            function makeFlareElement(textureFlare,sizeMultiplier,itemDistance,callback,iteration)
            {
                const flareColor = new THREE.Color( item.get('color') );

                const newFlare =
                new THREE.LensflareElement(
                    textureFlare,
                    item.get('size') * sizeMultiplier,
                    itemDistance,
                    flareColor
                );

                if (itemType !== 'BOKEH') { iteration = i }

                newFlare.name = 'lensFlare' + itemType + '_' + iteration;

                let list = 'LIST_lensFlare' + itemType;

                eval(list).push(newFlare);

                callback(itemType);
            };


            function ifLastSettingsIteration()
            {
                if((i + 1) == (flareSettingsIterations))
                {readyToAddFunc(itemType)}
            }


            function readyToAddFunc(itemType)
            {
                switch(itemType) {
                    case 'RAYS' : readyToAddRAYS = true;
                    break;
                    case 'GLOW' : readyToAddGLOW = true;
                    break;
                    case 'BOKEH' : readyToAddBOKEH = true;
                    break;
                };
            };

        };	//	END for Loop

    };	//	END	makeFlare()


//________________________________________________________________________________
// MAKE OBJECT AND ADD FLARES



        function createLensFlareObject()
        {

            lensflare = new THREE.Lensflare();

            lensflare.name = nameInput;

            light.add( lensflare );


        //     let lensflareCountVar;


        //     if (typeof window.LIST_lensflare_Names == 'undefined')
        //     {

        //         window.LIST_lensflare_Names = [];

        //         lensflare.name = nameInput;

        //         LIST_lensflare_Names.push(lensflare.name);

        //         console.log('LIST_lensflare_Names CREATED. adding:', LIST_lensflare_Names);


        //         light.add( lensflare );

        //     }


        //     else if (typeof window.LIST_lensflare_Names !== 'undefined')
        //     {

        //         add_to_LIST_lensflare_Names();

        //     }



        //     function add_to_LIST_lensflare_Names()
        //     {
        //         console.log('LIST_lensflare_Names:',LIST_lensflare_Names);

        //         let does_contain = LIST_lensflare_Names.includes(nameInput);
        //         console.log('does_contain = LIST_lensflare_Names.find(nameInput):',does_contain);

        //         if ( !LIST_lensflare_Names.includes(nameInput) )
        //         {
        //             lensflare.name = nameInput;
        //             LIST_lensflare_Names.push(lensflare.name);
        //             light.add( lensflare );
        //         }

        //         else if ( LIST_lensflare_Names.includes(nameInput) )
        //         {

        //             let alert_message = 'lens flare name: "' + nameInput + '" is already in use.  Please choose another name.';

        //             alert(alert_message);

        //         }

        //    };
        // };






            // if (typeof window.lensflareCount == 'undefined')
            // {

            //     window.lensflareCount = 1;

            //     lensflareCountVar = '0' + lensflareCount;

            //     lensflare.name = nameInput + '_' + lensflareCountVar;

            // }

            // else
            // {
            //     lensflareCount += 1;

            //     if ( lensflareCount < 10 )
            //     {
            //         lensflareCountVar = '0' + lensflareCount;
            //         console.log('lensflareCountVar:',lensflareCountVar);
            //         lensflare.name = nameInput + '_' + lensflareCountVar;
            //     }
            //     else if ( lensflareCount >= 10 )
            //     {
            //         lensflareCountVar = lensflareCount.toString();
            //         console.log('lensflareCountVar:',lensflareCountVar);
            //         lensflare.name = nameInput + '_' + lensflareCountVar;
            //     }
            // }



            // lensflare.name = 'lensflare_' + lensflareCount;
            // function addLensFlareToLight()
            // {
            //     light.add( lensflare );
            // }


            };

        // 	// attempt at removing black square artifact when transparent background is used...
        // 	// enable transparency
        // 	// lensflare.material.transparent = true;
        // 	// // set opacity to 50%
        // 	// lensflare.material.opacity = 0;

        // 	light.add( lensflare );
        // 	lensflare.name = 'lensflare';
        // 	promiseFunctionVAR (lensflare, callback);

        // };


        function waitToAddAllFlares()
        {
            createLensFlareObject();

            // console.log('Waiting for all flare elements.');

            // console.log('readyToAddRAYS:',readyToAddRAYS);
            // console.log('readyToAddGLOW:',readyToAddGLOW);
            // console.log('readyToAddBOKEH:',readyToAddBOKEH);

            var intervalId = setInterval(() => {

                if	(
                    readyToAddRAYS == true &&
                    readyToAddGLOW == true &&
                    readyToAddBOKEH == true
                    )
                {
                    clearInterval(intervalId);
                    addAllFlares();
                }
            }, 100)


            function addAllFlares()
            {
                // console.log('adding all flares');

                checkboxRAYSaddFlareCheck();

                function checkboxRAYSaddFlareCheck()
                {
                    if (activeCheckboxRAYS == true)
                    {
                        addRays();
                    }
                    else
                    {
                        checkboxGLOWaddFlareCheck()
                    }
                }

                function checkboxGLOWaddFlareCheck()
                {
                    if (activeCheckboxGLOW == true)
                    {
                        addGlows();
                    }
                    else
                    {
                        checkboxBOKEHaddFlareCheck()
                    }
                }

                function checkboxBOKEHaddFlareCheck()
                {
                    if (activeCheckboxBOKEH == true)
                    {
                        addBokeh();
                    }
                    else
                    {
                        done();
                    }
                }

                function addRays(){
                    // console.log('adding RAYS flares using: LIST_lensFlareRAYS:',LIST_lensFlareRAYS);
                    addLensFlareElementsToLensFlareObject(LIST_lensFlareRAYS,
                    checkboxGLOWaddFlareCheck)
                };
                function addGlows(){
                    // console.log('adding GLOW flares using: LIST_lensFlareGLOW:',LIST_lensFlareGLOW);
                    addLensFlareElementsToLensFlareObject(LIST_lensFlareGLOW,
                    checkboxBOKEHaddFlareCheck)
                };
                function addBokeh(){
                    // console.log('adding BOKEH flares using: LIST_lensFlareBOKEH:',LIST_lensFlareBOKEH);
                    addLensFlareElementsToLensFlareObject(LIST_lensFlareBOKEH,
                    done)
                };
            }
        };	//	END addAllFlares

//________________________________________________________________________________
//


        function addLensFlareElementsToLensFlareObject(LIST_LensFlares, callback)
        {

            for (let i = 0; i < LIST_LensFlares.length; i++)
            {
                let item = LIST_LensFlares[i];
                lensflare.addElement( item );
                // lensflare.id = idInput;
                console.log('lensflare',lensflare);
                // console.log(item.name,'added to lensflare object:',item);

                if (i == LIST_LensFlares.length -1 )
                {
                    // console.log(LIST_LensFlares.name,' length met. running next function.');
                    callback();
                }
            }
        };


        function done()
        {
            // console.log('done');

            //	attempt at blocking bokeh reflections in 'Generate Ocean' plugin
            // 	console.log('scene: ', scene);
            // 	console.log('light: ', light);
            // 	console.log('lensflare: ', lensflare);

            // 	var intervalId = setInterval(() => {
            // 	if (typeof mirrorCamRendering !== 'undefined' )
            // 		{
            // 		console.log('mirrorCamRendering: ', mirrorCamRendering);
            // 		clearInterval(intervalId);
            // 		animate()
            // 		}
            // 	}, 100)

        }


        // function animate() {

        // 	requestAnimationFrame( animate );
        // 	visibility()
        // }


        // function visibility()
        // {

        // 	//	attempt at blocking bokeh reflections in 'Generate Ocean' plugin

        // 	if (typeof mirrorCamRendering !== 'undefined' )
        // 	{
        // 		if (mirrorCamRendering == true)
        // 		{
        // 			lensflare.visible = false;
        // 			console.log('lensflare.visible: ', lensflare.visible);
        // 		}

        // 		else if (mirrorCamRendering == false)
        // 		{
        // 			lensflare.visible = true;
        // 			console.log('lensflare.visible: ', lensflare.visible);
        // 		}
        // 	};

        // }

//________________________________________________________________________________
// LENSE FLARE RAYS TEXTURES

    function svgCode_RAYS ( rays, symmetrical, rayWidth, raySharpness, randomSeed, rotate, feBlur, opacity  )
    {

        // console.log(
        // 	'rays',rays,
        // 	'symmetrical',symmetrical,
        // 	'rayWidth',rayWidth,
        // 	'raySharpness',raySharpness,
        // 	'randomSeed',randomSeed,
        // 	'rotate',rotate,
        // 	'feBlur',feBlur,
        // 	'opacity',opacity,
        // );

        if ( randomSeed !== 0 &&	( randomSeed > 10 || randomSeed < 1  ) )
        {
            console.log('[ GLIFTEK ]: Lens Flare Rays Settings puzzle "random ray lengths" input must be between 1 and 10. Set to 0 to disable. Setting to 0.');
            alert('[ GLIFTEK ]: Lens Flare Rays Settings puzzle "random ray lengths" input must be between 1 and 10. Set to 0 to disable. Setting to 0');
        };


        function randomFlareRayLengths(randomSeed)
        {
            if (randomSeed == 0)
            {
                const result = 1;
                return result;
            }
            else if ( randomSeed > 10 || randomSeed < 1  )
            {
                const result = 1;
                return result;
            }
            else
            {
                const result = (Math.floor(Math.random() * randomSeed) + 1) * .1 ;
                return result;
            }

        };

        const offsetX = '0';// use later for 'spiral' options
        const offsetY = '0';

        let raysIteration = '';

        let masking = ``;
        // console.log('symmetrical: ',symmetrical);


        function makeIteration( i )
        {
            let degPerStreak = 360 / ( rays );
            let rotateDeg = degPerStreak * i

            let rayOpacity = 1; // use later for varying ray opacity

            const randomLength = randomFlareRayLengths(randomSeed);
            // console.log('randomSeed: ',randomSeed,'  randomLength: ',randomLength);

            let result =
            `<g transform=
            'rotate(${rotateDeg},300,300)'>
            <use
            class='rayUse'
            xlink:href='#raySymbol'
            transform='scale(${randomLength},${rayWidth})'/>
            </g>`;

            return result
        };


        if (symmetrical == true)
        {
            masking = ``;

            if ( rays % 2 !== 0 )	// change for single half streaks
            {
                rays++
                console.log('[ GLIFTEK ] Lens Flare Rays Settings: Only an even number of rays can be symmetrical. Changing "ray count" up to: ',rays);
            }

            for(let i=0; i<(rays / 2); i++)
            {
                raysIteration += makeIteration(i);
            }
        }

        else if (symmetrical == false)
        {
            masking = `mask:url(#mask)`;

            for(let i=0; i<(rays); i++)
            {
                raysIteration += makeIteration(i);
            }
        };

        let totalTransforms =
        `transform='rotate(${rotate},300,300)' opacity='${opacity * flareMasterOpacityRAYS * flareMasterOpacity}' filter='url(#blur)'`;

        let result = svgUriEncode
        (`
            width='600'
            height='600'
            viewBox='0 0 600 600'>

            <style type="text/css">
            .rayUse {
                transform-origin: center;
            }
            .rayElipse {
                mix-blend-mode:screen;
                fill:url(#radial-gradient);
            }
            </style>

                <defs>

                    <mask id="mask">
                        <rect x='0' y='285' width='300' height='30' fill='#ffffff' />
                    </mask>

                    <radialGradient id='radial-gradient'

                        cx='300'
                        cy='300'
                        r='150'

                        gradientTransform='translate(-300 290.9) scale(2 0.03)' gradientUnits='userSpaceOnUse'
                        >

                        <stop offset='0.15'
                        stop-color='#fff'
                        stop-opacity='1'
                        />

                        <stop offset='${ 1 - (raySharpness * .1) }'
                        stop-color='#fff'
                        stop-opacity='0'
                        />

                    </radialGradient>

                    <filter id='blur' x='-.1' y='-.1' >
                    <feGaussianBlur in='SourceGraphic' stdDeviation='${feBlur}' />
                    </filter>
                </defs>
                <g style="isolation:isolate">
                    <symbol id='raySymbol' viewBox='0 0 600 600' >
                        <g style='${masking}'
                        transform='
                        translate(${offsetX},${offsetY})
                        '>
                            <ellipse class='rayElipse' cx='300' cy='300' rx='300' ry='5' />
                        </g>
                    </symbol>
                </g>

                <g ${totalTransforms}> ${raysIteration} </g>

        `);

        // console.log('result from svgCode_RAYS: ',result);

    return result;
    }


//________________________________________________________________________________
//  LENSE FLARE GLOW TEXTURES

    function svgCode_GLOW_hexagon ( toneCenter, toneInner, toneMid, toneOuter, toneEdge, rotate, feBlur, opacity  )
    {

        let itemIteration =`<use xlink:href='#glow' />`;

        let newGroupId = 'glowGroup';

        let totalTransforms = '';
        // console.log('totalTransforms: ',totalTransforms);

        let result = svgUriEncode
        (`

        width='100'
        height='100'
        viewBox='-10 -10 110 110'>

        <defs>
        <filter id='blur' x='-.1' y='-.1' >
        <feGaussianBlur in='SourceGraphic' stdDeviation='${feBlur}' />
        </filter>
        </defs>
        ${BOKEH_hexagon}

        id='glow'
        style='fill:gray'
        filter='url(#blur)'
        transform='rotate(${rotate},50,50)'
        opacity='${opacity * flareMasterOpacityGLOW * flareMasterOpacity}'
        />

        <g ${totalTransforms}> ${itemIteration} </g>

        `);

        console.log('result from svgCode_GLOW_hexagon: ',result);
        return result;
    };




    function svgCode_GLOW_circle ( toneCenter, toneInner, toneMid, toneOuter, toneEdge, rotate, feBlur, opacity  )
    {

        let itemIteration =`<use xlink:href='#glow' opacity='${opacity * flareMasterOpacityGLOW}'/>`;

        let newGroupId = 'glowGroup';

        let totalTransforms = '';
        // console.log('totalTransforms: ',totalTransforms);

        let result = svgUriEncode
        (`

        width='100'
        height='100'
        viewBox='0 0 100 100'>

        <defs>
        <radialGradient id='radial-gradient' cx='50' cy='50' r='50' gradientUnits='userSpaceOnUse'>

        <stop offset='${toneCenter}' style='stop-color: #000; stop-opacity: 0'/>
        <stop offset='${toneInner}' style='stop-color: #fff; stop-opacity: .5'/>
        <stop offset='${toneMid}' style='stop-color: #fff; stop-opacity: 1'/>
        <stop offset='${toneOuter}' style='stop-color: #fff; stop-opacity: .5'/>
        <stop offset='${toneEdge}' style='stop-color: #fff; stop-opacity: 0'/>

        </radialGradient>

        <g style='isolation:isolate'>

            <g id='glow'>

                <circle cx='50' cy='50' r='50' style='mix-blend-mode:screen;fill:url(#radial-gradient)' />

            </g>

        </g>

        </defs>
        <g ${totalTransforms}> ${itemIteration} </g>

        `);


        // let result = svgUriEncode
        // (`

        // width='100'
        // height='100'
        // viewBox='0 0 100 100'>

        // <defs>
        // <radialGradient id='radial-gradient' cx='50' cy='50' r='50' gradientUnits='userSpaceOnUse'>

        // <stop offset='${toneCenter}' style='stop-color: #fff; stop-opacity: 1'/>
        // <stop offset='${toneMid}' style='stop-color: #fff; stop-opacity: 5'/>
        // <stop offset='${toneOuter}' style='stop-color: #fff; stop-opacity: 0'/>

        // </radialGradient>

        // <g style='isolation:isolate'>

        //     <g id='glow'>

        //         <circle cx='50' cy='50' r='50' style='mix-blend-mode:screen;fill:url(#radial-gradient)' />

        //     </g>

        // </g>

        // </defs>
        // <g ${totalTransforms}> ${itemIteration} </g>

        // `);

        // console.log('result from svgCode_GLOW_circle: ',result);
        return result;
    };




    function svgCode_GLOW_ellipse ( toneCenter, toneInner, toneMid, toneOuter, toneEdge, rotate, feBlur, opacity  )
    {

        let itemIteration =`<use xlink:href='#glow' opacity='${opacity * flareMasterOpacityGLOW}'/>`;

        let newGroupId = 'glowGroup';

        let totalTransforms = '';
        // console.log('totalTransforms: ',totalTransforms);

        let result = svgUriEncode
        (`

        width='100'
        height='100'
        viewBox='0 0 100 100'>

        <defs>
        <radialGradient id='radial-gradient' cx='50' cy='50' r='50' gradientUnits='userSpaceOnUse'>

        <stop offset='${toneCenter}' style='stop-color: #000; stop-opacity: 0'/>
        <stop offset='${toneInner}' style='stop-color: #fff; stop-opacity: .5'/>
        <stop offset='${toneMid}' style='stop-color: #fff; stop-opacity: 1'/>
        <stop offset='${toneOuter}' style='stop-color: #fff; stop-opacity: .5'/>
        <stop offset='${toneEdge}' style='stop-color: #fff; stop-opacity: 0'/>

        </radialGradient>

        <g style='isolation:isolate'>

            <g id='glow'>

                <ellipse cx='50' cy='50' rx='50' ry='25' style='mix-blend-mode:screen;fill:url(#radial-gradient)' />

            </g>

        </g>

        </defs>
        <g ${totalTransforms}> ${itemIteration} </g>

        `);

        return result;
    };




    function svgCode_GLOW_square ( toneCenter, toneInner, toneMid, toneOuter, toneEdge, rotate, feBlur, opacity  )
    {

        let itemIteration =`<use xlink:href='#glow' opacity='${opacity * flareMasterOpacityGLOW * flareMasterOpacity}'/>`;

        let newGroupId = 'glowGroup';

        let totalTransforms = '';
        // console.log('totalTransforms: ',totalTransforms);

        let result = svgUriEncode
        (`

        width='100'
        height='100'
        viewBox='0 0 100 100'>

        <defs>
        <radialGradient id='radial-gradient' cx='50' cy='50' r='50' gradientUnits='userSpaceOnUse'>

        <stop offset='${toneCenter}' style='stop-color: #000; stop-opacity: 0'/>
        <stop offset='${toneInner}' style='stop-color: #fff; stop-opacity: .5'/>
        <stop offset='${toneMid}' style='stop-color: #fff; stop-opacity: 1'/>
        <stop offset='${toneOuter}' style='stop-color: #fff; stop-opacity: .5'/>
        <stop offset='${toneEdge}' style='stop-color: #fff; stop-opacity: 0'/>

        </radialGradient>

        <g style='isolation:isolate'>
        <g id='glow'>

        <rect cx='50' cy='50' r='50' style='mix-blend-mode:screen;fill:url(#radial-gradient)' />

        </g>
        </g>
        </defs>
        <g ${totalTransforms}> ${itemIteration} </g>

        `);

        // console.log('result from svgCode_GLOW: ',result);
        return result;
    };


//________________________________________________________________________________
//  LENSE FLARE BOKEH TEXTURES


    function svgCode_BOKEH( shape, color, vert, rotate, feBlur, opacity  )
    {
        // console.log('vert in svgCode_BOKEH:', vert);

        const width = 100;
        const height = 100;

        const vBminX = 0;
        const vBminY = 0;

        const vBwidth = 100;
        const vBheight = 100;
        // const vBheight = 100 * ( vert * 10);

        const translateX = 0;
        const translateY = 0;
        // const translateY = vert * -5;


        const scaleX = 1;
        const scaleY = 1;

        let result = svgUriEncode
        (`
            width='${width}'
            height='${height}'
            viewBox='${vBminX} ${vBminY}
            ${vBwidth} ${vBheight}'>
            <defs>
                <filter id="blur" x="-.1" y="-.1" >
                <feGaussianBlur in='SourceGraphic' stdDeviation='${feBlur}' />
                </filter>
            </defs>
            ${eval(shape)}
            style='fill:${color}'
            opacity='
            ${opacity * flareMasterOpacityBOKEH * flareMasterOpacity}'
            filter='url(#blur)'
            transform='
            translate(${translateX},${translateY})
            scale(${scaleX},${scaleY})
            rotate(${rotate},${width / 2},${height / 2})
        '/>
        `);

        return result;
    };


//________________________________________________________________________________
// 	LENSE FLARE CLOSE TEXTURES

    function loadAllLensFlareTextures()
    {

        MAP_LF_Bokeh_Polygons.set('line',
        "<line x1='50' y1='20' x2='80' y2='50' style ='stroke:gray;stroke-width:5'");

        MAP_LF_Bokeh_Polygons.set('circle',
        "<circle cx='50' cy='50' r='50' ");

        MAP_LF_Bokeh_Polygons.set('ellipse',
        "<ellipse cx='50' cy='50' rx='50' ry='25' ");

        MAP_LF_Bokeh_Polygons.set('triangle',
        "<polygon points='50 20 84.64 80 15.36 80 50 20'");

        MAP_LF_Bokeh_Polygons.set('square',
        "<rect x='20' y='20' width='60' height='60'");

        MAP_LF_Bokeh_Polygons.set('pentagon',
        "<polygon points='50 13.82 88.04 41.46 73.51 86.18 26.49 86.18 11.96 41.46 50 13.82'");

        MAP_LF_Bokeh_Polygons.set('hexagon',
        "<polygon points = '50.04 10 84.66 30.04 84.62 70.04 49.96 90 15.34 69.96 15.38 29.96 50.04 10'");

        MAP_LF_Bokeh_Polygons.set('heptagon',
        "<polygon points='50 11.98 81.27 27.04 89 60.88 67.36 88.02 32.65 88.02 11 60.88 18.73 27.04 50 11.98'");

        MAP_LF_Bokeh_Polygons.set('octagon',
        "<polygon points='65.31 13.04 86.95 34.69 86.95 65.31 65.31 86.95 34.69 86.95 13.04 65.31 13.04 34.69 34.69 13.04 65.31 13.04'");

        MAP_LF_Bokeh_Polygons.set('nonagon',
        "<polygon points='50 11.21 75.71 20.56 89.39 44.26 84.64 71.21 63.68 88.79 36.32 88.79 15.36 71.21 10.61 44.26 24.29 20.56 50 11.21'");

        BOKEH_line = MAP_LF_Bokeh_Polygons.get('line');
        BOKEH_circle = MAP_LF_Bokeh_Polygons.get('circle');
        BOKEH_ellipse = MAP_LF_Bokeh_Polygons.get('ellipse');
        BOKEH_triangle = MAP_LF_Bokeh_Polygons.get('triangle');
        BOKEH_square = MAP_LF_Bokeh_Polygons.get('square');
        BOKEH_pentagon = MAP_LF_Bokeh_Polygons.get('pentagon');
        BOKEH_hexagon = MAP_LF_Bokeh_Polygons.get('hexagon');
        BOKEH_heptagon = MAP_LF_Bokeh_Polygons.get('heptagon');
        BOKEH_octagon = MAP_LF_Bokeh_Polygons.get('octagon');
        BOKEH_nonagon = MAP_LF_Bokeh_Polygons.get('nonagon');

        //	console.log('MAP_LF_Bokeh_Polygons: ',MAP_LF_Bokeh_Polygons);

    };	//	END loadAllLensFlareTextures

//________________________________________________________________________________
//  LENSE FLARE.JS code

function lensFlareJS()
{
    ( function () {

        class Lensflare extends THREE.Mesh {

            constructor() {

                super( Lensflare.Geometry, new THREE.MeshBasicMaterial( {
                    opacity: 0,
                    transparent: true
                } ) );
                this.type = 'Lensflare';
                this.frustumCulled = false;
                this.renderOrder = Infinity; //

                const positionScreen = new THREE.Vector3();
                const positionView = new THREE.Vector3(); // textures

                const tempMap = new THREE.DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, THREE.RGBFormat );
                tempMap.minFilter = THREE.NearestFilter;
                tempMap.magFilter = THREE.NearestFilter;
                tempMap.wrapS = THREE.ClampToEdgeWrapping;
                tempMap.wrapT = THREE.ClampToEdgeWrapping;
                const occlusionMap = new THREE.DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, THREE.RGBFormat );
                occlusionMap.minFilter = THREE.NearestFilter;
                occlusionMap.magFilter = THREE.NearestFilter;
                occlusionMap.wrapS = THREE.ClampToEdgeWrapping;
                occlusionMap.wrapT = THREE.ClampToEdgeWrapping; // material

                const geometry = Lensflare.Geometry;

                const material1a = new THREE.RawShaderMaterial( {
                    uniforms: {
                        'scale': {
                            value: null
                        },
                        'screenPosition': {
                            value: null
                        }
                    },
                    vertexShader:
        /* glsl */
        `

                    precision highp float;

                    uniform vec3 screenPosition;
                    uniform vec2 scale;

                    attribute vec3 position;

                    void main() {

                        gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

                    }`,
                    fragmentShader:
        /* glsl */
        `

                    precision highp float;

                    void main() {

                        gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );

                    }`,
                    depthTest: true,
                    depthWrite: false,
                    transparent: false
                } );

                const material1b = new THREE.RawShaderMaterial( {
                    uniforms: {
                        'map': {
                            value: tempMap
                        },
                        'scale': {
                            value: null
                        },
                        'screenPosition': {
                            value: null
                        }
                    },
                    vertexShader:
        /* glsl */
        `

                    precision highp float;

                    uniform vec3 screenPosition;
                    uniform vec2 scale;

                    attribute vec3 position;
                    attribute vec2 uv;

                    varying vec2 vUV;

                    void main() {

                        vUV = uv;

                        gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

                    }`,
                    fragmentShader:
        /* glsl */
        `

                    precision highp float;

                    uniform sampler2D map;

                    varying vec2 vUV;

                    void main() {

                        gl_FragColor = texture2D( map, vUV );

                    }`,
                    depthTest: false,
                    depthWrite: false,
                    transparent: false
                    // transparent: true // default false
                } ); // the following object is used for occlusionMap generation

                // material1b.opacity = 0;
                // material1a.opacity = 0;


                const mesh1 = new THREE.Mesh( geometry, material1a ); //

                const elements = [];
                const shader = LensflareElement.Shader;
                const material2 = new THREE.RawShaderMaterial( {
                    uniforms: {
                        'map': {
                            value: null
                        },
                        'occlusionMap': {
                            value: occlusionMap
                        },
                        'color': {
                            value: new THREE.Color( 0xffffff )
                        },
                        'scale': {
                            value: new THREE.Vector2()
                        },
                        'screenPosition': {
                            value: new THREE.Vector3()
                        }
                    },
                    vertexShader: shader.vertexShader,
                    fragmentShader: shader.fragmentShader,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    depthWrite: false
                } );


                // material2.opacity = 0;

                const mesh2 = new THREE.Mesh( geometry, material2 );

                this.addElement = function ( element ) {

                    elements.push( element );

                }; //


                const scale = new THREE.Vector2();
                const screenPositionPixels = new THREE.Vector2();
                const validArea = new THREE.Box2();
                const viewport = new THREE.Vector4();

                this.onBeforeRender = function ( renderer, scene, camera ) {

                    renderer.getCurrentViewport( viewport );
                    const invAspect = viewport.w / viewport.z;
                    const halfViewportWidth = viewport.z / 2.0;
                    const halfViewportHeight = viewport.w / 2.0;
                    let size = 16 / viewport.w;
                    scale.set( size * invAspect, size );
                    validArea.min.set( viewport.x, viewport.y );
                    validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) ); // calculate position in screen space

                    positionView.setFromMatrixPosition( this.matrixWorld );
                    positionView.applyMatrix4( camera.matrixWorldInverse );
                    if ( positionView.z > 0 ) return; // lensflare is behind the camera

                    positionScreen.copy( positionView ).applyMatrix4( camera.projectionMatrix ); // horizontal and vertical coordinate of the lower left corner of the pixels to copy

                    screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;
                    screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8; // screen cull

                    if ( validArea.containsPoint( screenPositionPixels ) ) {

                        // save current RGB to temp texture
                        renderer.copyFramebufferToTexture( screenPositionPixels, tempMap ); // render pink quad

                        let uniforms = material1a.uniforms;
                        uniforms[ 'scale' ].value = scale;
                        uniforms[ 'screenPosition' ].value = positionScreen;
                        renderer.renderBufferDirect( camera, null, geometry, material1a, mesh1, null ); // copy result to occlusionMap

                        renderer.copyFramebufferToTexture( screenPositionPixels, occlusionMap ); // restore graphics

                        uniforms = material1b.uniforms;
                        uniforms[ 'scale' ].value = scale;
                        uniforms[ 'screenPosition' ].value = positionScreen;
                        renderer.renderBufferDirect( camera, null, geometry, material1b, mesh1, null ); // render elements

                        const vecX = - positionScreen.x * 2;
                        const vecY = - positionScreen.y * 2;

                        for ( let i = 0, l = elements.length; i < l; i ++ ) {

                            const element = elements[ i ];
                            const uniforms = material2.uniforms;
                            uniforms[ 'color' ].value.copy( element.color );
                            uniforms[ 'map' ].value = element.texture;
                            uniforms[ 'screenPosition' ].value.x = positionScreen.x + vecX * element.distance;
                            uniforms[ 'screenPosition' ].value.y = positionScreen.y + vecY * element.distance;
                            size = element.size / viewport.w;
                            const invAspect = viewport.w / viewport.z;
                            uniforms[ 'scale' ].value.set( size * invAspect, size );
                            material2.uniformsNeedUpdate = true;
                            renderer.renderBufferDirect( camera, null, geometry, material2, mesh2, null );

                        }

                    }

                };

                this.dispose = function () {

                    material1a.dispose();
                    material1b.dispose();
                    material2.dispose();
                    tempMap.dispose();
                    occlusionMap.dispose();

                    for ( let i = 0, l = elements.length; i < l; i ++ ) {

                        elements[ i ].texture.dispose();

                    }

                };

            }

        }

        Lensflare.prototype.isLensflare = true; //

        class LensflareElement {

            constructor( texture, size = 1, distance = 0, color = new THREE.Color( 0xffffff ) ) {

                this.texture = texture;
                this.size = size;
                this.distance = distance;
                this.color = color;

            }

        }

        LensflareElement.Shader = {
            uniforms: {
                'map': {
                    value: null
                },
                'occlusionMap': {
                    value: null
                },
                'color': {
                    value: null
                },
                'scale': {
                    value: null
                },
                'screenPosition': {
                    value: null
                }
            },
            vertexShader:
    /* glsl */
    `

            precision highp float;

            uniform vec3 screenPosition;
            uniform vec2 scale;

            uniform sampler2D occlusionMap;

            attribute vec3 position;
            attribute vec2 uv;

            varying vec2 vUV;
            varying float vVisibility;

            void main() {

                vUV = uv;

                vec2 pos = position.xy;

                vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );
                visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );
                visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );
                visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );
                visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );
                visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );
                visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );
                visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );
                visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );

                vVisibility =        visibility.r / 9.0;
                vVisibility *= 1.0 - visibility.g / 9.0;
                vVisibility *=       visibility.b / 9.0;

                gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );

            }`,
            fragmentShader:
    /* glsl */
    `

            precision highp float;

            uniform sampler2D map;
            uniform vec3 color;

            varying vec2 vUV;
            varying float vVisibility;

            void main() {

                vec4 texture = texture2D( map, vUV );
                texture.a *= vVisibility;
                gl_FragColor = texture;
                gl_FragColor.rgb *= color;

            }`
        };

        Lensflare.Geometry = function () {

            const geometry = new THREE.BufferGeometry();
            const float32Array = new Float32Array( [ - 1, - 1, 0, 0, 0, 1, - 1, 0, 1, 0, 1, 1, 0, 1, 1, - 1, 1, 0, 0, 1 ] );
            const interleavedBuffer = new THREE.InterleavedBuffer( float32Array, 5 );
            geometry.setIndex( [ 0, 1, 2, 0, 2, 3 ] );
            geometry.setAttribute( 'position', new THREE.InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
            geometry.setAttribute( 'uv', new THREE.InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );
            return geometry;

        }();

        THREE.Lensflare = Lensflare;
        THREE.LensflareElement = LensflareElement;

    } )();


};	//	END lenseFlareJS()


//________________________________________________________________________________
//  PROMISE FUNCTIONS
// GET OBJECT PROMISE

            // let promiseFunction = function (promisedItem, successCallback)
            function promiseFunctionOBJ (promisedItem, successCallback)
            {
                var timeout = 10000; // 1000000ms = 10 seconds

                function ensure_itemIsSet(timeout) {
                    var start = Date.now();
                    return new Promise(waitFor_promisedItem);

                    function waitFor_promisedItem(resolve, reject) {
                        console.log("[ GLIFTEK Plugins ]:\n'",puzzleName, "'puzzle is looking for", promisedItem);

                        if (app.scene.getObjectByName(promisedItem))
                        {
                            resolve(app.scene.getObjectByName(promisedItem));
                        }
                        else if (timeout && (Date.now() - start) >= timeout)
                        {
                            reject(new Error('timeout.', promisedItem, 'not found!'));

                                console.log("[ GLIFTEK Plugins ]:\n 'timeout.'", promisedItem, 'not found!')
                                alert("[ GLIFTEK Plugins ]:\n 'timeout.'", promisedItem, 'not found!');
                        }
                        else
                        {
                            setTimeout(waitFor_promisedItem.bind(this, resolve, reject), 30);
                        }
                    }
                }

                ensure_itemIsSet(timeout).then(function(){

                    successCallback(promisedItem);

                });
            };  //  END selectedLightPromiseWait

//________________________________________________________________________________
// GET VARIABLE PROMISE


            // let promiseFunction = function (promisedItem, successCallback)
            function promiseFunctionVAR (promisedItem, successCallback)
            {
                var timeout = 10000; // 1000000ms = 10 seconds

                function ensure_itemIsSet(timeout) {
                    var start = Date.now();
                    return new Promise(waitFor_promisedItem);

                    function waitFor_promisedItem(resolve, reject) {
                        console.log("[ GLIFTEK Plugins ]:\n'",puzzleName, "'puzzle is looking for", promisedItem);

                        // (promisedItem !== 'undefined')
                        if (promisedItem !== 'undefined')
                        {
                            resolve(promisedItem);

                            //	get variable name
                            const varToString = varObj => Object.keys(varObj)[0]
                            // console.log("[ GLIFTEK Plugins ]:", varToString({promisedItem}), 'found!')
                            console.log("[ GLIFTEK Plugins ]:", promisedItem.name, 'found!')


                        }
                        else if (timeout && (Date.now() - start) >= timeout)
                        {
                            reject(new Error('timeout.', promisedItem, 'not found!'));

                                console.log("[ GLIFTEK Plugins ]:\n 'timeout.'", promisedItem, 'not found!')
                                alert("[ GLIFTEK Plugins ]:\n 'timeout.'", promisedItem, 'not found!');
                        }
                        else
                        {

                            setTimeout(waitFor_promisedItem.bind(this, resolve, reject), 30);
                        }
                    }
                }

                ensure_itemIsSet(timeout).then(function(){

                    successCallback(promisedItem);

                });
            };  //  END selectedLightPromiseWait



//________________________________________________________________________________
    };  // END mainFunction
//________________________________________________________________________________
}).apply(null, arguments);
}


// Describe this function...
function LENS_FLARE_DELUXE_1() {

      createLenseFlareFunction
      (
          'myLensFlare_A',
          'Lens_Flare_Point_Light',

          true,
          LFD_RAYS_Settings_01,
          1.5,
          0.95,

          true,
          LFD_GLOW_Settings_01,
          1,
          0.95,

          true,
          LFD_BOKEH_Settings_01,
          0.75,
          0.75,

          0.65,
          0.95

      );
}


function lensFlareSettingsRAYS() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        rays,
        nameInput,
        symmetricalCheckbox,
        rayWidth,
        raySharpness,
        randomSeed,

        rotate,
        feBlur,
        opacity,

        size,
        distance,
        color
    )
    {   //  BEGIN Plug.provide Function
//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Lens Flare Deluxe Rays Settings';

//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        // if ( !input || input == '<none>') {
        //     console.log( puzzleName, ' missing input!');
        // }   else    { mainFunction () };

//________________________________________________________________________________
//  MAIN FUNCTION
        // mainFunction();
        // function mainFunction()
        // {
//________________________________________________________________________________
//  PUZZLE CORE CODE

        const MAP_LF_Settings_RAYS =
        new Map
        ([
            ['type' , 'RAYS'],
            ['shape' , 'RAYS'],

            ['rays' , rays],
            ['nameInput' , nameInput],
            ['symmetrical' , symmetricalCheckbox],
            ['rayWidth' , rayWidth],
            ['raySharpness' , raySharpness],
            ['randomSeed' , randomSeed],

            ['rotate' , rotate],
            ['feBlur' , feBlur],
            ['opacity' , opacity],

            ['size' , size],
            ['distance' , distance],
            ['color' , color],
        ]);

//________________________________________________________________________________
        // }; // END mainFunction
//________________________________________________________________________________
// PUZZLE OUTPUT

        // console.log('MAP_LF_Settings_RAYS: ',MAP_LF_Settings_RAYS);
        return MAP_LF_Settings_RAYS;

//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function INIT_RAYS_SETTINGS_1() {
  LFD_RAYS_Settings_01 = [
      lensFlareSettingsRAYS
      (
          6,
          'name',
          true,
          3,
          0,
          9,

          0,
          0.1,
          0.9,

          900,
          0,
          '#ffff66',

      )
      ,
      lensFlareSettingsRAYS
      (
          9,
          'name',
          false,
          3,
          1,
          3,

          0,
          0.1,
          0.9,

          1200,
          0.001,
          '#ffcc66',

      )
      ,
      lensFlareSettingsRAYS
      (
          64,
          'name',
          true,
          3,
          0,
          5,

          23,
          2,
          0.5,

          500,
          0.002,
          '#ffffcc',

      )
      ];
}


// removeObject puzzles
function removeObject(objSelector) {
    var objNames = retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (!obj || !obj.parent)
            continue;

        obj.parent.remove(obj);

        // clean object cache
        _pGlob.objCache = {};
    }
}


// Describe this function...
function SWITCH_FLARE_3() {
  if (lens_flare_counter < LIST_lens_flares.length) {
    if (lens_flare_counter == 1) {

              setImageBackground
              (
                  './img/bg_clouds_pink_purple.jpg',
              )
          removeObject('myLensFlare_01');
    } else if (lens_flare_counter == 2) {

              setImageBackground
              (
                  './img/bg_blue_dark_cloudy.jpg',
              )
          removeObject('myLensFlare_01');
      LENS_FLARE_DELUXE_2();
    } else if (lens_flare_counter == 3) {

              setImageBackground
              (
                  './img/bg_clouds_godrays_02.jpg',
              )
          removeObject('myLensFlare_03');
    }
  }
}

// Describe this function...
function SWITCH_FLARE() {
  lens_flare_counter = (typeof lens_flare_counter == 'number' ? lens_flare_counter : 0) + 1;
  if (lens_flare_counter <= 3) {
    console.log('lens_flare_counter: ' + String(lens_flare_counter));
    CHANGE_BG_AND_FLARE();
  } else if (lens_flare_counter > 3) {
    lens_flare_counter = 1;
    console.log('lens_flare_counter reset to: ' + String(lens_flare_counter));
    CHANGE_BG_AND_FLARE();
  }
}

// Describe this function...
function CHANGE_BG_AND_FLARE() {
  if (lens_flare_counter == 1) {

            setImageBackground
            (
                './img/bg_clouds_pink_purple.jpg',
            )
        removeObject('myLensFlare_C');
    LENS_FLARE_DELUXE_1();
  } else if (lens_flare_counter == 2) {

            setImageBackground
            (
                './img/bg_blue_dark_cloudy.jpg',
            )
        removeObject('myLensFlare_A');
    LENS_FLARE_DELUXE_2();
  } else if (lens_flare_counter == 3) {

            setImageBackground
            (
                './img/bg_clouds_godrays_02.jpg',
            )
        removeObject('myLensFlare_B');
    LENS_FLARE_DELUXE_3();
  }
}


function lensFlareSettingsGLOW() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        nameInput,
        shapeDropdown,

        toneCenter,
        toneInner,
        toneMid,
        toneOuter,
        toneEdge,

        rotate,
        feBlur,
        opacity,

        size,
        distance,
        color
    )
    {   //  BEGIN Plug.provide Function
//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Lens Flare Deluxe Glow Settings';

//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        // if ( !input || input == '<none>') {
        //     console.log( puzzleName, ' missing input!');
        // }   else    { mainFunction () };

//________________________________________________________________________________
//  MAIN FUNCTION
        // mainFunction();
        // function mainFunction()
        // {
//________________________________________________________________________________
//  PUZZLE CORE CODE

        const MAP_LF_Settings_GLOW =
        new Map
        ([

            ['type' , 'GLOW'],
            ['nameInput' , nameInput],

            ['shape' , shapeDropdown],

            ['toneCenter' , toneCenter],
            ['toneInner' , toneInner],

            ['toneMid' , toneMid],
            ['toneOuter' , toneOuter],
            ['toneEdge' , toneEdge],

            ['rotate' , rotate],
            ['feBlur' , feBlur],
            ['opacity' , opacity],

            ['size' , size],
            ['distance' , distance],
            ['color' , color],

        ]);

//________________________________________________________________________________
        // }; // END mainFunction
//________________________________________________________________________________
// PUZZLE OUTPUT

        // console.log('MAP_LF_Settings_GLOW: ',MAP_LF_Settings_GLOW);
        return MAP_LF_Settings_GLOW;

//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function INIT_GLOW_SETTINGS_1() {
  LFD_GLOW_Settings_01 = [
      lensFlareSettingsGLOW
      (
          'name',
          'GLOW_circle',

          0,
          0,
          0.7,
          0.85,
          1,

          0,
          0.4,
          0.4,

          150,
          0,
          '#ffff66',
      )
      ,
      lensFlareSettingsGLOW
      (
          'name',
          'GLOW_circle',

          0,
          0,
          0.7,
          0.85,
          1,

          0,
          0.6,
          0.4,

          300,
          0,
          '#ff9900',
      )
      ];
}


function lensFlareSettingsBOKEH() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        shapeDropdown,

        vert,

        rotate,
        feBlur,
        opacity,

        size,
        distance,
        color
    )
    {   //  BEGIN Plug.provide Function
//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Lens Flare Deluxe Bokeh Settings';

//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        // if ( !input || input == '<none>') {
        //     console.log( puzzleName, ' missing input!');
        // }   else    { mainFunction () };

//________________________________________________________________________________
//  MAIN FUNCTION
        // mainFunction();
        // function mainFunction()
        // {
//________________________________________________________________________________
//  PUZZLE CORE CODE

        const MAP_LF_Settings_BOKEH =
        new Map
        ([
            ['type' , 'BOKEH'],
            ['shape' , shapeDropdown],

            ['vert' , vert],

            ['rotate' , rotate],
            ['feBlur' , feBlur],
            ['opacity' , opacity],

            ['size' , size],
            ['distance' , distance],
            ['color' , color],
        ]);

//________________________________________________________________________________
        // }; // END mainFunction
//________________________________________________________________________________
// PUZZLE OUTPUT

        // console.log('MAP_LF_Settings_BOKEH: ',MAP_LF_Settings_BOKEH);
        return MAP_LF_Settings_BOKEH;

//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function INIT_BOKEH_SETTINGS_1() {
  LFD_BOKEH_Settings_01 = [
      lensFlareSettingsBOKEH
      (
          'BOKEH_hexagon',

          0,

          0,
          0.2,
          0.6,

          1,
          0.9,
          '#ff9900',
      )
      ,
      lensFlareSettingsBOKEH
      (
          'BOKEH_hexagon',

          0,

          0,
          0.8,
          0.5,

          2,
          0,
          '#ffff00',
      )
      ];
}

// Describe this function...
function SWITCH_FLARE_4() {

          screenFade
          (
              'screenFade_2',
              10,
              'in',
              0,
              0.25,
              '#000000',
              '',
              true,
              function() {  changeVis(current_lens_flare, false);
    if (lens_flare_counter < LIST_lens_flares.length) {
      lens_flare_counter = (typeof lens_flare_counter == 'number' ? lens_flare_counter : 0) + 1;
    } else {
      lens_flare_counter = 0;
    }
    current_lens_flare = LIST_lens_flares[lens_flare_counter];
    changeVis(current_lens_flare, true);

            setImageBackground
            (
                LIST_bg_images[lens_flare_counter],
            )

            screenFade
            (
                'screenFade_3',
                10,
                'out',
                0,
                0.25,
                '#000000',
                '',
                true,
                function() {},
            )
        },
          )
      }

// Describe this function...
function LENS_FLARE_DELUXE_2() {

      createLenseFlareFunction
      (
          'myLensFlare_B',
          'Lens_Flare_Point_Light',

          true,
          LFD_RAYS_Settings_02,
          0.4,
          0.75,

          true,
          LFD_GLOW_Settings_02,
          0.125,
          0.6,

          true,
          LFD_BOKEH_Settings_02,
          1,
          0.95,

          2.25,
          0.8

      );
}

// Describe this function...
function INIT_RAYS_SETTINGS_2() {
  LFD_RAYS_Settings_02 = [
      lensFlareSettingsRAYS
      (
          2,
          'anamorphic',
          true,
          0.7,
          8,
          0,

          0,
          0,
          0.9,

          10000,
          0,
          '#3366ff',

      )
      ,
      lensFlareSettingsRAYS
      (
          32,
          'shimmer_1',
          false,
          0.5,
          3,
          2.5,

          23,
          0,
          0.8,

          2400,
          0.002,
          '#3366ff',

      )
      ,
      lensFlareSettingsRAYS
      (
          32,
          'shimmer_2',
          false,
          0.5,
          3,
          2.5,

          45,
          0,
          0.8,

          2400,
          0.002,
          '#33ccff',

      )
      ,
      lensFlareSettingsRAYS
      (
          64,
          'shimmer_3',
          false,
          0.25,
          0,
          4,

          0,
          0,
          0.8,

          1600,
          0.003,
          '#99ffff',

      )
      ];
}

// Describe this function...
function INIT_GLOW_SETTINGS_2() {
  LFD_GLOW_Settings_02 = [
      lensFlareSettingsGLOW
      (
          'inner glow',
          'GLOW_hexagon',

          0,
          0.2,
          0.7,
          1,
          1,

          0,
          4,
          0.9,

          350,
          0,
          '#ccffff',
      )
      ,
      lensFlareSettingsGLOW
      (
          'outer circle',
          'GLOW_circle',

          0.55,
          0.65,
          0.85,
          0.95,
          1,

          0,
          7,
          0.4,

          1500,
          0,
          '#00ffff',
      )
      ,
      lensFlareSettingsGLOW
      (
          'accent elipse',
          'GLOW_ellipse',

          0.55,
          0.65,
          0.85,
          0.95,
          1,

          0,
          7,
          0.2,

          1500,
          0,
          '#00ffff',
      )
      ];
}

// Describe this function...
function INIT_BOKEH_SETTINGS_2() {
  LFD_BOKEH_Settings_02 = [
      lensFlareSettingsBOKEH
      (
          'BOKEH_ellipse',

          0,

          0,
          0.2,
          0.5,

          1,
          0.9,
          '#ccffff',
      )
      ,
      lensFlareSettingsBOKEH
      (
          'BOKEH_ellipse',

          0,

          0,
          0.2,
          0.3,

          0.5,
          0.5,
          '#66ffff',
      )
      ];
}

// Describe this function...
function LENS_FLARE_DELUXE_3() {

      createLenseFlareFunction
      (
          'myLensFlare_C',
          'Lens_Flare_Point_Light',

          true,
          LFD_RAYS_Settings_03,
          0.4,
          0.75,

          true,
          LFD_GLOW_Settings_03,
          0.5,
          0.6,

          true,
          LFD_BOKEH_Settings_03,
          1,
          0.95,

          1,
          0.8

      );
}

// Describe this function...
function INIT_RAYS_SETTINGS_3() {
  LFD_RAYS_Settings_03 = [
      lensFlareSettingsRAYS
      (
          32,
          'shimmer_1',
          false,
          1,
          3,
          2.5,

          23,
          0,
          0.8,

          6000,
          0.002,
          '#cc33cc',

      )
      ,
      lensFlareSettingsRAYS
      (
          32,
          'shimmer_2',
          false,
          5,
          3,
          8,

          45,
          0,
          0.8,

          2400,
          0.002,
          '#663366',

      )
      ];
}

// Describe this function...
function INIT_GLOW_SETTINGS_3() {
  LFD_GLOW_Settings_03 = [
      lensFlareSettingsGLOW
      (
          'inner glow',
          'GLOW_hexagon',

          0,
          0.2,
          0.5,
          0.6,
          0.7,

          0,
          10,
          0.9,

          600,
          0,
          '#ff99ff',
      )
      ,
      lensFlareSettingsGLOW
      (
          'name',
          'GLOW_hexagon',

          0,
          0.2,
          0.7,
          0.8,
          0.9,

          0,
          4,
          0.9,

          300,
          0,
          '#993399',
      )
      ];
}

// Describe this function...
function INIT_BOKEH_SETTINGS_3() {
  LFD_BOKEH_Settings_03 = [
      lensFlareSettingsBOKEH
      (
          'BOKEH_triangle',

          0,

          213,
          0.2,
          0.5,

          1,
          0.9,
          '#ccccff',
      )
      ,
      lensFlareSettingsBOKEH
      (
          'BOKEH_triangle',

          0,

          33,
          0.2,
          0.3,

          0.5,
          0.5,
          '#9999ff',
      )
      ];
}


MAIN();



} // end of PL.init function

})(); // end of closure

/* ================================ end of code ============================= */
