/**
 * Generated by Verge3D Puzzles v.3.9.0 pre1
 * Thu Nov 11 2021 00:37:25 GMT-0500 (Eastern Standard Time)
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */

'use strict';

(function() {

// global variables/constants used by puzzles' functions

var LIST_NONE = '<none>';

var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster();

var PL = v3d.PL = v3d.PL || {};

// a more readable alias for PL (stands for "Puzzle Logic")
v3d.puzzles = PL;

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        }
    }

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    var PROC = {
    
};


    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["INSTRUCTIONS"] = INSTRUCTIONS;
this.procedures["BUTTON_UPLOAD"] = BUTTON_UPLOAD;
this.procedures["FORM_URL"] = FORM_URL;
this.procedures["BUTTON_RESET"] = BUTTON_RESET;
this.procedures["MAKE_BUTTONS"] = MAKE_BUTTONS;
this.procedures["BUTTON_GLIFTEK"] = BUTTON_GLIFTEK;
this.procedures["BUTTON_VERGE_3D"] = BUTTON_VERGE_3D;
this.procedures["MAIN"] = MAIN;
this.procedures["SETUP"] = SETUP;
this.procedures["BUTTONS_POINTER"] = BUTTONS_POINTER;
this.procedures["GLIFTEK_LOGO"] = GLIFTEK_LOGO;
this.procedures["CHANGE_SVG_MESH"] = CHANGE_SVG_MESH;
this.procedures["ROTATE_OBJECTS_SEPARATE"] = ROTATE_OBJECTS_SEPARATE;
this.procedures["EXTRUDE_OBJECTS"] = EXTRUDE_OBJECTS;
this.procedures["ROTATE_OBJECT"] = ROTATE_OBJECT;
this.procedures["CHANGE_COLOR_OF_LETTERS"] = CHANGE_COLOR_OF_LETTERS;
this.procedures["OBJECT_ROTATION"] = OBJECT_ROTATION;
this.procedures["VERGE_3D_LOGO"] = VERGE_3D_LOGO;
this.procedures["MAKE_DICT_color_rgb4"] = MAKE_DICT_color_rgb4;
this.procedures["SET_CUBE_MATERIAL_COPIES"] = SET_CUBE_MATERIAL_COPIES;
this.procedures["UPLOADED_SVG"] = UPLOADED_SVG;
this.procedures["RESET_OBJECTS"] = RESET_OBJECTS;

var PROC = {
    "INSTRUCTIONS": INSTRUCTIONS,
    "BUTTON_UPLOAD": BUTTON_UPLOAD,
    "FORM_URL": FORM_URL,
    "BUTTON_RESET": BUTTON_RESET,
    "MAKE_BUTTONS": MAKE_BUTTONS,
    "BUTTON_GLIFTEK": BUTTON_GLIFTEK,
    "BUTTON_VERGE_3D": BUTTON_VERGE_3D,
    "MAIN": MAIN,
    "SETUP": SETUP,
    "BUTTONS_POINTER": BUTTONS_POINTER,
    "GLIFTEK_LOGO": GLIFTEK_LOGO,
    "CHANGE_SVG_MESH": CHANGE_SVG_MESH,
    "ROTATE_OBJECTS_SEPARATE": ROTATE_OBJECTS_SEPARATE,
    "EXTRUDE_OBJECTS": EXTRUDE_OBJECTS,
    "ROTATE_OBJECT": ROTATE_OBJECT,
    "CHANGE_COLOR_OF_LETTERS": CHANGE_COLOR_OF_LETTERS,
    "OBJECT_ROTATION": OBJECT_ROTATION,
    "VERGE_3D_LOGO": VERGE_3D_LOGO,
    "MAKE_DICT_color_rgb4": MAKE_DICT_color_rgb4,
    "SET_CUBE_MATERIAL_COPIES": SET_CUBE_MATERIAL_COPIES,
    "UPLOADED_SVG": UPLOADED_SVG,
    "RESET_OBJECTS": RESET_OBJECTS,
};

var file, object_to_extrude, depth, element, input, object_to_rotate, material_color, r, g, b, m, GLIFTEK_Logo_Var, Current_SVG, p, LIST_children_of_Gliftek_Logo, Current_SVG_Extruded_Empty, LIST_SVG_Parts_Extruded, q, SVG_Empty_Scale, o;


function svgAsObjLoader() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (   svgFileInput,
        scaleInput,
        separateObjectsCheckbox
        // nameInput,
        // meshNameInput
    )
    {   //  BEGIN Plug.provide Function
//________________________________________________________________________________
//  DECLARE VARIABLES

    let svgObjectOutput;
    let meshObj;
    let mesh;
    let LIST_svgParts = [];
    // let group = {};
    let group = new THREE.Group();

    let SVGname,SVGheightHalf,SVGwidthHalf;



//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !svgFileInput ) {
            console.log('Load SVG as Object Puzzle is missing a input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  MAIN FUNCTION

        function mainFunction()
        {
//________________________________________________________________________________
//  PUZZLE CORE CODE



//________________________________________________________________________________
//  SVG LOADER JS

THREE.SVGLoader = function ( manager ) {

THREE.Loader.call( this, manager );

// Default dots per inch
this.defaultDPI = 90;

// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'
this.defaultUnit = 'px';

};

THREE.SVGLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {

constructor: THREE.SVGLoader,

load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.FileLoader( scope.manager );
    loader.setPath( scope.path );
    loader.setRequestHeader( scope.requestHeader );
    loader.setWithCredentials( scope.withCredentials );
    loader.load( url, function ( text ) {

        try {

            onLoad( scope.parse( text ) );

        } catch ( e ) {

            if ( onError ) {

                onError( e );

            } else {

                console.error( e );

            }

            scope.manager.itemError( url );

        }

    }, onProgress, onError );

},

parse: function ( text ) {

    var scope = this;

    function parseNode( node, style ) {

        if ( node.nodeType !== 1 ) return;

        var transform = getNodeTransform( node );

        var traverseChildNodes = true;

        var path = null;

        switch ( node.nodeName ) {

            case 'svg':
                break;

            case 'style':
                parseCSSStylesheet( node );
                break;

            case 'g':
                style = parseStyle( node, style );
                break;

            case 'path':
                style = parseStyle( node, style );
                if ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );
                if ( node.hasAttribute( 'id' ) ) path.id = node.id;
                //console.log('path.id: ',path.id);
                break;

            case 'rect':
                style = parseStyle( node, style );
                path = parseRectNode( node );
                break;

            case 'polygon':
                style = parseStyle( node, style );
                path = parsePolygonNode( node );
                break;

            case 'polyline':
                style = parseStyle( node, style );
                path = parsePolylineNode( node );
                break;

            case 'circle':
                style = parseStyle( node, style );
                path = parseCircleNode( node );
                break;

            case 'ellipse':
                style = parseStyle( node, style );
                path = parseEllipseNode( node );
                break;

            case 'line':
                style = parseStyle( node, style );
                path = parseLineNode( node );
                break;

            case 'defs':
                traverseChildNodes = false;
                break;

            case 'use':
                style = parseStyle( node, style );
                var usedNodeId = node.href.baseVal.substring( 1 );
                var usedNode = node.viewportElement.getElementById( usedNodeId );
                if ( usedNode ) {

                    parseNode( usedNode, style );

                } else {

                    console.warn( 'SVGLoader: \'use node\' references non-existent node id: ' + usedNodeId );

                }

                break;

            default:
                // console.log( node );

        }

        if ( path ) {

            if ( style.fill !== undefined && style.fill !== 'none' ) {

                path.color.setStyle( style.fill );

            }

            transformPath( path, currentTransform );

            paths.push( path );

            path.userData = { node: node, style: style };

        }

        if ( traverseChildNodes ) {

            var nodes = node.childNodes;

            for ( var i = 0; i < nodes.length; i ++ ) {

                parseNode( nodes[ i ], style );

            }

        }

        if ( transform ) {

            transformStack.pop();

            if ( transformStack.length > 0 ) {

                currentTransform.copy( transformStack[ transformStack.length - 1 ] );

            } else {

                currentTransform.identity();

            }

        }

    }

    function parsePathNode( node ) {

        var path = new THREE.ShapePath();

        var point = new THREE.Vector2();
        var control = new THREE.Vector2();

        var firstPoint = new THREE.Vector2();
        var isFirstPoint = true;
        var doSetFirstPoint = false;

        var d = node.getAttribute( 'd' );

        // console.log( d );

        var commands = d.match( /[a-df-z][^a-df-z]*/ig );

        for ( var i = 0, l = commands.length; i < l; i ++ ) {

            var command = commands[ i ];

            var type = command.charAt( 0 );
            var data = command.substr( 1 ).trim();

            if ( isFirstPoint === true ) {

                doSetFirstPoint = true;
                isFirstPoint = false;

            }

            switch ( type ) {

                case 'M':
                    var numbers = parseFloats( data );
                    for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {

                        point.x = numbers[ j + 0 ];
                        point.y = numbers[ j + 1 ];
                        control.x = point.x;
                        control.y = point.y;

                        if ( j === 0 ) {

                            path.moveTo( point.x, point.y );

                        } else {

                            path.lineTo( point.x, point.y );

                        }

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'H':
                    var numbers = parseFloats( data );

                    for ( var j = 0, jl = numbers.length; j < jl; j ++ ) {

                        point.x = numbers[ j ];
                        control.x = point.x;
                        control.y = point.y;
                        path.lineTo( point.x, point.y );

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'V':
                    var numbers = parseFloats( data );

                    for ( var j = 0, jl = numbers.length; j < jl; j ++ ) {

                        point.y = numbers[ j ];
                        control.x = point.x;
                        control.y = point.y;
                        path.lineTo( point.x, point.y );

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'L':
                    var numbers = parseFloats( data );

                    for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {

                        point.x = numbers[ j + 0 ];
                        point.y = numbers[ j + 1 ];
                        control.x = point.x;
                        control.y = point.y;
                        path.lineTo( point.x, point.y );

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'C':
                    var numbers = parseFloats( data );

                    for ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {

                        path.bezierCurveTo(
                            numbers[ j + 0 ],
                            numbers[ j + 1 ],
                            numbers[ j + 2 ],
                            numbers[ j + 3 ],
                            numbers[ j + 4 ],
                            numbers[ j + 5 ]
                        );
                        control.x = numbers[ j + 2 ];
                        control.y = numbers[ j + 3 ];
                        point.x = numbers[ j + 4 ];
                        point.y = numbers[ j + 5 ];

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'S':
                    var numbers = parseFloats( data );

                    for ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {

                        path.bezierCurveTo(
                            getReflection( point.x, control.x ),
                            getReflection( point.y, control.y ),
                            numbers[ j + 0 ],
                            numbers[ j + 1 ],
                            numbers[ j + 2 ],
                            numbers[ j + 3 ]
                        );
                        control.x = numbers[ j + 0 ];
                        control.y = numbers[ j + 1 ];
                        point.x = numbers[ j + 2 ];
                        point.y = numbers[ j + 3 ];

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'Q':
                    var numbers = parseFloats( data );

                    for ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {

                        path.quadraticCurveTo(
                            numbers[ j + 0 ],
                            numbers[ j + 1 ],
                            numbers[ j + 2 ],
                            numbers[ j + 3 ]
                        );
                        control.x = numbers[ j + 0 ];
                        control.y = numbers[ j + 1 ];
                        point.x = numbers[ j + 2 ];
                        point.y = numbers[ j + 3 ];

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'T':
                    var numbers = parseFloats( data );

                    for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {

                        var rx = getReflection( point.x, control.x );
                        var ry = getReflection( point.y, control.y );
                        path.quadraticCurveTo(
                            rx,
                            ry,
                            numbers[ j + 0 ],
                            numbers[ j + 1 ]
                        );
                        control.x = rx;
                        control.y = ry;
                        point.x = numbers[ j + 0 ];
                        point.y = numbers[ j + 1 ];

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'A':
                    var numbers = parseFloats( data, [ 3, 4 ], 7 );

                    for ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {

                        // skip command if start point == end point
                        if ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;

                        var start = point.clone();
                        point.x = numbers[ j + 5 ];
                        point.y = numbers[ j + 6 ];
                        control.x = point.x;
                        control.y = point.y;
                        parseArcCommand(
                            path, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point
                        );

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'm':
                    var numbers = parseFloats( data );

                    for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {

                        point.x += numbers[ j + 0 ];
                        point.y += numbers[ j + 1 ];
                        control.x = point.x;
                        control.y = point.y;

                        if ( j === 0 ) {

                            path.moveTo( point.x, point.y );

                        } else {

                            path.lineTo( point.x, point.y );

                        }

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'h':
                    var numbers = parseFloats( data );

                    for ( var j = 0, jl = numbers.length; j < jl; j ++ ) {

                        point.x += numbers[ j ];
                        control.x = point.x;
                        control.y = point.y;
                        path.lineTo( point.x, point.y );

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'v':
                    var numbers = parseFloats( data );

                    for ( var j = 0, jl = numbers.length; j < jl; j ++ ) {

                        point.y += numbers[ j ];
                        control.x = point.x;
                        control.y = point.y;
                        path.lineTo( point.x, point.y );

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'l':
                    var numbers = parseFloats( data );

                    for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {

                        point.x += numbers[ j + 0 ];
                        point.y += numbers[ j + 1 ];
                        control.x = point.x;
                        control.y = point.y;
                        path.lineTo( point.x, point.y );

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'c':
                    var numbers = parseFloats( data );

                    for ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {

                        path.bezierCurveTo(
                            point.x + numbers[ j + 0 ],
                            point.y + numbers[ j + 1 ],
                            point.x + numbers[ j + 2 ],
                            point.y + numbers[ j + 3 ],
                            point.x + numbers[ j + 4 ],
                            point.y + numbers[ j + 5 ]
                        );
                        control.x = point.x + numbers[ j + 2 ];
                        control.y = point.y + numbers[ j + 3 ];
                        point.x += numbers[ j + 4 ];
                        point.y += numbers[ j + 5 ];

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 's':
                    var numbers = parseFloats( data );

                    for ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {

                        path.bezierCurveTo(
                            getReflection( point.x, control.x ),
                            getReflection( point.y, control.y ),
                            point.x + numbers[ j + 0 ],
                            point.y + numbers[ j + 1 ],
                            point.x + numbers[ j + 2 ],
                            point.y + numbers[ j + 3 ]
                        );
                        control.x = point.x + numbers[ j + 0 ];
                        control.y = point.y + numbers[ j + 1 ];
                        point.x += numbers[ j + 2 ];
                        point.y += numbers[ j + 3 ];

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'q':
                    var numbers = parseFloats( data );

                    for ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {

                        path.quadraticCurveTo(
                            point.x + numbers[ j + 0 ],
                            point.y + numbers[ j + 1 ],
                            point.x + numbers[ j + 2 ],
                            point.y + numbers[ j + 3 ]
                        );
                        control.x = point.x + numbers[ j + 0 ];
                        control.y = point.y + numbers[ j + 1 ];
                        point.x += numbers[ j + 2 ];
                        point.y += numbers[ j + 3 ];

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 't':
                    var numbers = parseFloats( data );

                    for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {

                        var rx = getReflection( point.x, control.x );
                        var ry = getReflection( point.y, control.y );
                        path.quadraticCurveTo(
                            rx,
                            ry,
                            point.x + numbers[ j + 0 ],
                            point.y + numbers[ j + 1 ]
                        );
                        control.x = rx;
                        control.y = ry;
                        point.x = point.x + numbers[ j + 0 ];
                        point.y = point.y + numbers[ j + 1 ];

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'a':
                    var numbers = parseFloats( data, [ 3, 4 ], 7 );

                    for ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {

                        // skip command if no displacement
                        if ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;

                        var start = point.clone();
                        point.x += numbers[ j + 5 ];
                        point.y += numbers[ j + 6 ];
                        control.x = point.x;
                        control.y = point.y;
                        parseArcCommand(
                            path, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point
                        );

                        if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

                    }

                    break;

                case 'Z':
                case 'z':
                    path.currentPath.autoClose = true;

                    if ( path.currentPath.curves.length > 0 ) {

                        // Reset point to beginning of Path
                        point.copy( firstPoint );
                        path.currentPath.currentPoint.copy( point );
                        isFirstPoint = true;

                    }

                    break;

                default:
                    console.warn( command );

            }

            // console.log( type, parseFloats( data ), parseFloats( data ).length  )

            doSetFirstPoint = false;

        }

        return path;

    }

    function parseCSSStylesheet( node ) {

        if ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;

        for ( var i = 0; i < node.sheet.cssRules.length; i ++ ) {

            var stylesheet = node.sheet.cssRules[ i ];

            if ( stylesheet.type !== 1 ) continue;

            var selectorList = stylesheet.selectorText
                .split( /,/gm )
                .filter( Boolean )
                .map( i => i.trim() );

            for ( var j = 0; j < selectorList.length; j ++ ) {

                stylesheets[ selectorList[ j ] ] = Object.assign(
                    stylesheets[ selectorList[ j ] ] || {},
                    stylesheet.style
                );

            }

        }

    }

    /**
     * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
     * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion
     * From
     * rx ry x-axis-rotation large-arc-flag sweep-flag x y
     * To
     * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation
     */

    function parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {

        if ( rx == 0 || ry == 0 ) {

            // draw a line if either of the radii == 0
            path.lineTo( end.x, end.y );
            return;

        }

        x_axis_rotation = x_axis_rotation * Math.PI / 180;

        // Ensure radii are positive
        rx = Math.abs( rx );
        ry = Math.abs( ry );

        // Compute (x1', y1')
        var dx2 = ( start.x - end.x ) / 2.0;
        var dy2 = ( start.y - end.y ) / 2.0;
        var x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;
        var y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;

        // Compute (cx', cy')
        var rxs = rx * rx;
        var rys = ry * ry;
        var x1ps = x1p * x1p;
        var y1ps = y1p * y1p;

        // Ensure radii are large enough
        var cr = x1ps / rxs + y1ps / rys;

        if ( cr > 1 ) {

            // scale up rx,ry equally so cr == 1
            var s = Math.sqrt( cr );
            rx = s * rx;
            ry = s * ry;
            rxs = rx * rx;
            rys = ry * ry;

        }

        var dq = ( rxs * y1ps + rys * x1ps );
        var pq = ( rxs * rys - dq ) / dq;
        var q = Math.sqrt( Math.max( 0, pq ) );
        if ( large_arc_flag === sweep_flag ) q = - q;
        var cxp = q * rx * y1p / ry;
        var cyp = - q * ry * x1p / rx;

        // Step 3: Compute (cx, cy) from (cx', cy')
        var cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;
        var cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;

        // Step 4: Compute θ1 and Δθ
        var theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );
        var delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );

        path.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );

    }

    function svgAngle( ux, uy, vx, vy ) {

        var dot = ux * vx + uy * vy;
        var len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );
        var ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear
        if ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;
        return ang;

    }

    /*
    * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute
    * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough
    */
    function parseRectNode( node ) {

        var x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );
        var y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );
        var rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );
        var ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );
        var w = parseFloatWithUnits( node.getAttribute( 'width' ) );
        var h = parseFloatWithUnits( node.getAttribute( 'height' ) );

        var path = new THREE.ShapePath();
        path.moveTo( x + 2 * rx, y );
        path.lineTo( x + w - 2 * rx, y );
        if ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry );
        path.lineTo( x + w, y + h - 2 * ry );
        if ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h );
        path.lineTo( x + 2 * rx, y + h );

        if ( rx !== 0 || ry !== 0 ) {

            path.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );

        }

        path.lineTo( x, y + 2 * ry );

        if ( rx !== 0 || ry !== 0 ) {

            path.bezierCurveTo( x, y, x, y, x + 2 * rx, y );

        }

        return path;

    }

    function parsePolygonNode( node ) {

        function iterator( match, a, b ) {

            var x = parseFloatWithUnits( a );
            var y = parseFloatWithUnits( b );

            if ( index === 0 ) {

                path.moveTo( x, y );

            } else {

                path.lineTo( x, y );

            }

            index ++;

        }

        var regex = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g;

        var path = new THREE.ShapePath();

        var index = 0;

        node.getAttribute( 'points' ).replace( regex, iterator );

        path.currentPath.autoClose = true;

        return path;

    }

    function parsePolylineNode( node ) {

        function iterator( match, a, b ) {

            var x = parseFloatWithUnits( a );
            var y = parseFloatWithUnits( b );

            if ( index === 0 ) {

                path.moveTo( x, y );

            } else {

                path.lineTo( x, y );

            }

            index ++;

        }

        var regex = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g;

        var path = new THREE.ShapePath();

        var index = 0;

        node.getAttribute( 'points' ).replace( regex, iterator );

        path.currentPath.autoClose = false;

        return path;

    }

    function parseCircleNode( node ) {

        var x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );
        var y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );
        var r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );

        var subpath = new THREE.Path();
        subpath.absarc( x, y, r, 0, Math.PI * 2 );

        var path = new THREE.ShapePath();
        path.subPaths.push( subpath );

        return path;

    }

    function parseEllipseNode( node ) {

        var x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );
        var y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );
        var rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );
        var ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );

        var subpath = new THREE.Path();
        subpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );

        var path = new THREE.ShapePath();
        path.subPaths.push( subpath );

        return path;

    }

    function parseLineNode( node ) {

        var x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );
        var y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );
        var x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );
        var y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );

        var path = new THREE.ShapePath();
        path.moveTo( x1, y1 );
        path.lineTo( x2, y2 );
        path.currentPath.autoClose = false;

        return path;

    }

    //

    function parseStyle( node, style ) {

        style = Object.assign( {}, style ); // clone style

        var stylesheetStyles = {};

        if ( node.hasAttribute( 'class' ) ) {

            var classSelectors = node.getAttribute( 'class' )
                .split( /\s/ )
                .filter( Boolean )
                .map( i => i.trim() );

            for ( var i = 0; i < classSelectors.length; i ++ ) {

                stylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );

            }

        }

        if ( node.hasAttribute( 'id' ) ) {

            stylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );

        }

        function addStyle( svgName, jsName, adjustFunction ) {

            if ( adjustFunction === undefined ) adjustFunction = function copy( v ) {

                if ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );

                return v;

            };

            if ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );
            if ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );
            if ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );

        }

        function clamp( v ) {

            return Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );

        }

        function positive( v ) {

            return Math.max( 0, parseFloatWithUnits( v ) );

        }

        addStyle( 'fill', 'fill' );
        addStyle( 'fill-opacity', 'fillOpacity', clamp );
        addStyle( 'opacity', 'opacity', clamp );
        addStyle( 'stroke', 'stroke' );
        addStyle( 'stroke-opacity', 'strokeOpacity', clamp );
        addStyle( 'stroke-width', 'strokeWidth', positive );
        addStyle( 'stroke-linejoin', 'strokeLineJoin' );
        addStyle( 'stroke-linecap', 'strokeLineCap' );
        addStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );
        addStyle( 'visibility', 'visibility' );

        return style;

    }

    // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes

    function getReflection( a, b ) {

        return a - ( b - a );

    }

    // from https://github.com/ppvg/svg-numbers (MIT License)

    function parseFloats( input, flags, stride ) {

        if ( typeof input !== 'string' ) {

            throw new TypeError( 'Invalid input: ' + typeof input );

        }

        // Character groups
        var RE = {
            SEPARATOR: /[ \t\r\n\,.\-+]/,
            WHITESPACE: /[ \t\r\n]/,
            DIGIT: /[\d]/,
            SIGN: /[-+]/,
            POINT: /\./,
            COMMA: /,/,
            EXP: /e/i,
            FLAGS: /[01]/
        };

        // States
        var SEP = 0;
        var INT = 1;
        var FLOAT = 2;
        var EXP = 3;

        var state = SEP;
        var seenComma = true;
        var result = [], number = '', exponent = '';

        function throwSyntaxError( current, i, partial ) {

            var error = new SyntaxError( 'Unexpected character "' + current + '" at index ' + i + '.' );
            error.partial = partial;
            throw error;

        }

        function newNumber() {

            if ( number !== '' ) {

                if ( exponent === '' ) result.push( Number( number ) );
                else result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );

            }

            number = '';
            exponent = '';

        }

        var current, i = 0, length = input.length;
        for ( i = 0; i < length; i ++ ) {

            current = input[ i ];

            // check for flags
            if ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {

                state = INT;
                number = current;
                newNumber();
                continue;

            }

            // parse until next number
            if ( state === SEP ) {

                // eat whitespace
                if ( RE.WHITESPACE.test( current ) ) {

                    continue;

                }

                // start new number
                if ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {

                    state = INT;
                    number = current;
                    continue;

                }

                if ( RE.POINT.test( current ) ) {

                    state = FLOAT;
                    number = current;
                    continue;

                }

                // throw on double commas (e.g. "1, , 2")
                if ( RE.COMMA.test( current ) ) {

                    if ( seenComma ) {

                        throwSyntaxError( current, i, result );

                    }

                    seenComma = true;

                }

            }

            // parse integer part
            if ( state === INT ) {

                if ( RE.DIGIT.test( current ) ) {

                    number += current;
                    continue;

                }

                if ( RE.POINT.test( current ) ) {

                    number += current;
                    state = FLOAT;
                    continue;

                }

                if ( RE.EXP.test( current ) ) {

                    state = EXP;
                    continue;

                }

                // throw on double signs ("-+1"), but not on sign as separator ("-1-2")
                if ( RE.SIGN.test( current )
                        && number.length === 1
                        && RE.SIGN.test( number[ 0 ] ) ) {

                    throwSyntaxError( current, i, result );

                }

            }

            // parse decimal part
            if ( state === FLOAT ) {

                if ( RE.DIGIT.test( current ) ) {

                    number += current;
                    continue;

                }

                if ( RE.EXP.test( current ) ) {

                    state = EXP;
                    continue;

                }

                // throw on double decimal points (e.g. "1..2")
                if ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {

                    throwSyntaxError( current, i, result );

                }

            }

            // parse exponent part
            if ( state === EXP ) {

                if ( RE.DIGIT.test( current ) ) {

                    exponent += current;
                    continue;

                }

                if ( RE.SIGN.test( current ) ) {

                    if ( exponent === '' ) {

                        exponent += current;
                        continue;

                    }

                    if ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {

                        throwSyntaxError( current, i, result );

                    }

                }

            }


            // end of number
            if ( RE.WHITESPACE.test( current ) ) {

                newNumber();
                state = SEP;
                seenComma = false;

            } else if ( RE.COMMA.test( current ) ) {

                newNumber();
                state = SEP;
                seenComma = true;

            } else if ( RE.SIGN.test( current ) ) {

                newNumber();
                state = INT;
                number = current;

            } else if ( RE.POINT.test( current ) ) {

                newNumber();
                state = FLOAT;
                number = current;

            } else {

                throwSyntaxError( current, i, result );

            }

        }

        // add the last number found (if any)
        newNumber();

        return result;

    }

    // Units

    var units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];

    // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)
    var unitConversion = {

        'mm': {
            'mm': 1,
            'cm': 0.1,
            'in': 1 / 25.4,
            'pt': 72 / 25.4,
            'pc': 6 / 25.4,
            'px': - 1
        },
        'cm': {
            'mm': 10,
            'cm': 1,
            'in': 1 / 2.54,
            'pt': 72 / 2.54,
            'pc': 6 / 2.54,
            'px': - 1
        },
        'in': {
            'mm': 25.4,
            'cm': 2.54,
            'in': 1,
            'pt': 72,
            'pc': 6,
            'px': - 1
        },
        'pt': {
            'mm': 25.4 / 72,
            'cm': 2.54 / 72,
            'in': 1 / 72,
            'pt': 1,
            'pc': 6 / 72,
            'px': - 1
        },
        'pc': {
            'mm': 25.4 / 6,
            'cm': 2.54 / 6,
            'in': 1 / 6,
            'pt': 72 / 6,
            'pc': 1,
            'px': - 1
        },
        'px': {
            'px': 1
        }

    };

    function parseFloatWithUnits( string ) {

        var theUnit = 'px';

        if ( typeof string === 'string' || string instanceof String ) {

            for ( var i = 0, n = units.length; i < n; i ++ ) {

                var u = units[ i ];

                if ( string.endsWith( u ) ) {

                    theUnit = u;
                    string = string.substring( 0, string.length - u.length );
                    break;

                }

            }

        }

        var scale = undefined;

        if ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {

            // Conversion scale from  pixels to inches, then to default units

            scale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;

        } else {

            scale = unitConversion[ theUnit ][ scope.defaultUnit ];

            if ( scale < 0 ) {

                // Conversion scale to pixels

                scale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;

            }

        }

        return scale * parseFloat( string );

    }

    // Transforms

    function getNodeTransform( node ) {

        if ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {

            return null;

        }

        var transform = parseNodeTransform( node );

        if ( transformStack.length > 0 ) {

            transform.premultiply( transformStack[ transformStack.length - 1 ] );

        }

        currentTransform.copy( transform );
        transformStack.push( transform );

        return transform;

    }

    function parseNodeTransform( node ) {

        var transform = new THREE.Matrix3();
        var currentTransform = tempTransform0;

        if ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {

            var tx = parseFloatWithUnits( node.getAttribute( 'x' ) );
            var ty = parseFloatWithUnits( node.getAttribute( 'y' ) );

            transform.translate( tx, ty );

        }

        if ( node.hasAttribute( 'transform' ) ) {

            var transformsTexts = node.getAttribute( 'transform' ).split( ')' );

            for ( var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {

                var transformText = transformsTexts[ tIndex ].trim();

                if ( transformText === '' ) continue;

                var openParPos = transformText.indexOf( '(' );
                var closeParPos = transformText.length;

                if ( openParPos > 0 && openParPos < closeParPos ) {

                    var transformType = transformText.substr( 0, openParPos );

                    var array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );

                    currentTransform.identity();

                    switch ( transformType ) {

                        case 'translate':

                            if ( array.length >= 1 ) {

                                var tx = array[ 0 ];
                                var ty = tx;

                                if ( array.length >= 2 ) {

                                    ty = array[ 1 ];

                                }

                                currentTransform.translate( tx, ty );

                            }

                            break;

                        case 'rotate':

                            if ( array.length >= 1 ) {

                                var angle = 0;
                                var cx = 0;
                                var cy = 0;

                                // Angle
                                angle = - array[ 0 ] * Math.PI / 180;

                                if ( array.length >= 3 ) {

                                    // Center x, y
                                    cx = array[ 1 ];
                                    cy = array[ 2 ];

                                }

                                // Rotate around center (cx, cy)
                                tempTransform1.identity().translate( - cx, - cy );
                                tempTransform2.identity().rotate( angle );
                                tempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );
                                tempTransform1.identity().translate( cx, cy );
                                currentTransform.multiplyMatrices( tempTransform1, tempTransform3 );

                            }

                            break;

                        case 'scale':

                            if ( array.length >= 1 ) {

                                var scaleX = array[ 0 ];
                                var scaleY = scaleX;

                                if ( array.length >= 2 ) {

                                    scaleY = array[ 1 ];

                                }

                                currentTransform.scale( scaleX, scaleY );

                            }

                            break;

                        case 'skewX':

                            if ( array.length === 1 ) {

                                currentTransform.set(
                                    1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,
                                    0, 1, 0,
                                    0, 0, 1
                                );

                            }

                            break;

                        case 'skewY':

                            if ( array.length === 1 ) {

                                currentTransform.set(
                                    1, 0, 0,
                                    Math.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,
                                    0, 0, 1
                                );

                            }

                            break;

                        case 'matrix':

                            if ( array.length === 6 ) {

                                currentTransform.set(
                                    array[ 0 ], array[ 2 ], array[ 4 ],
                                    array[ 1 ], array[ 3 ], array[ 5 ],
                                    0, 0, 1
                                );

                            }

                            break;

                    }

                }

                transform.premultiply( currentTransform );

            }

        }

        return transform;

    }

    function transformPath( path, m ) {

        function transfVec2( v2 ) {

            tempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );

            v2.set( tempV3.x, tempV3.y );

        }

        var isRotated = isTransformRotated( m );

        var subPaths = path.subPaths;

        for ( var i = 0, n = subPaths.length; i < n; i ++ ) {

            var subPath = subPaths[ i ];
            var curves = subPath.curves;

            for ( var j = 0; j < curves.length; j ++ ) {

                var curve = curves[ j ];

                if ( curve.isLineCurve ) {

                    transfVec2( curve.v1 );
                    transfVec2( curve.v2 );

                } else if ( curve.isCubicBezierCurve ) {

                    transfVec2( curve.v0 );
                    transfVec2( curve.v1 );
                    transfVec2( curve.v2 );
                    transfVec2( curve.v3 );

                } else if ( curve.isQuadraticBezierCurve ) {

                    transfVec2( curve.v0 );
                    transfVec2( curve.v1 );
                    transfVec2( curve.v2 );

                } else if ( curve.isEllipseCurve ) {

                    if ( isRotated ) {

                        console.warn( 'SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.' );

                    }

                    tempV2.set( curve.aX, curve.aY );
                    transfVec2( tempV2 );
                    curve.aX = tempV2.x;
                    curve.aY = tempV2.y;

                    curve.xRadius *= getTransformScaleX( m );
                    curve.yRadius *= getTransformScaleY( m );

                }

            }

        }

    }

    function isTransformRotated( m ) {

        return m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;

    }

    function getTransformScaleX( m ) {

        var te = m.elements;
        return Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );

    }

    function getTransformScaleY( m ) {

        var te = m.elements;
        return Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );

    }

    //

    var paths = [];
    var stylesheets = {};

    var transformStack = [];

    var tempTransform0 = new THREE.Matrix3();
    var tempTransform1 = new THREE.Matrix3();
    var tempTransform2 = new THREE.Matrix3();
    var tempTransform3 = new THREE.Matrix3();
    var tempV2 = new THREE.Vector2();
    var tempV3 = new THREE.Vector3();

    var currentTransform = new THREE.Matrix3();

    var xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml

    parseNode( xml.documentElement, {
        fill: '#000',
        fillOpacity: 1,
        strokeOpacity: 1,
        strokeWidth: 1,
        strokeLineJoin: 'miter',
        strokeLineCap: 'butt',
        strokeMiterLimit: 4
    } );

    var data = { paths: paths, xml: xml.documentElement };

    // console.log( paths );
    return data;

}

} );

THREE.SVGLoader.createShapes = function ( shapePath ) {

// Param shapePath: a shapepath as returned by the parse function of this class
// Returns Shape object

const BIGNUMBER = 999999999;

const IntersectionLocationType = {
    ORIGIN: 0,
    DESTINATION: 1,
    BETWEEN: 2,
    LEFT: 3,
    RIGHT: 4,
    BEHIND: 5,
    BEYOND: 6
};

const classifyResult = {
    loc: IntersectionLocationType.ORIGIN,
    t: 0
};

function findEdgeIntersection( a0, a1, b0, b1 ) {

    var x1 = a0.x;
    var x2 = a1.x;
    var x3 = b0.x;
    var x4 = b1.x;
    var y1 = a0.y;
    var y2 = a1.y;
    var y3 = b0.y;
    var y4 = b1.y;
    var nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );
    var nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );
    var denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );
    var t1 = nom1 / denom;
    var t2 = nom2 / denom;

    if ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {

        //1. lines are parallel or edges don't intersect

        return null;

    } else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {

        //2. lines are colinear

        //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)
        for ( var i = 0; i < 2; i ++ ) {

            classifyPoint( i === 0 ? b0 : b1, a0, a1 );
            //find position of this endpoints relatively to edge1
            if ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {

                var point = ( i === 0 ? b0 : b1 );
                return { x: point.x, y: point.y, t: classifyResult.t };

            } else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {

                var x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );
                var y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );
                return { x: x, y: y, t: classifyResult.t, };

            }

        }

        return null;

    } else {

        //3. edges intersect

        for ( var i = 0; i < 2; i ++ ) {

            classifyPoint( i === 0 ? b0 : b1, a0, a1 );

            if ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {

                var point = ( i === 0 ? b0 : b1 );
                return { x: point.x, y: point.y, t: classifyResult.t };

            }

        }

        var x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );
        var y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );
        return { x: x, y: y, t: t1 };

    }

}

function classifyPoint( p, edgeStart, edgeEnd ) {

    var ax = edgeEnd.x - edgeStart.x;
    var ay = edgeEnd.y - edgeStart.y;
    var bx = p.x - edgeStart.x;
    var by = p.y - edgeStart.y;
    var sa = ax * by - bx * ay;

    if ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {

        classifyResult.loc = IntersectionLocationType.ORIGIN;
        classifyResult.t = 0;
        return;

    }

    if ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {

        classifyResult.loc = IntersectionLocationType.DESTINATION;
        classifyResult.t = 1;
        return;

    }

    if ( sa < - Number.EPSILON ) {

        classifyResult.loc = IntersectionLocationType.LEFT;
        return;

    }

    if ( sa > Number.EPSILON ) {

        classifyResult.loc = IntersectionLocationType.RIGHT;
        return;


    }

    if ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {

        classifyResult.loc = IntersectionLocationType.BEHIND;
        return;

    }

    if ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {

        classifyResult.loc = IntersectionLocationType.BEYOND;
        return;

    }

    var t;

    if ( ax !== 0 ) {

        t = bx / ax;

    } else {

        t = by / ay;

    }

    classifyResult.loc = IntersectionLocationType.BETWEEN;
    classifyResult.t = t;

}

function getIntersections( path1, path2 ) {

    const intersectionsRaw = [];
    const intersections = [];

    for ( let index = 1; index < path1.length; index ++ ) {

        const path1EdgeStart = path1[ index - 1 ];
        const path1EdgeEnd = path1[ index ];

        for ( let index2 = 1; index2 < path2.length; index2 ++ ) {

            const path2EdgeStart = path2[ index2 - 1 ];
            const path2EdgeEnd = path2[ index2 ];

            const intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );

            if ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {

                intersectionsRaw.push( intersection );
                intersections.push( new THREE.Vector2( intersection.x, intersection.y ) );

            }

        }

    }

    return intersections;

}

function getScanlineIntersections( scanline, boundingBox, paths ) {

    const center = new THREE.Vector2();
    boundingBox.getCenter( center );

    const allIntersections = [];

    paths.forEach( path => {

        // check if the center of the bounding box is in the bounding box of the paths.
        // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.
        // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.
        if ( path.boundingBox.containsPoint( center ) ) {

            const intersections = getIntersections( scanline, path.points );

            intersections.forEach( p => {

                allIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );

            } );

        }

    } );

    allIntersections.sort( ( i1, i2 ) => {

        return i1.point.x - i2.point.x;

    } );

    return allIntersections;

}

function isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {

    if ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {

        _fillRule = 'nonzero';

    }

    const centerBoundingBox = new THREE.Vector2();
    simplePath.boundingBox.getCenter( centerBoundingBox );

    const scanline = [ new THREE.Vector2( scanlineMinX, centerBoundingBox.y ), new THREE.Vector2( scanlineMaxX, centerBoundingBox.y ) ];

    const scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );

    scanlineIntersections.sort( ( i1, i2 ) => {

        return i1.point.x - i2.point.x;

    } );

    const baseIntersections = [];
    const otherIntersections = [];

    scanlineIntersections.forEach( i => {

        if ( i.identifier === simplePath.identifier ) {

            baseIntersections.push( i );

        } else {

            otherIntersections.push( i );

        }

    } );

    const firstXOfPath = baseIntersections[ 0 ].point.x;

    // build up the path hierarchy
    const stack = [];
    let i = 0;

    while ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {

        if ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {

            stack.pop();

        } else {

            stack.push( otherIntersections[ i ].identifier );

        }

        i ++;

    }

    stack.push( simplePath.identifier );

    if ( _fillRule === 'evenodd' ) {

        const isHole = stack.length % 2 === 0 ? true : false;
        const isHoleFor = stack[ stack.length - 2 ];

        return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };

    } else if ( _fillRule === 'nonzero' ) {

        // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.
        let isHole = true;
        let isHoleFor = null;
        let lastCWValue = null;

        for ( let i = 0; i < stack.length; i ++ ) {

            const identifier = stack[ i ];
            if ( isHole ) {

                lastCWValue = allPaths[ identifier ].isCW;
                isHole = false;
                isHoleFor = identifier;

            } else if ( lastCWValue !== allPaths[ identifier ].isCW ) {

                lastCWValue = allPaths[ identifier ].isCW;
                isHole = true;

            }

        }

        return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };

    } else {

        console.warn( 'fill-rule: "' + _fillRule + '" is currently not implemented.' );

    }

}

// check for self intersecting paths
// TODO

// check intersecting paths
// TODO

// prepare paths for hole detection
let identifier = 0;

let scanlineMinX = BIGNUMBER;
let scanlineMaxX = - BIGNUMBER;

let simplePaths = shapePath.subPaths.map( p => {

    const points = p.getPoints();
    let maxY = - BIGNUMBER;
    let minY = BIGNUMBER;
    let maxX = - BIGNUMBER;
    let minX = BIGNUMBER;

      //points.forEach(p => p.y *= -1);

    for ( let i = 0; i < points.length; i ++ ) {

        const p = points[ i ];

        if ( p.y > maxY ) {

            maxY = p.y;

        }

        if ( p.y < minY ) {

            minY = p.y;

        }

        if ( p.x > maxX ) {

            maxX = p.x;

        }

        if ( p.x < minX ) {

            minX = p.x;

        }

    }

    //
    if ( scanlineMaxX <= maxX ) {

        scanlineMaxX = maxX + 1;

    }

    if ( scanlineMinX >= minX ) {

        scanlineMinX = minX - 1;

    }

    return { points: points, isCW: THREE.ShapeUtils.isClockWise( points ), identifier: identifier ++, boundingBox: new THREE.Box2( new THREE.Vector2( minX, minY ), new THREE.Vector2( maxX, maxY ) ) };

} );

simplePaths = simplePaths.filter( sp => sp.points.length > 0 );

// check if path is solid or a hole
const isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule ) );


const shapesToReturn = [];
simplePaths.forEach( p => {

    const amIAHole = isAHole[ p.identifier ];

    if ( ! amIAHole.isHole ) {

        const shape = new THREE.Shape( p.points );
        const holes = isAHole.filter( h => h.isHole && h.for === p.identifier );
        holes.forEach( h => {

            const path = simplePaths[ h.identifier ];
            shape.holes.push( new THREE.Path( path.points ) );

        } );
        shapesToReturn.push( shape );

    }

} );

return shapesToReturn;

};

THREE.SVGLoader.getStrokeStyle = function ( width, color, lineJoin, lineCap, miterLimit ) {

// Param width: Stroke width
// Param color: As returned by THREE.Color.getStyle()
// Param lineJoin: One of "round", "bevel", "miter" or "miter-limit"
// Param lineCap: One of "round", "square" or "butt"
// Param miterLimit: Maximum join length, in multiples of the "width" parameter (join is truncated if it exceeds that distance)
// Returns style object

width = width !== undefined ? width : 1;
color = color !== undefined ? color : '#000';
lineJoin = lineJoin !== undefined ? lineJoin : 'miter';
lineCap = lineCap !== undefined ? lineCap : 'butt';
miterLimit = miterLimit !== undefined ? miterLimit : 4;

return {
    strokeColor: color,
    strokeWidth: width,
    strokeLineJoin: lineJoin,
    strokeLineCap: lineCap,
    strokeMiterLimit: miterLimit
};

};

THREE.SVGLoader.pointsToStroke = function ( points, style, arcDivisions, minDistance ) {

// Generates a stroke with some witdh around the given path.
// The path can be open or closed (last point equals to first point)
// Param points: Array of Vector2D (the path). Minimum 2 points.
// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object
// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)
// Param minDistance: Points closer to this distance will be merged. (Optional)
// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)

var vertices = [];
var normals = [];
var uvs = [];

if ( THREE.SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {

    return null;

}

var geometry = new THREE.BufferGeometry();
geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );
geometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );

return geometry;

};

THREE.SVGLoader.pointsToStrokeWithBuffers = function () {

var tempV2_1 = new THREE.Vector2();
var tempV2_2 = new THREE.Vector2();
var tempV2_3 = new THREE.Vector2();
var tempV2_4 = new THREE.Vector2();
var tempV2_5 = new THREE.Vector2();
var tempV2_6 = new THREE.Vector2();
var tempV2_7 = new THREE.Vector2();
var lastPointL = new THREE.Vector2();
var lastPointR = new THREE.Vector2();
var point0L = new THREE.Vector2();
var point0R = new THREE.Vector2();
var currentPointL = new THREE.Vector2();
var currentPointR = new THREE.Vector2();
var nextPointL = new THREE.Vector2();
var nextPointR = new THREE.Vector2();
var innerPoint = new THREE.Vector2();
var outerPoint = new THREE.Vector2();

return function ( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {

    // This function can be called to update existing arrays or buffers.
    // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.
    // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)
    // Returns number of written vertices / normals / uvs pairs
    // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)
    // 'normals' and 'uvs' buffers are optional

    arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;
    minDistance = minDistance !== undefined ? minDistance : 0.001;
    vertexOffset = vertexOffset !== undefined ? vertexOffset : 0;

    // First ensure there are no duplicated points
    points = removeDuplicatedPoints( points );

    var numPoints = points.length;

    if ( numPoints < 2 ) return 0;

    var isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );

    var currentPoint;
    var previousPoint = points[ 0 ];
    var nextPoint;

    var strokeWidth2 = style.strokeWidth / 2;

    var deltaU = 1 / ( numPoints - 1 );
    var u0 = 0;

    var innerSideModified;
    var joinIsOnLeftSide;
    var isMiter;
    var initialJoinIsOnLeftSide = false;

    var numVertices = 0;
    var currentCoordinate = vertexOffset * 3;
    var currentCoordinateUV = vertexOffset * 2;

    // Get initial left and right stroke points
    getNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );
    lastPointL.copy( points[ 0 ] ).sub( tempV2_1 );
    lastPointR.copy( points[ 0 ] ).add( tempV2_1 );
    point0L.copy( lastPointL );
    point0R.copy( lastPointR );

    for ( var iPoint = 1; iPoint < numPoints; iPoint ++ ) {

        currentPoint = points[ iPoint ];

        // Get next point
        if ( iPoint === numPoints - 1 ) {

            if ( isClosed ) {

                // Skip duplicated initial point
                nextPoint = points[ 1 ];

            } else nextPoint = undefined;

        } else {

            nextPoint = points[ iPoint + 1 ];

        }

        // Normal of previous segment in tempV2_1
        var normal1 = tempV2_1;
        getNormal( previousPoint, currentPoint, normal1 );

        tempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );
        currentPointL.copy( currentPoint ).sub( tempV2_3 );
        currentPointR.copy( currentPoint ).add( tempV2_3 );

        var u1 = u0 + deltaU;

        innerSideModified = false;

        if ( nextPoint !== undefined ) {

            // Normal of next segment in tempV2_2
            getNormal( currentPoint, nextPoint, tempV2_2 );

            tempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );
            nextPointL.copy( currentPoint ).sub( tempV2_3 );
            nextPointR.copy( currentPoint ).add( tempV2_3 );

            joinIsOnLeftSide = true;
            tempV2_3.subVectors( nextPoint, previousPoint );
            if ( normal1.dot( tempV2_3 ) < 0 ) {

                joinIsOnLeftSide = false;

            }

            if ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;

            tempV2_3.subVectors( nextPoint, currentPoint );
            tempV2_3.normalize();
            var dot = Math.abs( normal1.dot( tempV2_3 ) );

            // If path is straight, don't create join
            if ( dot !== 0 ) {

                // Compute inner and outer segment intersections
                var miterSide = strokeWidth2 / dot;
                tempV2_3.multiplyScalar( - miterSide );
                tempV2_4.subVectors( currentPoint, previousPoint );
                tempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );
                innerPoint.copy( tempV2_5 ).negate();
                var miterLength2 = tempV2_5.length();
                var segmentLengthPrev = tempV2_4.length();
                tempV2_4.divideScalar( segmentLengthPrev );
                tempV2_6.subVectors( nextPoint, currentPoint );
                var segmentLengthNext = tempV2_6.length();
                tempV2_6.divideScalar( segmentLengthNext );
                // Check that previous and next segments doesn't overlap with the innerPoint of intersection
                if ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {

                    innerSideModified = true;

                }

                outerPoint.copy( tempV2_5 ).add( currentPoint );
                innerPoint.add( currentPoint );

                isMiter = false;

                if ( innerSideModified ) {

                    if ( joinIsOnLeftSide ) {

                        nextPointR.copy( innerPoint );
                        currentPointR.copy( innerPoint );

                    } else {

                        nextPointL.copy( innerPoint );
                        currentPointL.copy( innerPoint );

                    }

                } else {

                    // The segment triangles are generated here if there was overlapping

                    makeSegmentTriangles();

                }

                switch ( style.strokeLineJoin ) {

                    case 'bevel':

                        makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );

                        break;

                    case 'round':

                        // Segment triangles

                        createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );

                        // Join triangles

                        if ( joinIsOnLeftSide ) {

                            makeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );

                        } else {

                            makeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );

                        }

                        break;

                    case 'miter':
                    case 'miter-clip':
                    default:

                        var miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;

                        if ( miterFraction < 1 ) {

                            // The join miter length exceeds the miter limit

                            if ( style.strokeLineJoin !== 'miter-clip' ) {

                                makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );
                                break;

                            } else {

                                // Segment triangles

                                createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );

                                // Miter-clip join triangles

                                if ( joinIsOnLeftSide ) {

                                    tempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );
                                    tempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );

                                    addVertex( currentPointL, u1, 0 );
                                    addVertex( tempV2_6, u1, 0 );
                                    addVertex( currentPoint, u1, 0.5 );

                                    addVertex( currentPoint, u1, 0.5 );
                                    addVertex( tempV2_6, u1, 0 );
                                    addVertex( tempV2_7, u1, 0 );

                                    addVertex( currentPoint, u1, 0.5 );
                                    addVertex( tempV2_7, u1, 0 );
                                    addVertex( nextPointL, u1, 0 );

                                } else {

                                    tempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );
                                    tempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );

                                    addVertex( currentPointR, u1, 1 );
                                    addVertex( tempV2_6, u1, 1 );
                                    addVertex( currentPoint, u1, 0.5 );

                                    addVertex( currentPoint, u1, 0.5 );
                                    addVertex( tempV2_6, u1, 1 );
                                    addVertex( tempV2_7, u1, 1 );

                                    addVertex( currentPoint, u1, 0.5 );
                                    addVertex( tempV2_7, u1, 1 );
                                    addVertex( nextPointR, u1, 1 );

                                }

                            }

                        } else {

                            // Miter join segment triangles

                            if ( innerSideModified ) {

                                // Optimized segment + join triangles

                                if ( joinIsOnLeftSide ) {

                                    addVertex( lastPointR, u0, 1 );
                                    addVertex( lastPointL, u0, 0 );
                                    addVertex( outerPoint, u1, 0 );

                                    addVertex( lastPointR, u0, 1 );
                                    addVertex( outerPoint, u1, 0 );
                                    addVertex( innerPoint, u1, 1 );

                                } else {

                                    addVertex( lastPointR, u0, 1 );
                                    addVertex( lastPointL, u0, 0 );
                                    addVertex( outerPoint, u1, 1 );

                                    addVertex( lastPointL, u0, 0 );
                                    addVertex( innerPoint, u1, 0 );
                                    addVertex( outerPoint, u1, 1 );

                                }


                                if ( joinIsOnLeftSide ) {

                                    nextPointL.copy( outerPoint );

                                } else {

                                    nextPointR.copy( outerPoint );

                                }


                            } else {

                                // Add extra miter join triangles

                                if ( joinIsOnLeftSide ) {

                                    addVertex( currentPointL, u1, 0 );
                                    addVertex( outerPoint, u1, 0 );
                                    addVertex( currentPoint, u1, 0.5 );

                                    addVertex( currentPoint, u1, 0.5 );
                                    addVertex( outerPoint, u1, 0 );
                                    addVertex( nextPointL, u1, 0 );

                                } else {

                                    addVertex( currentPointR, u1, 1 );
                                    addVertex( outerPoint, u1, 1 );
                                    addVertex( currentPoint, u1, 0.5 );

                                    addVertex( currentPoint, u1, 0.5 );
                                    addVertex( outerPoint, u1, 1 );
                                    addVertex( nextPointR, u1, 1 );

                                }

                            }

                            isMiter = true;

                        }

                        break;

                }

            } else {

                // The segment triangles are generated here when two consecutive points are collinear

                makeSegmentTriangles();

            }

        } else {

            // The segment triangles are generated here if it is the ending segment

            makeSegmentTriangles();

        }

        if ( ! isClosed && iPoint === numPoints - 1 ) {

            // Start line endcap
            addCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );

        }

        // Increment loop variables

        u0 = u1;

        previousPoint = currentPoint;

        lastPointL.copy( nextPointL );
        lastPointR.copy( nextPointR );

    }

    if ( ! isClosed ) {

        // Ending line endcap
        addCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );

    } else if ( innerSideModified && vertices ) {

        // Modify path first segment vertices to adjust to the segments inner and outer intersections

        var lastOuter = outerPoint;
        var lastInner = innerPoint;

        if ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {

            lastOuter = innerPoint;
            lastInner = outerPoint;

        }

        if ( joinIsOnLeftSide ) {

            if ( isMiter || initialJoinIsOnLeftSide ) {

                lastInner.toArray( vertices, 0 * 3 );
                lastInner.toArray( vertices, 3 * 3 );

                if ( isMiter ) {

                    lastOuter.toArray( vertices, 1 * 3 );

                }

            }

        } else {

            if ( isMiter || ! initialJoinIsOnLeftSide ) {

                lastInner.toArray( vertices, 1 * 3 );
                lastInner.toArray( vertices, 3 * 3 );

                if ( isMiter ) {

                    lastOuter.toArray( vertices, 0 * 3 );

                }

            }

        }

    }

    return numVertices;

    // -- End of algorithm

    // -- Functions

    function getNormal( p1, p2, result ) {

        result.subVectors( p2, p1 );
        return result.set( - result.y, result.x ).normalize();

    }

    function addVertex( position, u, v ) {

        if ( vertices ) {

            vertices[ currentCoordinate ] = position.x;
            vertices[ currentCoordinate + 1 ] = position.y;
            vertices[ currentCoordinate + 2 ] = 0;

            if ( normals ) {

                normals[ currentCoordinate ] = 0;
                normals[ currentCoordinate + 1 ] = 0;
                normals[ currentCoordinate + 2 ] = 1;

            }

            currentCoordinate += 3;

            if ( uvs ) {

                uvs[ currentCoordinateUV ] = u;
                uvs[ currentCoordinateUV + 1 ] = v;

                currentCoordinateUV += 2;

            }

        }

        numVertices += 3;

    }

    function makeCircularSector( center, p1, p2, u, v ) {

        // param p1, p2: Points in the circle arc.
        // p1 and p2 are in clockwise direction.

        tempV2_1.copy( p1 ).sub( center ).normalize();
        tempV2_2.copy( p2 ).sub( center ).normalize();

        var angle = Math.PI;
        var dot = tempV2_1.dot( tempV2_2 );
        if ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );

        angle /= arcDivisions;

        tempV2_3.copy( p1 );

        for ( var i = 0, il = arcDivisions - 1; i < il; i ++ ) {

            tempV2_4.copy( tempV2_3 ).rotateAround( center, angle );

            addVertex( tempV2_3, u, v );
            addVertex( tempV2_4, u, v );
            addVertex( center, u, 0.5 );

            tempV2_3.copy( tempV2_4 );

        }

        addVertex( tempV2_4, u, v );
        addVertex( p2, u, v );
        addVertex( center, u, 0.5 );

    }

    function makeSegmentTriangles() {

        addVertex( lastPointR, u0, 1 );
        addVertex( lastPointL, u0, 0 );
        addVertex( currentPointL, u1, 0 );

        addVertex( lastPointR, u0, 1 );
        addVertex( currentPointL, u1, 1 );
        addVertex( currentPointR, u1, 0 );

    }

    function makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {

        if ( innerSideModified ) {

            // Optimized segment + bevel triangles

            if ( joinIsOnLeftSide ) {

                // Path segments triangles

                addVertex( lastPointR, u0, 1 );
                addVertex( lastPointL, u0, 0 );
                addVertex( currentPointL, u1, 0 );

                addVertex( lastPointR, u0, 1 );
                addVertex( currentPointL, u1, 0 );
                addVertex( innerPoint, u1, 1 );

                // Bevel join triangle

                addVertex( currentPointL, u, 0 );
                addVertex( nextPointL, u, 0 );
                addVertex( innerPoint, u, 0.5 );

            } else {

                // Path segments triangles

                addVertex( lastPointR, u0, 1 );
                addVertex( lastPointL, u0, 0 );
                addVertex( currentPointR, u1, 1 );

                addVertex( lastPointL, u0, 0 );
                addVertex( innerPoint, u1, 0 );
                addVertex( currentPointR, u1, 1 );

                // Bevel join triangle

                addVertex( currentPointR, u, 1 );
                addVertex( nextPointR, u, 0 );
                addVertex( innerPoint, u, 0.5 );

            }

        } else {

            // Bevel join triangle. The segment triangles are done in the main loop

            if ( joinIsOnLeftSide ) {

                addVertex( currentPointL, u, 0 );
                addVertex( nextPointL, u, 0 );
                addVertex( currentPoint, u, 0.5 );

            } else {

                addVertex( currentPointR, u, 1 );
                addVertex( nextPointR, u, 0 );
                addVertex( currentPoint, u, 0.5 );

            }

        }

    }

    function createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {

        if ( innerSideModified ) {

            if ( joinIsOnLeftSide ) {

                addVertex( lastPointR, u0, 1 );
                addVertex( lastPointL, u0, 0 );
                addVertex( currentPointL, u1, 0 );

                addVertex( lastPointR, u0, 1 );
                addVertex( currentPointL, u1, 0 );
                addVertex( innerPoint, u1, 1 );

                addVertex( currentPointL, u0, 0 );
                addVertex( currentPoint, u1, 0.5 );
                addVertex( innerPoint, u1, 1 );

                addVertex( currentPoint, u1, 0.5 );
                addVertex( nextPointL, u0, 0 );
                addVertex( innerPoint, u1, 1 );

            } else {

                addVertex( lastPointR, u0, 1 );
                addVertex( lastPointL, u0, 0 );
                addVertex( currentPointR, u1, 1 );

                addVertex( lastPointL, u0, 0 );
                addVertex( innerPoint, u1, 0 );
                addVertex( currentPointR, u1, 1 );

                addVertex( currentPointR, u0, 1 );
                addVertex( innerPoint, u1, 0 );
                addVertex( currentPoint, u1, 0.5 );

                addVertex( currentPoint, u1, 0.5 );
                addVertex( innerPoint, u1, 0 );
                addVertex( nextPointR, u0, 1 );

            }

        }

    }

    function addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {

        // param center: End point of the path
        // param p1, p2: Left and right cap points

        switch ( style.strokeLineCap ) {

            case 'round':

                if ( start ) {

                    makeCircularSector( center, p2, p1, u, 0.5 );

                } else {

                    makeCircularSector( center, p1, p2, u, 0.5 );

                }

                break;

            case 'square':

                if ( start ) {

                    tempV2_1.subVectors( p1, center );
                    tempV2_2.set( tempV2_1.y, - tempV2_1.x );

                    tempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );
                    tempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );

                    // Modify already existing vertices
                    if ( joinIsOnLeftSide ) {

                        tempV2_3.toArray( vertices, 1 * 3 );
                        tempV2_4.toArray( vertices, 0 * 3 );
                        tempV2_4.toArray( vertices, 3 * 3 );

                    } else {

                        tempV2_3.toArray( vertices, 1 * 3 );
                        tempV2_3.toArray( vertices, 3 * 3 );
                        tempV2_4.toArray( vertices, 0 * 3 );

                    }

                } else {

                    tempV2_1.subVectors( p2, center );
                    tempV2_2.set( tempV2_1.y, - tempV2_1.x );

                    tempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );
                    tempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );

                    var vl = vertices.length;

                    // Modify already existing vertices
                    if ( joinIsOnLeftSide ) {

                        tempV2_3.toArray( vertices, vl - 1 * 3 );
                        tempV2_4.toArray( vertices, vl - 2 * 3 );
                        tempV2_4.toArray( vertices, vl - 4 * 3 );

                    } else {

                        tempV2_3.toArray( vertices, vl - 2 * 3 );
                        tempV2_4.toArray( vertices, vl - 1 * 3 );
                        tempV2_4.toArray( vertices, vl - 4 * 3 );

                    }

                }

                break;

            case 'butt':
            default:

                // Nothing to do here
                break;

        }

    }

    function removeDuplicatedPoints( points ) {

        // Creates a new array if necessary with duplicated points removed.
        // This does not remove duplicated initial and ending points of a closed path.

        var dupPoints = false;
        for ( var i = 1, n = points.length - 1; i < n; i ++ ) {

            if ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {

                dupPoints = true;
                break;

            }

        }

        if ( ! dupPoints ) return points;

        var newPoints = [];
        newPoints.push( points[ 0 ] );

        for ( var i = 1, n = points.length - 1; i < n; i ++ ) {

            if ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {

                newPoints.push( points[ i ] );

            }

        }

        newPoints.push( points[ points.length - 1 ] );

        return newPoints;

    }

};

}();































//________________________________________________________________________________
//  APPLY SVG LOADER




                console.log('svgFileInput: ',svgFileInput);

                loadSVG( svgFileInput );


                function loadSVG( url )
                {


                    var loader = new THREE.SVGLoader();

                    loader.load( url, function ( data )
                    {

                        var paths = data.paths;


                        var meshGroupName;


                        console.log('data from data: ',data);

                        // const styleFromData = style.textContent;
                        // console.log('styleFromData: ',styleFromData);


                        // const styleFromNodes = data.xml.ownerDocument.all[2].childNodes[0];
                        // console.log('styleFromNodes: ',styleFromNodes);

                        SVGname = data.xml.attributes.id.value;
                        console.log('SVGname: ',SVGname);


                        const SVGheight = data.xml.attributes.height.value;
                        console.log('SVGheight: ',SVGheight);

                        SVGheightHalf = (Math.round(data.xml.attributes.height.value / -2 ));
                        console.log('SVGheightHalf: ',SVGheightHalf);



                        const SVGwidth = data.xml.attributes.width.value;
                        console.log('SVGwidth: ',SVGwidth);

                        SVGwidthHalf = (Math.round(data.xml.attributes.width.value / -2));
                        console.log('SVGwidthHalf: ',SVGwidthHalf)




                        // var group = new THREE.Group();
                        // group = new THREE.Group();
                        group.name = SVGname;

                        group.svgDataPaths = data.paths;

                        // var scaleFactor = SVGwidth / (scaleInput * 0.001);

                        // NOTE: this is considering a width of 1000. must figure calculation
                        var scaleFactor = scaleInput * 0.001;

                        group.scale.multiplyScalar( scaleFactor );
                        // group.scale.multiplyScalar( 0.005 );
                        // group.position.y = 3.75;
                        // group.position.x = - 70;

                        group.scale.y *= - 1;


                        // MR DOOB SETTINGS FOR EXAMPLE
                        // group.scale.multiplyScalar( 0.25 );
                        // group.position.x = - 70;
                        // group.position.y = 70;

                        // var thisColor = '#00368a';
                        // processNode( data.xml, group, thisColor );
                        processNode( data.xml, group, null );

                        // app.scene.add( group );
                        // console.log('group: ',group);

                        function processNode( node, currentGroup, overrideColor )
                        {

                            if ( node.nodeName === 'g' ) {

                                console.log('g: ',node);

                                let groupName = node.id;
                                console.log('groupName: ',groupName);

                                let newGroup = new THREE.Group();
                                newGroup.name = groupName;

                                // let extrudedGroup = new THREE.Group();
                                // app.scene.add(newGroup);//test adding by me

                                console.log('newGroup.name: ',newGroup.name);
                                // overrideColor = '#9f8600'
                                // overrideColor = '#' + Math.floor( Math.random() * ( 1 << 24 ) )
                                // .toString( 16 );




                                // currentGroup.add( newGroup );?????

                                currentGroup = newGroup;

                            }
                            else {

                                for ( let i = 0; i < paths.length; i ++ )
                                {

                                    let path = paths[ i ];
                                    if ( path.userData.node === node ) {

                                        console.log('path: ',node);
                                        meshGroupName = node.parentNode.id;
                                        console.log('meshGroupName: ',meshGroupName);

                                        createPathGeometry( path, currentGroup, overrideColor );
                                        break;

                                    }
                                }

                            }

                            let nodes = node.childNodes;

                            for ( let i = 0; i < nodes.length; i ++ ) {

                                processNode( nodes[ i ], currentGroup, overrideColor );

                            }

                        };  //  END process node






                        function createPathGeometry( path, currentGroup, overrideColor )
                        {

                            let material;

                            // separateObjectsCheckbox

                            if ( separateObjectsCheckbox == false )
                            {
                                material = new THREE.MeshBasicMaterial(
                                // material = new THREE.MeshNormalMaterial(
                                {
                                    // color: new THREE.Color().setStyle( materialColor ),
                                    color: new THREE.Color().setStyle( path.userData.style.fill ),
                                    opacity: path.userData.style.fillOpacity,
                                    transparent: path.userData.style.fillOpacity < 1,
                                    side: THREE.DoubleSide,
                                    depthWrite: false,
                                    // wireframe: guiData.fillShapesWireframe
                                }
                                );

                                material.name =  'SVG_' + SVGname;

                            }



                            // var shapes = path.toShapes( true );  // old way
                            const shapes = THREE.SVGLoader.createShapes( path );

                            for ( let j = 0; j < shapes.length; j ++ )
                            {

                                let shape = shapes[j];

                                let geometry = new THREE.ShapeBufferGeometry( shape );


                                if ( separateObjectsCheckbox == true )
                                {
                                    material = new THREE.MeshBasicMaterial
                                    (
                                    // material = new THREE.MeshNormalMaterial(
                                        {
                                            color: new THREE.Color().setStyle( path.userData.style.fill ),
                                            opacity: path.userData.style.fillOpacity,
                                            transparent: path.userData.style.fillOpacity < 1,
                                            side: THREE.DoubleSide,
                                            depthWrite: false,
                                            // name: path.id + '_' + SVGname
                                            // wireframe: guiData.fillShapesWireframe
                                        }
                                    );


                                    // this makes each material  available
                                    // material.name = 'SVG' + path.id + '_' + SVGname;
                                    material.name = 'SVG_' + path.id;
                                    // material.name = 'mat_' + SVGname;





                                }



                                let mesh = new THREE.Mesh( geometry, material );


                                if ( separateObjectsCheckbox == true )
                                {
                                    mesh.name = 'SVG_' + path.userData.node.id;

                                };

                                mesh.svgDataPaths = path;
                                mesh.groupName = meshGroupName;
                                mesh.SVGname = SVGname;

                                LIST_svgParts.push(mesh.name);



                                mesh.position.x = SVGwidthHalf;
                                mesh.position.y = SVGheightHalf;

                                mesh.material.depthWrite = true;

                                mesh.svgSize =
                                {
                                    x: SVGwidthHalf,
                                    y: SVGheightHalf
                                };
                                console.log('SVG loader - mesh.svgSize: ',mesh.svgSize);



                                currentGroup.add( mesh );


                            }

                        }



                        app.scene.add( group );
                        console.log('group: ',group);

                        console.log('LIST_svgParts: ',LIST_svgParts);

                    } );  // end loader

            };  //  END loadSVG

//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}




// utility function envoked by almost all V3D-specific puzzles
// filter off some non-mesh types
function notIgnoredObj(obj) {
    return obj.type !== 'AmbientLight' &&
           obj.name !== '' &&
           !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
           !obj.isAuxClippingMesh;
}


// utility function envoked by almost all V3D-specific puzzles
// find first occurence of the object by its name
function getObjectByName(objName) {
    var objFound;
    var runTime = _pGlob !== undefined;
    objFound = runTime ? _pGlob.objCache[objName] : null;

    if (objFound && objFound.name === objName)
        return objFound;

    appInstance.scene.traverse(function(obj) {
        if (!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
            objFound = obj;
            if (runTime) {
                _pGlob.objCache[objName] = objFound;
            }
        }
    });
    return objFound;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects on the scene
function getAllObjectNames() {
    var objNameList = [];
    appInstance.scene.traverse(function(obj) {
        if (notIgnoredObj(obj))
            objNameList.push(obj.name)
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects which belong to the group
function getObjectNamesByGroupName(targetGroupName) {
    var objNameList = [];
    appInstance.scene.traverse(function(obj){
        if (notIgnoredObj(obj)) {
            var groupNames = obj.groupNames;
            if (!groupNames)
                return;
            for (var i = 0; i < groupNames.length; i++) {
                var groupName = groupNames[i];
                if (groupName == targetGroupName) {
                    objNameList.push(obj.name);
                }
            }
        }
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// process object input, which can be either single obj or array of objects, or a group
function retrieveObjectNames(objNames) {
    var acc = [];
    retrieveObjectNamesAcc(objNames, acc);
    return acc.filter(function(name) {
        return name;
    });
}

function retrieveObjectNamesAcc(currObjNames, acc) {
    if (typeof currObjNames == "string") {
        acc.push(currObjNames);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
        var newObj = getObjectNamesByGroupName(currObjNames[1]);
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "ALL_OBJECTS") {
        var newObj = getAllObjectNames();
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames)) {
        for (var i = 0; i < currObjNames.length; i++)
            retrieveObjectNamesAcc(currObjNames[i], acc);
    }
}





/**
 * Retrieve coordinate system from the loaded scene
 */
function getCoordSystem() {
    var scene = appInstance.scene;

    if (scene && "v3d" in scene.userData && "coordSystem" in scene.userData.v3d) {
        return scene.userData.v3d.coordSystem;
    } else {
        // COMPAT: <2.17, consider replacing to 'Y_UP_RIGHT' for scenes with unknown origin
        return 'Z_UP_RIGHT';
    }
}


/**
 * Transform coordinates from one space to another
 * Can be used with Vector3 or Euler.
 */
function coordsTransform(coords, from, to, noSignChange) {

    if (from == to)
        return coords;

    var y = coords.y, z = coords.z;

    if (from == 'Z_UP_RIGHT' && to == 'Y_UP_RIGHT') {
        coords.y = z;
        coords.z = noSignChange ? y : -y;
    } else if (from == 'Y_UP_RIGHT' && to == 'Z_UP_RIGHT') {
        coords.y = noSignChange ? z : -z;
        coords.z = y;
    } else {
        console.error('coordsTransform: Unsupported coordinate space');
    }

    return coords;
}


/**
 * Verge3D euler rotation to Blender/Max shortest.
 * 1) Convert from intrinsic rotation (v3d) to extrinsic XYZ (Blender/Max default
 *    order) via reversion: XYZ -> ZYX
 * 2) swizzle ZYX->YZX
 * 3) choose the shortest rotation to resemble Blender's behavior
 */
var eulerV3DToBlenderShortest = function() {

    var eulerTmp = new v3d.Euler();
    var eulerTmp2 = new v3d.Euler();
    var vec3Tmp = new v3d.Vector3();

    return function(euler, dest) {

        var eulerBlender = eulerTmp.copy(euler).reorder('YZX');
        var eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();

        var len = eulerBlender.toVector3(vec3Tmp).lengthSq();
        var lenAlt = eulerBlenderAlt.toVector3(vec3Tmp).lengthSq();

        dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
        return coordsTransform(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
    }

}();




function RotationInterface() {
    /**
     * For user manipulations use XYZ extrinsic rotations (which
     * are the same as ZYX intrinsic rotations)
     *     - Blender/Max/Maya use extrinsic rotations in the UI
     *     - XYZ is the default option, but could be set from
     *       some order hint if exported
     */
    this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
    this._actualRotation = new v3d.Euler();
}

Object.assign(RotationInterface, {
    initObject: function(obj) {
        if (obj.userData.v3d.puzzles === undefined) {
            obj.userData.v3d.puzzles = {}
        }
        if (obj.userData.v3d.puzzles.rotationInterface === undefined) {
            obj.userData.v3d.puzzles.rotationInterface = new RotationInterface();
        }

        var rotUI = obj.userData.v3d.puzzles.rotationInterface;
        rotUI.updateFromObject(obj);
        return rotUI;
    }
});

Object.assign(RotationInterface.prototype, {

    updateFromObject: function(obj) {
        var SYNC_ROT_EPS = 1e-8;

        if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
            this._actualRotation.copy(obj.rotation);
            this._updateUserRotFromActualRot();
        }
    },

    getActualRotation: function(euler) {
        return euler.copy(this._actualRotation);
    },

    setUserRotation: function(euler) {
        // don't copy the order, since it's fixed to ZYX for now
        this._userRotation.set(euler.x, euler.y, euler.z);
        this._updateActualRotFromUserRot();
    },

    getUserRotation: function(euler) {
        return euler.copy(this._userRotation);
    },

    _updateUserRotFromActualRot: function() {
        var order = this._userRotation.order;
        this._userRotation.copy(this._actualRotation).reorder(order);
    },

    _updateActualRotFromUserRot: function() {
        var order = this._actualRotation.order;
        this._actualRotation.copy(this._userRotation).reorder(order);
    }

});




// setObjTransform puzzle
function setObjTransform(objSelector, isWorldSpace, mode, vector, offset){
    var x = vector[0];
      var y = vector[1];
      var z = vector[2];

    var objNames = retrieveObjectNames(objSelector);

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    var inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''),
            Number(z !== ''));
    var coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.MathUtils.DEG2RAD);
    }

    var coordSystem = getCoordSystem();

    coordsTransform(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    coordsTransform(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (var i = 0; i < objNames.length; i++) {

        var objName = objNames[i];
        if (!objName) continue;

        var obj = getObjectByName(objName);
        if (!obj) continue;

        if (isWorldSpace && obj.parent) {
            obj.matrixWorld.decomposeE(obj.position, obj.rotation, obj.scale);

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

            obj.matrixWorld.composeE(obj.position, obj.rotation, obj.scale);
            obj.matrix.multiplyMatrices(_pGlob.mat4Tmp.copy(obj.parent.matrixWorld).invert(), obj.matrixWorld);
            obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);

        } else if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            var euler = eulerV3DToBlenderShortest(obj.rotation, _pGlob.eulerTmp);
            coordsTransform(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            var rotUI = RotationInterface.initObject(obj);
            var euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {
            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

        }

        obj.updateMatrixWorld(true);
    }

}



// createObject puzzle
function createObject(type, name, width, height, depth, radius, tube, segments, cameraType, lightType, fov) {

    var oldObj = appInstance.scene.getObjectByName(name);
    if (oldObj) {
        oldObj.parent.remove(oldObj);
    }

    var obj;
    var geometry;

    switch (type) {
        case 'BOX':
            geometry = new v3d.BoxGeometry(width, height, depth);
            break;
        case 'CAMERA':
            var aspect = appInstance.container.offsetWidth / appInstance.container.offsetHeight;

            if (cameraType == 'PERSPECTIVE') {

                obj = new v3d.PerspectiveCamera(fov, aspect, 1, 1000);

            } else {

                var width = fov * aspect;
                obj = new v3d.OrthographicCamera(-width/2, width/2, fov/2, -fov/2, -1000, 1000);

            }

            obj.lookAt(_pGlob.vec3Tmp.set(0, 0, 0));
            break;
        case 'CIRCLE':
            geometry = new v3d.CircleGeometry(radius, segments);
            break;
        case 'CONE':
            geometry = new v3d.ConeGeometry(radius, height, segments);
            break;
        case 'CYLINDER':
            geometry = new v3d.CylinderGeometry(radius, radius, height, segments);
            break;
        case 'EMPTY':
            obj = new v3d.Object3D();
            break;
        case 'LIGHT':
            var color = 0xffffff;
            var intensity = 0.5;

            switch (lightType) {
                case 'AMBIENT':
                    obj = new v3d.AmbientLight(color, intensity);
                    break;
                case 'AREA':
                    v3d.RectAreaLightUniformsLib.init(LTC_MAT_1, LTC_MAT_2);
                    obj = new v3d.RectAreaLight(color, intensity, 1, 1);
                    break;
                case 'DIRECTIONAL':
                    obj = new v3d.DirectionalLight(color, intensity);
                    break;
                case 'HEMISPHERE':
                    obj = new v3d.HemisphereLight(color, 0, intensity);
                    break;
                case 'POINT':
                    obj = new v3d.PointLight(color, intensity);
                    break;
                case 'SPOT':
                    obj = new v3d.SpotLight(color, intensity);
                    break;
            }

            obj.isFreeLight = true;

            break;
        case 'PLANE':
            geometry = new v3d.PlaneGeometry(width, height, 1, 1);
            break;
        case 'SPHERE':
            geometry = new v3d.SphereGeometry(radius, 32, 32);
            break;
        case 'TEAPOT':
            geometry = new v3d.TeapotGeometry(width);
            break;
        case 'TORUS':
            geometry = new v3d.TorusGeometry(radius, tube, 32, 32);
            break;
    }

    if (geometry) {
        var material = new v3d.MeshStandardMaterial({
            color: 'white',
            roughness: 1.0,
            metalness: 0.0,
            side: (type == 'CIRCLE' || type == 'PLANE' || type == 'TEAPOT') ? v3d.DoubleSide : v3d.FrontSide
        });

        material.name = name + 'Material';

        obj = new v3d.Mesh(geometry, material);
    }

    obj.name = name;

    appInstance.scene.add(obj);

    // clean object cache
    _pGlob.objCache = {};

}



// makeParent puzzle
function makeParent(objName, targetObjName) {
    if (!objName)
        return;
    var obj = getObjectByName(objName);
    if (!obj)
        return;
    if (targetObjName && targetObjName !== LIST_NONE) {
        var targetObj = getObjectByName(targetObjName);
        if (!targetObj)
            return;
    } else {
        obj.traverseAncestors(function(ancObj) {
            if (ancObj.type == "Scene")
                targetObj = ancObj;
        });
    }
    var matOffset = new v3d.Matrix4();
    matOffset.copy(targetObj.matrixWorld).invert();
    matOffset.multiply(obj.matrixWorld);
    matOffset.decompose(obj.position, obj.quaternion, obj.scale);
    targetObj.add(obj);

    obj.updateMatrixWorld(true);
}



// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}


// Describe this function...
function UPLOADED_SVG(file) {
  RESET_OBJECTS();

          svgAsObjLoader
          (
              file,
              1,
              false,
          )
          registerSetTimeout(0.5, function() {
    Current_SVG = 'Verge3D_Logo_Parts';
    EXTRUDE_OBJECTS('Verge3D_Logo_Parts', 200);
    registerSetTimeout(0.5, function() {
      LIST_SVG_Parts_Extruded = ['SVG_dot_Extruded', 'SVG_arc_Extruded', 'SVG_fill_Extruded', 'SVG_border_Extruded'];
      Current_SVG_Extruded_Empty = String(Current_SVG) + '_Extruded_Empty';
      setObjTransform(Current_SVG, false, 'scale', ['', 0.35, ''], false);
      createObject('EMPTY', Current_SVG_Extruded_Empty, 0, 0, 0, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
      setObjTransform(Current_SVG_Extruded_Empty, false, 'position', ['', 0.5, ''], false);
      for (var q_index in LIST_SVG_Parts_Extruded) {
        q = LIST_SVG_Parts_Extruded[q_index];
        makeParent(q, Current_SVG_Extruded_Empty);
      }
      SVG_Empty_Scale = 0.5;
      setObjTransform(Current_SVG_Extruded_Empty, false, 'scale', [SVG_Empty_Scale, SVG_Empty_Scale, SVG_Empty_Scale], false);
      setObjTransform(Current_SVG_Extruded_Empty, false, 'position', [2, 0, 1.25], false);
      setObjTransform(Current_SVG, false, 'scale', [0.0025, 0.0025, -0.0025], false);
      setObjTransform(Current_SVG, false, 'position', [-2, '', 1.25], false);
      ROTATE_OBJECT(Current_SVG_Extruded_Empty);
    });
  });
}


// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}



// addHTMLElement puzzle
function addHTMLElement(elemType, id, mode, targetId, isParent) {

    var win = isParent ? window.parent : window;

    var elem = win.document.createElement(elemType);
    if (id !== '')
        elem.id = id;

    var targetElem = getElement(targetId, isParent);
    if (targetElem instanceof win.Element) {
        switch (mode) {
            case 'TO':
                targetElem.appendChild(elem);
                break;
            case 'BEFORE':
                targetElem.insertAdjacentElement('beforebegin', elem);
                break;
            case 'AFTER':
                targetElem.insertAdjacentElement('afterend', elem);
                break;
        }
    }
}



// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if (attr === 'style') {
            // NOTE: setting an attribute 'style' instead of a property 'style'
            // fixes IE11 wrong behavior
            elem.setAttribute(attr, value);
        } else if ((attr == 'href' || attr == 'src') && value instanceof Promise) {
            // resolve promise value for url-based attributes
            value.then(function(response) {
                elem[attr] = response;
            });
        } else {
            elem[attr] = value;
        }
    }
}



// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}


// Describe this function...
function INSTRUCTIONS() {
  addHTMLElement('div', 'instructions', 'TO', ['CONTAINER'], false);
  setHTMLElemAttribute('innerHTML', 'Select one of the logos below to load their SVG<br>or select \'upload\' to load a local file or from a URL.', 'instructions', false);
  setHTMLElemStyle('fontFamily', 'arial', 'instructions', false);
  setHTMLElemStyle('color', 'white', 'instructions', false);
}


// openFile puzzle
function openFile(callback) {

    _pGlob.openedFile = '';

    var input = document.createElement('input');
    input.type = 'file';
    input.style = 'display: none';
    // NOTE: fixes iOS event issue
    document.body.appendChild(input);

    function inputChangeCb(event) {
        var file = event.target.files[0];

        var reader = new FileReader();

        reader.addEventListener('load', function () {
            _pGlob.openedFile = reader.result;
            callback();
            document.body.removeChild(input);
        }, false);

        reader.readAsDataURL(file);
    }
    input.addEventListener('change', inputChangeCb);
    if (v3d.PL.editorEventListeners)
        v3d.PL.editorEventListeners.push([input, 'change', inputChangeCb]);

    if (appInstance.controls) {
        appInstance.controls.forceMouseUp();
    }

    input.click();
}



// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;
        elem.addEventListener(eventType, callback);
        if (v3d.PL.editorEventListeners)
            v3d.PL.editorEventListeners.push([elem, eventType, callback]);
    }
}


// Describe this function...
function BUTTON_UPLOAD() {
  RESET_OBJECTS();
  addHTMLElement('button', 'button_upload', 'TO', ['CONTAINER'], false);
  setHTMLElemAttribute('innerHTML', 'UPLOAD', 'button_upload', false);
  setHTMLElemStyle('fontFamily', 'arial', 'button_upload', false);
  setHTMLElemStyle('color', 'white', 'button_upload', false);
  setHTMLElemStyle('fontSize', '40', 'button_upload', false);
  setHTMLElemStyle('fontStyle', 'bold', 'button_upload', false);
  setHTMLElemStyle('background', 'transparent', 'button_upload', false);
  setHTMLElemStyle('border', '0', 'button_upload', false);
  BUTTONS_POINTER('button_upload');
  eventHTMLElem('pointerup', 'button_upload', false, function(event) {
    openFile(function() {});
  });
}

// Describe this function...
function FORM_URL() {
  RESET_OBJECTS();
  addHTMLElement('form', 'form_url', 'TO', ['CONTAINER'], false);
  setHTMLElemAttribute('innerHTML', 'RESET', 'form_url', false);
  setHTMLElemStyle('fontFamily', 'arial', 'form_url', false);
  setHTMLElemStyle('color', 'white', 'form_url', false);
  setHTMLElemStyle('fontSize', '40', 'form_url', false);
  setHTMLElemStyle('fontStyle', 'bold', 'form_url', false);
  setHTMLElemStyle('background', 'transparent', 'form_url', false);
  setHTMLElemStyle('border', '0', 'form_url', false);
  eventHTMLElem('input', 'form_url', false, function(event) {
    openFile(function() {});
  });
}

// Describe this function...
function BUTTON_RESET() {
  addHTMLElement('button', 'button_reset', 'TO', ['CONTAINER'], false);
  setHTMLElemAttribute('innerHTML', 'RESET', 'button_reset', false);
  setHTMLElemStyle('fontFamily', 'arial', 'button_reset', false);
  setHTMLElemStyle('color', 'white', 'button_reset', false);
  setHTMLElemStyle('fontSize', '40', 'button_reset', false);
  setHTMLElemStyle('fontStyle', 'bold', 'button_reset', false);
  setHTMLElemStyle('background', 'transparent', 'button_reset', false);
  setHTMLElemStyle('border', '0', 'button_reset', false);
  BUTTONS_POINTER('button_reset');
  eventHTMLElem('pointerup', 'button_reset', false, function(event) {
    RESET_OBJECTS();
  });
}


// dropFileTo puzzle
function dropFileTo(ids, isParent, dropCb, dragOverCb) {

    var elems = getElements(ids, isParent);

    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        function dropEventCb(event) {
            if (event.dataTransfer && event.dataTransfer.files.length) {
                var file = event.dataTransfer.files[0];

                var reader = new FileReader();

                reader.addEventListener('load', function() {
                    _pGlob.openedFile = reader.result;
                    dropCb(event);
                }, false);

                reader.readAsDataURL(file);
            }

            event.preventDefault();
        }
        elem.addEventListener('drop', dropEventCb);
        if (v3d.PL.editorEventListeners)
            v3d.PL.editorEventListeners.push([elem, 'drop', dropEventCb]);

        function dragOverEventCb(event) {
            dragOverCb(event);
            event.preventDefault();
        }
        elem.addEventListener('dragover', dragOverEventCb);
        if (v3d.PL.editorEventListeners)
            v3d.PL.editorEventListeners.push([elem, 'dragover', dragOverEventCb]);

    }

}


// Describe this function...
function MAKE_BUTTONS() {
  BUTTON_GLIFTEK();
  addHTMLElement('br', '', 'TO', ['CONTAINER'], false);
  BUTTON_VERGE_3D();
  addHTMLElement('br', '', 'TO', ['CONTAINER'], false);
  BUTTON_UPLOAD();
  addHTMLElement('br', '', 'TO', ['CONTAINER'], false);
  BUTTON_RESET();
  dropFileTo(['CONTAINER'], false, function() {}, function() {});
}


// removeObject puzzles
function removeObject(objSelector) {
    var objNames = retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (!obj || !obj.parent)
            continue;

        obj.parent.remove(obj);

        // clean object cache
        _pGlob.objCache = {};
    }
}



// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
    }
}


// Describe this function...
function RESET_OBJECTS() {
  removeObject(Current_SVG);
  removeObject(LIST_SVG_Parts_Extruded);
  removeObject(Current_SVG_Extruded_Empty);
  changeVis('Plane', false);
}


function extrudeGeometry() {
    return (function

//____________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        objInput,
        // nameInput,
        segmentInput,
        depthScaleInput,
        separateMaterialsCheckbox,
        frontAndBackMatInput,
        sideMatInput,
        bevelEnabledCheckbox,
        bevelThicknessInput,
        bevelSizeInput,
        bevelOffsetInput,
        bevelSegmentsInput
    )
    {
//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Extrude Geometry';
        let svgDataPaths;
//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !objInput || typeof objInput == 'undefined' || objInput == '<none>' ) {
            console.log('[ GLIFTEK ]: The',puzzleName, 'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

        function mainFunction()
        {

//________________________________________________________________________________
//  CORE CODE


            if (
                objInput.type !== "Object3D" ||
                objInput.type !== "Group" ||
                objInput.type !== "Mesh"
                )
            {
                objInput = app.scene.getObjectByName(objInput);
                console.log('objInput: ',objInput);
            };

            if ( objInput.children !== -1 )
            {
                console.log('objInput.children: ',objInput.children);

                objInput.children.forEach(item =>
                {
                    extrudeObject(item)
                });
            };




            function extrudeObject(obj)
            {

                console.log('obj: ',obj);

                //  IS obj A GROUP OF ITEMS
                if ( obj.svgDataPaths.length > 1 )
                {
                    svgDataPaths = obj.svgDataPaths;
                }
                //  IS obj A SINGLE ITEM
                else if ( obj.svgDataPaths.length = 1 )
                {
                    svgDataPaths = [];
                    svgDataPaths.push(obj.svgDataPaths);
                }
                // let svgDataPaths = obj.svgDataPaths;
                // console.log('svgDataPaths: ',svgDataPaths);


                console.log('Extrude Geometery - svgDataPaths: ',svgDataPaths);


                const svgGroup = new THREE.Group();



                // Loop through all of the parsed paths
                svgDataPaths.forEach((path) =>
                {
                    console.log('Extrude Geometery - path: ',path);
                    // console.log('Extrude Geometery - i: ',i);

                    const shapes = path.toShapes(true);

                    // Each path has array of shapes
                    shapes.forEach((shape) =>
                    {

                        // console.log('Extrude Geometery - shape: ',shape);
                        // console.log('Extrude Geometery - j: ',j);

                        // Finally we can take each shape and extrude it
                        const geometry = new THREE.ExtrudeGeometry(shape,
                        {
                            steps: segmentInput,
                            depth: depthScaleInput,
                            bevelEnabled: bevelEnabledCheckbox,
                            bevelThickness: bevelThicknessInput,
                            bevelSize: bevelSizeInput,
                            bevelOffset: bevelOffsetInput,
                            bevelSegments: bevelSegmentsInput
                        });



                        let mesh;

                        if ( separateMaterialsCheckbox == true )
                        {

                            console.log('frontAndBackMatInput',frontAndBackMatInput);

                            let frontAndBackMatInputMat

                            app.scene.traverse( function( node )
                            {
                                if ( node instanceof v3d.Mesh )
                                {
                                    if (node.material.name == frontAndBackMatInput )
                                    {
                                        frontAndBackMatInputMat = node.material;
                                    }
                                }
                            });


                            console.log('sideMatInput',sideMatInput);

                            let sideMatInputMat;

                            app.scene.traverse( function( node )
                            {
                                if ( node instanceof v3d.Mesh )
                                {
                                    if (node.material.name == sideMatInput )
                                    {
                                        sideMatInputMat = node.material;
                                    }
                                }
                            });

                            //let material_frontAndBack = new THREE.MeshNodeMaterial ({ color: 0xff0000 });
                            let material_frontAndBack = frontAndBackMatInputMat;
                            // material_frontAndBack.name = path.id + '_' + obj.name + '_frontAndBack';
                            material_frontAndBack.name = 'SVG_' + path.id + '_frontAndBack';
                            console.log('material_frontAndBack',material_frontAndBack);

                            // let material_Sides = new THREE.MeshNodeMaterial ({ color: 0x00ff00 });

                            let material_Sides = sideMatInputMat;
                            // material_Sides.name = path.id + '_' + obj.name + '_Sides';
                            material_Sides.name = 'SVG_' + path.id + '_Sides';
                            console.log('material_Sides',material_Sides);


                            let materials = [ material_frontAndBack, material_Sides ];


                            // Create a mesh and add it to the group
                            // const mesh = new THREE.Mesh(geometry, material);
                            mesh = new THREE.Mesh(geometry, materials);

                            console.log('mesh.material[0].name',mesh.material[0].name);
                            console.log('mesh.material[1].name',mesh.material[1].name);
                            //console.log('mesh',mesh);


                        }   //  END if ( separateMaterialsCheckbox == true )



                        else if ( separateMaterialsCheckbox == false )
                        {

                            // let material = new THREE.MeshBasicMaterial
                            let material = new THREE.MeshPhongMaterial
                            // let material = new THREE.MeshLambertMaterial
                            // let material = new THREE.MeshStandardMaterial
                            // let material = new THREE.MeshPhysicalMaterial
                            ({
                                color: new THREE.Color().setStyle( path.userData.style.fill ),
                                opacity: path.userData.style.fillOpacity,
                                transparent: path.userData.style.fillOpacity < 1,
                                side: THREE.DoubleSide,
                                depthWrite: true,
                            });

                            // material.flatShading = false;


                            // console.log('path.userData.style.fill',path.userData.style.fill);
                            // let nodeRGB_var = setRGBA( path.userData.style.fill, 1 );
                            // console.log('nodeRGB_var',nodeRGB_var);
                            // let material = new v3d.MeshNodeMaterial();
                            // material.nodeRGB = nodeRGB_var;
                            // material.side = THREE.DoubleSide;
                            // material.depthWrite = false;

                            material.name = 'SVG_' + path.id + '_Extruded';
                            console.log('mesh material from Extrude:',material);

                            geometry.computeVertexNormals();
                            geometry.computeFaceNormals();
                            mesh = new THREE.Mesh(geometry, material);

                        };  //  END else if ( separateMaterialsCheckbox == false )



                    if ( svgDataPaths.length > 1 )
                    {
                        svgGroup.add(mesh);
                        offsetObjectsToCenter();
                        console.log('RUNNING offsetObjectsToCenter();');
                    }
                    else if ( svgDataPaths.length = 1 )
                    {
                        const scaleLevel = -.005;
                        mesh.scale.set(scaleLevel,scaleLevel,scaleLevel);

                        mesh.scale.y *= -1;
                        mesh.rotateX(Math.PI/180 * 180);
                        mesh.rotateY(Math.PI/180 * 180);

                        // mesh.name = nameInput;
                    //mesh.name = path.id + '_Extruded';
                        mesh.castShadow = true;
                        app.scene.add(mesh);


                        function getCenterPoint(mesh)
                        {
                            var geometry = mesh.geometry;
                            geometry.computeBoundingBox();
                            var center = new THREE.Vector3();
                            geometry.boundingBox.getCenter( center );
                            mesh.localToWorld( center );
                            return center;
                        }
                        // MAKE IF CENTERED ROTATIONAL AXIS checkbox == true
                        let empty = new v3d.Object3D;
                        // empty.name = path.id + '_Extruded_Center';
                        empty.name = 'SVG_' + path.id + '_Extruded';
                        // empty.name = 'SVG_' + obj.userData.node.id + '_Extruded';
                        // app.scene.add(empty);
                        // svgGroup.add(empty);


                        svgGroup.add(empty);
                        app.scene.add(svgGroup);

                        // const axesHelper = new THREE.AxesHelper( .1 );
                        // empty.attach(axesHelper);

                        // console.log('getCenterPoint(mesh):',getCenterPoint(mesh));
                        // console.log('getCenterPoint(mesh).x:',getCenterPoint(mesh).x);

                        empty.position.x = getCenterPoint(mesh).x * ( scaleLevel * -1 );
                        empty.position.y = getCenterPoint(mesh).y * scaleLevel;
                        empty.position.z = getCenterPoint(mesh).z * scaleLevel;

                        empty.attach(mesh);
                        // console.log('EXTRUDING - obj.svgSize:',obj.svgSize);
                        // console.log('EXTRUDING - obj.svgSize.x:',obj.svgSize.x);
                        empty.translateX( obj.svgSize.x * ( scaleLevel * -1 ));
                        empty.translateY( obj.svgSize.y * scaleLevel );

                    };  //  END if else if ( svgDataPaths.length = 1 )



                });     // END shapes.forEach((shape)

            }); // END  svgDataPaths.forEach((path)







                // Meshes we got are all relative to themselves
                // meaning they have position set to (0, 0, 0)
                // which makes centering them in the group easy

                function offsetObjectsToCenter()
                {
                    // Get group's size
                    const box = new THREE.Box3().setFromObject(svgGroup);
                    const size = new THREE.Vector3();
                    box.getSize(size);

                    const yOffset = size.y / -2;
                    // const yOffset = size.y;
                    const xOffset = size.x / -2;
                    // const xOffset = size.x;

                    // Offset all of group's elements, to center them
                    svgGroup.children.forEach(item => {
                    item.position.x = xOffset;
                    item.position.y = yOffset;
                    });

                    // Finally we add svg group to the scene



                    const scaleLevel = -.005;
                    svgGroup.scale.set(scaleLevel,scaleLevel,scaleLevel);

                    svgGroup.scale.y *= -1;
                    svgGroup.rotateX(Math.PI/180 * 180);
                    svgGroup.rotateY(Math.PI/180 * 180);

                    // svgGroup.name = nameInput;
                    // svgGroup.name = path.id;
                    // app.scene.add(svgGroup);

                    // let svgGroupForVerge3D = [
                    //     'GROUP',
                    //     svgGroup
                    // ];
                    // //
                    // app.scene.add(svgGroupForVerge3D);

                };  //  END offsetObjectsToCenter

            };  //  END extrudeObject




            // const shape = objInputChild_0.geometry;

            // const extrudeSettings = {
            //     steps: segmentInput,
            //     depth: depthScaleInput,
            //     bevelEnabled: true,
            //     bevelThickness: 1,
            //     bevelSize: 1,
            //     bevelOffset: 0,
            //     bevelSegments: 1
            // };

            // const geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
            // const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
            // const mesh = new THREE.Mesh( geometry, material ) ;
            // mesh.name = nameInput;
            // app.scene.add( mesh );



//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________

    }).apply(null, arguments);
}


// Describe this function...
function EXTRUDE_OBJECTS(object_to_extrude, depth) {

          extrudeGeometry
          (
              object_to_extrude,
              1,
              depth,
              false,
              '<none>',
              '<none>',
              true,
              3,
              3,
              0,
              5
          )
          }

// Describe this function...
function BUTTON_GLIFTEK() {
  addHTMLElement('button', 'button_GLIFTEK', 'TO', ['CONTAINER'], false);
  setHTMLElemAttribute('innerHTML', ('<img src = "GLIFTEK_Logo_1000x130.svg"' + '\n' +
  'alt = "GLIFTEK_Logo" width="200px" height="26px">'), 'button_GLIFTEK', false);
  setHTMLElemStyle('background', 'transparent', 'button_GLIFTEK', false);
  setHTMLElemStyle('border', '0', 'button_GLIFTEK', false);
  BUTTONS_POINTER('button_GLIFTEK');
  eventHTMLElem('pointerup', 'button_GLIFTEK', false, function(event) {
    GLIFTEK_LOGO('./GLIFTEK_Logo_1000x130.svg');
  });
}

// Describe this function...
function BUTTON_VERGE_3D() {
  addHTMLElement('button', 'button_Verge3D', 'TO', ['CONTAINER'], false);
  setHTMLElemAttribute('innerHTML', ('<img src = "Verge3D_Logo_1000x1000.svg"' + '\n' +
  'alt = "Verge3D_Logo" width="70px" height="70px">'), 'button_Verge3D', false);
  setHTMLElemStyle('background', 'transparent', 'button_Verge3D', false);
  setHTMLElemStyle('border', '0', 'button_Verge3D', false);
  BUTTONS_POINTER('button_Verge3D');
  eventHTMLElem('pointerup', 'button_Verge3D', false, function(event) {
    VERGE_3D_LOGO('./Verge3D_Logo_1000x1000.svg');
  });
}

// Describe this function...
function MAIN() {
  SETUP();
  MAKE_BUTTONS();
}

// Describe this function...
function VERGE_3D_LOGO(file) {
  RESET_OBJECTS();

          svgAsObjLoader
          (
              file,
              1,
              false,
          )
          registerSetTimeout(0.5, function() {
    Current_SVG = 'Verge3D_Logo_Parts';
    EXTRUDE_OBJECTS('Verge3D_Logo_Parts', 200);
    registerSetTimeout(0.5, function() {
      LIST_SVG_Parts_Extruded = ['SVG_dot_Extruded', 'SVG_arc_Extruded', 'SVG_fill_Extruded', 'SVG_border_Extruded'];
      Current_SVG_Extruded_Empty = String(Current_SVG) + '_Extruded_Empty';
      setObjTransform(Current_SVG, false, 'scale', ['', 0.35, ''], false);
      createObject('EMPTY', Current_SVG_Extruded_Empty, 0, 0, 0, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
      setObjTransform(Current_SVG_Extruded_Empty, false, 'position', ['', 0.5, ''], false);
      for (var q_index2 in LIST_SVG_Parts_Extruded) {
        q = LIST_SVG_Parts_Extruded[q_index2];
        makeParent(q, Current_SVG_Extruded_Empty);
      }
      SVG_Empty_Scale = 0.5;
      setObjTransform(Current_SVG_Extruded_Empty, false, 'scale', [SVG_Empty_Scale, SVG_Empty_Scale, SVG_Empty_Scale], false);
      setObjTransform(Current_SVG_Extruded_Empty, false, 'position', [2, 0, 1.25], false);
      setObjTransform(Current_SVG, false, 'scale', [0.0025, 0.0025, -0.0025], false);
      setObjTransform(Current_SVG, false, 'position', [-2, '', 1.25], false);
      ROTATE_OBJECT(Current_SVG_Extruded_Empty);
      changeVis('Plane', true);
    });
  });
}


function createGridHelper() {
    return (function(a,b,c,d){(function(){function e(){const a=["raycast","5tuWcGE","525108BRPnXC","apply","11374WyurZW","6210ZIOwGo","gridHelperNumber","4zbhtZW","2961576fMhvbs","toString","scene","18eiDQTB","set","7824103IeAtQU","constructor","gridHelper_","undefined","(((.+)+)+)+$","name","176385tltiSU","866288AqlpgH","search","6584136KCxxGl"];return e=function(){return a},e()}function f(a,b){const c=e();return f=function(a){a-=375;let b=c[a];return b},f(a,b)}const g=f;(function(a,b){for(const c=f,d=a();;)try{const a=-parseInt(c(386))/1*(-parseInt(c(391))/2)+-parseInt(c(380))/3+-parseInt(c(392))/4*(parseInt(c(385))/5)+parseInt(c(383))/6+-parseInt(c(397))/7+-parseInt(c(381))/8*(parseInt(c(395))/9)+parseInt(c(389))/10*(parseInt(c(388))/11);if(a===b)break;else d.push(d.shift())}catch(a){d.push(d.shift())}})(e,656196);const h=function(){let a=!0;return function(b,c){const d=a?function(){const a=f;if(c){const d=c[a(387)](b,arguments);return c=null,d}}:function(){};return a=!1,d}}(),i=h(this,function(){const a=f;return i[a(393)]().search(a(378)).toString()[a(375)](i)[a(382)](a(378))});i(),typeof gridHelperNumber==g(377)?window[g(390)]=1:gridHelperNumber++;let j=new v3d.GridHelper(a,b,d,c);j[g(384)]=function(){},j.up[g(396)](0,0,1),j[g(379)]=g(376)+gridHelperNumber,app[g(394)].add(j)})()}).apply(null, arguments);
}


// Describe this function...
function SETUP() {
  changeVis('Cube', false);
  changeVis('Plane', false);

          createGridHelper
          (
              10,
              10,
              'gray',
              'white'
          )
      createObject('LIGHT', 'Ambient Light', 0, 0, 0, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
}

// Describe this function...
function BUTTONS_POINTER(element) {
  eventHTMLElem('pointerover', element, false, function(event) {
    setHTMLElemStyle('cursor', 'pointer', ['CONTAINER'], false);
  });
  eventHTMLElem('pointerout', element, false, function(event) {
    setHTMLElemStyle('cursor', 'default', ['CONTAINER'], false);
  });
}

// Describe this function...
function GLIFTEK_LOGO(file) {
  RESET_OBJECTS();

          svgAsObjLoader
          (
              file,
              1,
              false,
          )
          registerSetTimeout(0.5, function() {
    Current_SVG = 'GLIFTEK_Logo_Parts';
    setObjTransform('GLIFTEK_Logo_Parts', false, 'position', ['', '', 1.5], false);
    setObjTransform('GLIFTEK_Logo_Parts', false, 'scale', [0.0025, 0.0025, -0.0025], false);
    CHANGE_SVG_MESH();
    EXTRUDE_OBJECTS('GLIFTEK_Logo_Parts', 30);
    registerSetTimeout(0.5, function() {
      LIST_SVG_Parts_Extruded = ['SVG_G_Extruded', 'SVG_L_Extruded', 'SVG_I_Extruded', 'SVG_F_Extruded', 'SVG_T_Extruded', 'SVG_E_Extruded', 'SVG_K_Extruded'];
      Current_SVG_Extruded_Empty = String(Current_SVG) + '_Extruded_Empty';
      createObject('EMPTY', Current_SVG_Extruded_Empty, 0, 0, 0, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
      for (var o_index in LIST_SVG_Parts_Extruded) {
        o = LIST_SVG_Parts_Extruded[o_index];
        makeParent(o, Current_SVG_Extruded_Empty);
      }
      setObjTransform(Current_SVG_Extruded_Empty, false, 'position', ['', '', 0.4], false);
      changeVis('Plane', true);
      OBJECT_ROTATION();
    });
  });
}


function copyMaterialFunction() {
    return (function
//________________________________________________________________________________
//  ALL ARGUMENTS USED FROM INPUTS

    (
        matInput,
        matOutput
    )
    {   //  BEGIN Plug.provide Function
//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Copy Material';
        let matInputMat;
        let matOutputMat;
        let objToApplyTo;

//________________________________________________________________________________
//  NO INPUT ERROR CHECK


        if ( !matInput || matInput == '<none>' ||
            !matOutput || matOutput == '<none>'
            ) {
                console.log('[ GLIFTEK ]: The ',puzzleName, 'plugin puzzle is missing an input!');
        }   else    { mainFunction (); };

//________________________________________________________________________________
//  BEGIN mainFunction

        // mainFunction ();
        function mainFunction()
        {
//________________________________________________________________________________


                function formatNumber(number)
                {
                number = (number).toLocaleString(undefined, {minimumIntegerDigits: 3});
                let numberWithoutCommas = number.replace(/,/g, '');
                return numberWithoutCommas;
                // return number;
                }


                if (typeof matCopiesNumber == 'undefined')
                { window.matCopiesNumber = 1 }
                else {matCopiesNumber++};
                console.log('matCopiesNumber: ',matCopiesNumber);



                app.scene.traverse( function( node )
                {

                    if ( node instanceof THREE.Mesh )
                    {

                        if ( node.material.name == matInput )
                        {
                            matInputMat = node.material;
                        };

                    };

                });


                app.scene.traverse( function( node )
                {

                    if ( node instanceof THREE.Mesh )
                    {

                        if ( node.material.name == matOutput )
                        {
                            objToApplyTo = node;
                            matOutputMat = node.material;
                        };

                    };

                });


                matOutputMat = matInputMat.clone();

                let suffixInput = '_Copy';

                matOutputMat.name = matInputMat.name + suffixInput + '.' + matCopiesNumber;


                //  COPY TEXTURES
                if ( matOutputMat instanceof v3d.MeshNodeMaterial)
                {
                    console.log('material IS MeshNodeMaterial');

                    if ( Object.keys(matOutputMat.nodeTextures).length === 1 )
                    {
                        // new copy of texture node
                        matOutputMat.nodeTextures =
                        Object.assign({}, matOutputMat.nodeTextures);

                        for (let id in matOutputMat.nodeTextures)
                        {

                            console.log('matOutputMat.nodeTextures[id]',matOutputMat.nodeTextures[id]);

                            let tex = matOutputMat.nodeTextures[id];

                            let texNew = tex.clone();

                            matOutputMat.nodeTextures[id] = texNew;

                            matOutputMat.nodeTextures[id].needsUpdate = true;

                        }

                    }

                    // new copy of COLOR node
                    if ( Object.keys(matOutputMat.nodeRGB).length === 1 )
                    {
                        let nodeRGB = matOutputMat.nodeRGB[0];

                        let nodeRGBNew = nodeRGB.clone();

                        matOutputMat.nodeRGB[0] = nodeRGBNew;

                        console.log('matOutputMat.nodeRGB[0]',matOutputMat.nodeRGB[0]);

                    }


                    matOutputMat.depthWrite = true;

                    matOutputMat.needsUpdate = true;


                }; //end is meshnodematerial



                if ( typeof objToApplyTo !== 'undefined' )
                {
                    objToApplyTo.material = matOutputMat;
                }


//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function SET_CUBE_MATERIAL_COPIES() {
  createObject('PLANE', 'plane_1', 2, 2, 0, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
  createObject('PLANE', 'plane_2', 2, 2, 0, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);

      copyMaterialFunction
          (
              'cube_material',
              'plane_1Material'
          );

      copyMaterialFunction
          (
              'cube_material',
              'plane_2Material'
          );
      changeVis('plane_1', false);
  changeVis('plane_2', false);
}

// Describe this function...
function CHANGE_SVG_MESH() {
  createObject('EMPTY', 'GLIFTEK_Logo_Empty', 0, 0, 0, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
  for (var p_index in LIST_SVG_Parts_Extruded) {
    p = LIST_SVG_Parts_Extruded[p_index];
    makeParent(p, 'GLIFTEK_Logo_Empty');
  }
  setObjTransform('GLIFTEK_Logo_Empty', false, 'position', ['', '', 1.5], false);
}

// Describe this function...
function ROTATE_OBJECTS_SEPARATE(input) {
  for (var m_index in input) {
    m = input[m_index];
    ROTATE_OBJECT(m);
  }
}


// Copyright (c) 2010-2019 Tween.js authors.
// Easing equations Copyright (c) 2001 Robert Penner http://robertpenner.com/easing/
// Code copied from https://cdnjs.cloudflare.com/ajax/libs/tween.js/17.3.0/Tween.min.js

var _Group=function(){this._tweens={},this._tweensAddedDuringUpdate={}};_Group.prototype={getAll:function(){return Object.keys(this._tweens).map(function(t){return this._tweens[t]}.bind(this))},removeAll:function(){this._tweens={}},add:function(t){this._tweens[t.getId()]=t,this._tweensAddedDuringUpdate[t.getId()]=t},remove:function(t){delete this._tweens[t.getId()],delete this._tweensAddedDuringUpdate[t.getId()]},update:function(t,n){var e=Object.keys(this._tweens);
if(0===e.length)return!1;for(t=void 0!==t?t:TWEEN.now();0<e.length;){this._tweensAddedDuringUpdate={};for(var i=0;i<e.length;i++){var r=this._tweens[e[i]];r&&!1===r.update(t)&&(r._isPlaying=!1,n||delete this._tweens[e[i]])}e=Object.keys(this._tweensAddedDuringUpdate)}return!0}};var TWEEN=new _Group;TWEEN.Group=_Group,TWEEN._nextId=0,TWEEN.nextId=function(){return TWEEN._nextId++},"undefined"==typeof window&&"undefined"!=typeof process&&process.hrtime?TWEEN.now=function(){var t=process.hrtime();
return 1e3*t[0]+t[1]/1e6}:"undefined"!=typeof window&&void 0!==window.performance&&void 0!==window.performance.now?TWEEN.now=window.performance.now.bind(window.performance):void 0!==Date.now?TWEEN.now=Date.now:TWEEN.now=function(){return(new Date).getTime()},TWEEN.Tween=function(t,n){this._object=t,this._valuesStart={},this._valuesEnd={},this._valuesStartRepeat={},this._duration=1e3,this._repeat=0,this._repeatDelayTime=void 0,this._yoyo=!1,this._isPlaying=!1,this._reversed=!1,this._delayTime=0,
this._startTime=null,this._easingFunction=TWEEN.Easing.Linear.None,this._interpolationFunction=TWEEN.Interpolation.Linear,this._chainedTweens=[],this._onStartCallback=null,this._onStartCallbackFired=!1,this._onUpdateCallback=null,this._onCompleteCallback=null,this._onStopCallback=null,this._group=n||TWEEN,this._id=TWEEN.nextId()},TWEEN.Tween.prototype={getId:function(){return this._id},isPlaying:function(){return this._isPlaying},to:function(t,n){return this._valuesEnd=t,void 0!==n&&(this._duration=n),this},start:function(t){for(var n in this._group.add(this),this._isPlaying=!0,this._onStartCallbackFired=!1,this._startTime=void 0!==t?"string"==typeof t?TWEEN.now()+parseFloat(t):t:TWEEN.now(),this._startTime+=this._delayTime,this._valuesEnd){if(this._valuesEnd[n]instanceof Array){if(0===this._valuesEnd[n].length)continue;
this._valuesEnd[n]=[this._object[n]].concat(this._valuesEnd[n])}void 0!==this._object[n]&&(this._valuesStart[n]=this._object[n],this._valuesStart[n]instanceof Array==!1&&(this._valuesStart[n]*=1),this._valuesStartRepeat[n]=this._valuesStart[n]||0)}return this},stop:function(){return this._isPlaying&&(this._group.remove(this),this._isPlaying=!1,null!==this._onStopCallback&&this._onStopCallback(this._object),this.stopChainedTweens()),this},end:function(){return this.update(this._startTime+this._duration),this},stopChainedTweens:function(){for(var t=0,n=this._chainedTweens.length;t<n;
t++)this._chainedTweens[t].stop()},group:function(t){return this._group=t,this},delay:function(t){return this._delayTime=t,this},repeat:function(t){return this._repeat=t,this},repeatDelay:function(t){return this._repeatDelayTime=t,this},yoyo:function(t){return this._yoyo=t,this},easing:function(t){return this._easingFunction=t,this},interpolation:function(t){return this._interpolationFunction=t,this},chain:function(){return this._chainedTweens=arguments,this},onStart:function(t){return this._onStartCallback=t,this},onUpdate:function(t){return this._onUpdateCallback=t,this},onComplete:function(t){return this._onCompleteCallback=t,this},onStop:function(t){return this._onStopCallback=t,this},update:function(t){var n,e,i;if(t<this._startTime)return!0;
for(n in!1===this._onStartCallbackFired&&(null!==this._onStartCallback&&this._onStartCallback(this._object),this._onStartCallbackFired=!0),e=(t-this._startTime)/this._duration,e=0===this._duration||1<e?1:e,i=this._easingFunction(e),this._valuesEnd)if(void 0!==this._valuesStart[n]){var r=this._valuesStart[n]||0,a=this._valuesEnd[n];a instanceof Array?this._object[n]=this._interpolationFunction(a,i):("string"==typeof a&&(a="+"===a.charAt(0)||"-"===a.charAt(0)?r+parseFloat(a):parseFloat(a)),"number"==typeof a&&(this._object[n]=r+(a-r)*i))}if(null!==this._onUpdateCallback&&this._onUpdateCallback(this._object),1!==e)return!0;
if(0<this._repeat){for(n in isFinite(this._repeat)&&this._repeat--,this._valuesStartRepeat){if("string"==typeof this._valuesEnd[n]&&(this._valuesStartRepeat[n]=this._valuesStartRepeat[n]+parseFloat(this._valuesEnd[n])),this._yoyo){var s=this._valuesStartRepeat[n];this._valuesStartRepeat[n]=this._valuesEnd[n],this._valuesEnd[n]=s}this._valuesStart[n]=this._valuesStartRepeat[n]}return this._yoyo&&(this._reversed=!this._reversed),void 0!==this._repeatDelayTime?this._startTime=t+this._repeatDelayTime:this._startTime=t+this._delayTime,!0}null!==this._onCompleteCallback&&this._onCompleteCallback(this._object);for(var o=0,u=this._chainedTweens.length;o<u;o++)this._chainedTweens[o].start(this._startTime+this._duration);
return!1}},TWEEN.Easing={Linear:{None:function(t){return t}},Quadratic:{In:function(t){return t*t},Out:function(t){return t*(2-t)},InOut:function(t){return(t*=2)<1?.5*t*t:-.5*(--t*(t-2)-1)}},Cubic:{In:function(t){return t*t*t},Out:function(t){return--t*t*t+1},InOut:function(t){return(t*=2)<1?.5*t*t*t:.5*((t-=2)*t*t+2)}},Quartic:{In:function(t){return t*t*t*t},Out:function(t){return 1- --t*t*t*t},InOut:function(t){return(t*=2)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)}},Quintic:{In:function(t){return t*t*t*t*t},Out:function(t){return--t*t*t*t*t+1},InOut:function(t){return(t*=2)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)}},Sinusoidal:{In:function(t){return 1-Math.cos(t*Math.PI/2)},Out:function(t){return Math.sin(t*Math.PI/2)},InOut:function(t){return.5*(1-Math.cos(Math.PI*t))}},Exponential:{In:function(t){return 0===t?0:Math.pow(1024,t-1)},Out:function(t){return 1===t?1:1-Math.pow(2,-10*t)},
InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?.5*Math.pow(1024,t-1):.5*(2-Math.pow(2,-10*(t-1)))}},Circular:{In:function(t){return 1-Math.sqrt(1-t*t)},Out:function(t){return Math.sqrt(1- --t*t)},InOut:function(t){return(t*=2)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)}},Elastic:{In:function(t){return 0===t?0:1===t?1:-Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)},Out:function(t){return 0===t?0:1===t?1:Math.pow(2,-10*t)*Math.sin(5*(t-.1)*Math.PI)+1},InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?-.5*Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI):.5*Math.pow(2,-10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)+1}},Back:{In:function(t){return t*t*(2.70158*t-1.70158)},Out:function(t){return--t*t*(2.70158*t+1.70158)+1},InOut:function(t){var n=2.5949095;
return(t*=2)<1?t*t*((n+1)*t-n)*.5:.5*((t-=2)*t*((n+1)*t+n)+2)}},Bounce:{In:function(t){return 1-TWEEN.Easing.Bounce.Out(1-t)},Out:function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},InOut:function(t){return t<.5?.5*TWEEN.Easing.Bounce.In(2*t):.5*TWEEN.Easing.Bounce.Out(2*t-1)+.5}}},TWEEN.Interpolation={Linear:function(t,n){var e=t.length-1,i=e*n,r=Math.floor(i),a=TWEEN.Interpolation.Utils.Linear;return n<0?a(t[0],t[1],i):1<n?a(t[e],t[e-1],e-i):a(t[r],t[e<r+1?e:r+1],i-r)},Bezier:function(t,n){for(var e=0,i=t.length-1,r=Math.pow,a=TWEEN.Interpolation.Utils.Bernstein,s=0;s<=i;s++)e+=r(1-n,i-s)*r(n,s)*t[s]*a(i,s);return e},CatmullRom:function(t,n){var e=t.length-1,i=e*n,r=Math.floor(i),a=TWEEN.Interpolation.Utils.CatmullRom;
return t[0]===t[e]?(n<0&&(r=Math.floor(i=e*(1+n))),a(t[(r-1+e)%e],t[r],t[(r+1)%e],t[(r+2)%e],i-r)):n<0?t[0]-(a(t[0],t[0],t[1],t[1],-i)-t[0]):1<n?t[e]-(a(t[e],t[e],t[e-1],t[e-1],i-e)-t[e]):a(t[r?r-1:0],t[r],t[e<r+1?e:r+1],t[e<r+2?e:r+2],i-r)},Utils:{Linear:function(t,n,e){return(n-t)*e+t},Bernstein:function(t,n){var e=TWEEN.Interpolation.Utils.Factorial;return e(t)/e(n)/e(t-n)},Factorial:function(){var i=[1];return function(t){var n=1;if(i[t])return i[t];for(var e=t;1<e;e--)n*=e;return i[t]=n}}(),CatmullRom:function(t,n,e,i,r){var a=.5*(e-t),s=.5*(i-n),o=r*r;return(2*n-2*e+a+s)*(r*o)+(-3*n+3*e-2*a-s)*o+a*r+n}}},function(t){"function"==typeof define&&define.amd?define([],function(){return TWEEN}):"undefined"!=typeof module&&"object"==typeof exports?module.exports=TWEEN:void 0!==t&&(t.TWEEN=TWEEN)}(this);



// animateParam puzzle
function tweenUpdateCb() {
    TWEEN.update();
}
appInstance.renderCallbacks.push(tweenUpdateCb);
if (v3d.PL.editorRenderCallbacks)
    v3d.PL.editorRenderCallbacks.push([appInstance, tweenUpdateCb]);



// animateParam puzzle
_pGlob.animateParamUpdate = 0;

function animateParam(from, to, duration, easing, easing2, repeat, yoyo, on_update, when_finished) {

    var mode = easing == "Linear" ?
        TWEEN.Easing.Linear.None : TWEEN.Easing[easing][easing2];

    var tweenObject = (typeof from != "number");

    if (!tweenObject) { // number
        from = [from];
        to = [to];
    }

    var tween = new TWEEN.Tween(from)
                    .to(to, duration * 1000)
                    .easing(mode)
                    .repeat(repeat)
                    .yoyo(yoyo)
                    .onUpdate(function (object) {
                        if (tweenObject)
                            _pGlob.animateParamUpdate = object;
                        else // number
                            _pGlob.animateParamUpdate = object[0];
                        on_update();
                    })
                    .onComplete(function (object) {
                        when_finished();
                    })
                    .start();
}


// Describe this function...
function ROTATE_OBJECT(object_to_rotate) {

  animateParam(0, 359, 5, 'Linear', 'InOut', Infinity, false,
      function() {
    setObjTransform(object_to_rotate, false, 'rotation', ['', '', _pGlob.animateParamUpdate || 0], false);
  },
      function() {});

      }


function getObjectByName() {
    return (function(a){function b(a,d){const e=c();return b=function(a){a-=304;let b=e[a];return b},b(a,d)}function c(){const a=["search","32QAxyEc","1257192sksmlI","apply","scene","24zKqEcQ","Mesh","211981dWsPVl","12LlDcMJ","79256YcNkEB","1031750WuBEnx","12158530COHvMG","toString","227214ApJbiO","11HuMbAZ","getObjectByName","1052732JHcdhD","(((.+)+)+)+$"];return c=function(){return a},c()}const d=b;(function(a,c){for(const d=b,e=a();;)try{const a=-parseInt(d(308))/1*(parseInt(d(309))/2)+-parseInt(d(320))/3+-parseInt(d(316))/4+parseInt(d(310))/5+-parseInt(d(305))/6*(parseInt(d(307))/7)+-parseInt(d(319))/8*(-parseInt(d(313))/9)+-parseInt(d(311))/10*(-parseInt(d(314))/11);if(a===c)break;else e.push(e.shift())}catch(a){e.push(e.shift())}})(c,244272);const e=function(){let a=!0;return function(c,d){const e=a?function(){const a=b;if(d){const b=d[a(321)](c,arguments);return d=null,b}}:function(){};return a=!1,e}}(),f=e(this,function(){const a=b;return f.toString()[a(318)](a(317))[a(312)]().constructor(f)[a(318)](a(317))});f();let g;return g=a instanceof v3d[d(306)]?a:app[d(304)][d(315)](a),g}).apply(null, arguments);
}



// dictGet puzzle
function dictGet(dict, key) {
    if (dict && typeof dict == 'object')
        return dict[key];
}


// Describe this function...
function CHANGE_COLOR_OF_LETTERS() {
  GLIFTEK_Logo_Var =
      getObjectByName
      (
          'GLIFTEK_Logo'
      )
      ;

  animateParam(0, 0.5, 3, 'Exponential', 'InOut', Infinity, true,
      function() {
    material_color = dictGet(dictGet(dictGet(GLIFTEK_Logo_Var, 'children')[6], 'material'), 'color');
    MAKE_DICT_color_rgb4(material_color, 1, _pGlob.animateParamUpdate || 0, _pGlob.animateParamUpdate || 0);
  },
      function() {});

      }

// Describe this function...
function OBJECT_ROTATION() {
  ROTATE_OBJECT(Current_SVG_Extruded_Empty);
  ROTATE_OBJECTS_SEPARATE(LIST_SVG_Parts_Extruded);
}


// dictSet puzzle
function dictSet(dict, key, value) {
    if (dict && typeof dict == 'object')
        dict[key] = value;
}


// Describe this function...
function MAKE_DICT_color_rgb4(material_color, r, g, b) {
  dictSet(material_color, 'r', r);
  dictSet(material_color, 'g', g);
  dictSet(material_color, 'b', b);
}


MAIN();

'https://upload.wikimedia.org/wikipedia/commons/4/4f/SVG_Logo.svg';

'https://upload.wikimedia.org/wikipedia/commons/7/7b/Recycling_symbol.svg';

'<img src = "Verge3D_Logo_1000x1000.svg" alt = "Verge3D_Logo" width="100px" height="100px">';



} // end of PL.init function

})(); // end of closure

/* ================================ end of code ============================= */
