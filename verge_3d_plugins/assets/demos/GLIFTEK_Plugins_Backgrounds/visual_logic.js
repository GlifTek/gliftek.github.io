/**
 * Generated by Verge3D Puzzles v.3.8.0
 * Fri Oct 01 2021 22:19:00 GMT-0400 (Eastern Daylight Time)
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */

'use strict';

(function() {

// global variables/constants used by puzzles' functions

var LIST_NONE = '<none>';

var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster();

var PL = v3d.PL = v3d.PL || {};

// a more readable alias for PL (stands for "Puzzle Logic")
v3d.puzzles = PL;

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        }
    }

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    var PROC = {
    
};

// initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = true;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = false;
_initGlob.output.initOptions.useFullscreen = false;

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["MAIN"] = MAIN;
this.procedures["GRADIENT_BACKGROUND_CENTER"] = GRADIENT_BACKGROUND_CENTER;
this.procedures["CLICK_CUBE"] = CLICK_CUBE;
this.procedures["GRADIENT_BACKGROUND_TEAL"] = GRADIENT_BACKGROUND_TEAL;
this.procedures["FADE_FROM_BLACK"] = FADE_FROM_BLACK;
this.procedures["FADE_IN_OUT"] = FADE_IN_OUT;
this.procedures["SCREEN_VIGNETTE"] = SCREEN_VIGNETTE;

var PROC = {
    "MAIN": MAIN,
    "GRADIENT_BACKGROUND_CENTER": GRADIENT_BACKGROUND_CENTER,
    "CLICK_CUBE": CLICK_CUBE,
    "GRADIENT_BACKGROUND_TEAL": GRADIENT_BACKGROUND_TEAL,
    "FADE_FROM_BLACK": FADE_FROM_BLACK,
    "FADE_IN_OUT": FADE_IN_OUT,
    "SCREEN_VIGNETTE": SCREEN_VIGNETTE,
};

var screen_fade_color_2, cubeClicked, offset_var;

// Describe this function...
function MAIN() {
  FADE_FROM_BLACK();
  cubeClicked = 0;
  GRADIENT_BACKGROUND_TEAL();
}


function generateGradientBackground() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        typeDropdown,
        color2Checkbox,
        colorInput_1_PICKER,
        colorInput_2_PICKER,
        colorInput_3_PICKER,
        colorInput_1_TEXT,
        colorInput_2_TEXT,
        colorInput_3_TEXT,
        colorInput_1_OFFSET,
        colorInput_2_OFFSET,
        colorInput_3_OFFSET,
    )
    {   //  BEGIN Plug.provide Function

//________________________________________________________________________________
//  MAIN FUNCTION

        mainFunction();
        function mainFunction()
        {

//________________________________________________________________________________
//  PUZZLE CORE CODE

        function setColorFromInputs(colorInput_TEXT, colorInput_PICKER)
        {
            let colorInput_esc;

            if ( typeof colorInput_TEXT == 'undefined' || typeof colorInput_TEXT == null || colorInput_TEXT == '' )
            {
                colorInput_esc = colorInput_PICKER.substring(1);
                // console.log(colorInput_PICKER,'supplied. using PICKER.');
            }
            else
            {
                colorInput_esc = colorInput_TEXT.substring(1);
                // console.log(colorInput_TEXT,'supplied. using TEXT.');
            }

            return colorInput_esc
        };

        const colorInput_1esc = setColorFromInputs(colorInput_1_TEXT, colorInput_1_PICKER);
        const colorInput_3esc = setColorFromInputs(colorInput_3_TEXT, colorInput_3_PICKER);

        let gradientToLoad;
        let colorInput_2esc;

        let colorInput_2_option;

        const svgHeader =
        `
        data:image/svg+xml,%3Csvg id='bg_gradient' data-name='bg_gradient' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='640' height='640' viewBox='0 0 640 640'%3E
        `;

        const svgRect = `%3Crect x='0' y='0' width='640' height='640' `;

        if (color2Checkbox == true)
        {
            colorInput_2esc = setColorFromInputs(colorInput_2_TEXT, colorInput_2_PICKER);

            colorInput_2_option =
            `
            %3Cstop offset='${colorInput_2_OFFSET}' stop-color='%23${colorInput_2esc}'/%3E
            `;
        }
        else if (color2Checkbox == false)
        {
            colorInput_2_option = '';
        }

        if (typeDropdown == 'gradientLinear')
        {
            gradientToLoad =
            `
            ${svgHeader}%3Cdefs%3E%3ClinearGradient id='linear-gradient' x1='320' y1='0' x2='320' y2='640' gradientUnits='userSpaceOnUse'%3E%3Cstop offset='${colorInput_1_OFFSET}' stop-color='%23${colorInput_1esc}'/%3E${colorInput_2_option}%3Cstop offset='${colorInput_3_OFFSET}' stop-color='%23${colorInput_3esc}'/%3E%3C/linearGradient%3E%3C/defs%3E${svgRect}fill='url(%23linear-gradient)'/%3E%3Cpath d='M639,1V639H1V1H639m1-1H0V640H640V0Z'/%3E%3C/svg%3E
            `;

        }
        else if (typeDropdown == 'gradientRadial')
        {
            gradientToLoad =
            `
            ${svgHeader}%3Cdefs%3E%3CradialGradient id='radial-gradient' cx='320' cy='320' r='320' gradientUnits='userSpaceOnUse'%3E%3Cstop offset='${colorInput_1_OFFSET}' stop-color='%23${colorInput_1esc}' /%3E${colorInput_2_option}%3Cstop offset='${colorInput_3_OFFSET}' stop-color='%23${colorInput_3esc}' /%3E%3C/radialGradient%3E%3C/defs%3E${svgRect}fill='url(%23radial-gradient)' /%3E%3Cpath d='M639,1V639H1V1H639m1-1H0V640H640V0Z' /%3E%3C/svg%3E
            `;

        };

        // console.log('gradientToLoad: ',gradientToLoad);

        let bgTexture = new THREE.TextureLoader()
        .load(gradientToLoad);

        bgTexture.minFilter = THREE.LinearFilter;

        app.scene.background = bgTexture;

        app.scene.background.encoding = THREE.sRGBEncoding;


        // TODO make animatable...
        // bgTexture.needsUpdate = true;
        // animate()
        // {
        //     requestAnimationFrame(animate);
        // }


//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function GRADIENT_BACKGROUND_CENTER() {

          generateGradientBackground
          (
              'gradientRadial',
              false,
              '#ffff99',
              '#b87132',
              '#cc6600',
              '',
              '',
              '',
              0.5,
              0.6,
              1,

          )
      }



// utility function envoked by almost all V3D-specific puzzles
// filter off some non-mesh types
function notIgnoredObj(obj) {
    return obj.type !== 'AmbientLight' &&
           obj.name !== '' &&
           !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
           !obj.isAuxClippingMesh;
}


// utility function envoked by almost all V3D-specific puzzles
// find first occurence of the object by its name
function getObjectByName(objName) {
    var objFound;
    var runTime = _pGlob !== undefined;
    objFound = runTime ? _pGlob.objCache[objName] : null;

    if (objFound && objFound.name === objName)
        return objFound;

    appInstance.scene.traverse(function(obj) {
        if (!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
            objFound = obj;
            if (runTime) {
                _pGlob.objCache[objName] = objFound;
            }
        }
    });
    return objFound;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects on the scene
function getAllObjectNames() {
    var objNameList = [];
    appInstance.scene.traverse(function(obj) {
        if (notIgnoredObj(obj))
            objNameList.push(obj.name)
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects which belong to the group
function getObjectNamesByGroupName(targetGroupName) {
    var objNameList = [];
    appInstance.scene.traverse(function(obj){
        if (notIgnoredObj(obj)) {
            var groupNames = obj.groupNames;
            if (!groupNames)
                return;
            for (var i = 0; i < groupNames.length; i++) {
                var groupName = groupNames[i];
                if (groupName == targetGroupName) {
                    objNameList.push(obj.name);
                }
            }
        }
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// process object input, which can be either single obj or array of objects, or a group
function retrieveObjectNames(objNames) {
    var acc = [];
    retrieveObjectNamesAcc(objNames, acc);
    return acc.filter(function(name) {
        return name;
    });
}

function retrieveObjectNamesAcc(currObjNames, acc) {
    if (typeof currObjNames == "string") {
        acc.push(currObjNames);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
        var newObj = getObjectNamesByGroupName(currObjNames[1]);
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "ALL_OBJECTS") {
        var newObj = getAllObjectNames();
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames)) {
        for (var i = 0; i < currObjNames.length; i++)
            retrieveObjectNamesAcc(currObjNames[i], acc);
    }
}




// utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
function initObjectPicking(callback, eventType, mouseDownUseTouchStart, mouseButtons) {

    var elem = appInstance.renderer.domElement;
    elem.addEventListener(eventType, pickListener);
    if (v3d.PL.editorEventListeners)
        v3d.PL.editorEventListeners.push([elem, eventType, pickListener]);

    if (eventType == 'mousedown') {

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        elem.addEventListener(touchEventName, pickListener);
        if (v3d.PL.editorEventListeners)
            v3d.PL.editorEventListeners.push([elem, touchEventName, pickListener]);

    } else if (eventType == 'dblclick') {

        var prevTapTime = 0;

        function doubleTapCallback(event) {

            var now = new Date().getTime();
            var timesince = now - prevTapTime;

            if (timesince < 600 && timesince > 0) {

                pickListener(event);
                prevTapTime = 0;
                return;

            }

            prevTapTime = new Date().getTime();
        }

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        elem.addEventListener(touchEventName, doubleTapCallback);
        if (v3d.PL.editorEventListeners)
            v3d.PL.editorEventListeners.push([elem, touchEventName, doubleTapCallback]);
    }

    var raycaster = new v3d.Raycaster();

    function pickListener(event) {

        // to handle unload in loadScene puzzle
        if (!appInstance.getCamera())
            return;

        event.preventDefault();

        var xNorm = 0, yNorm = 0;
        if (event instanceof MouseEvent) {
            if (mouseButtons && mouseButtons.indexOf(event.button) == -1)
                return;
            xNorm = event.offsetX / elem.clientWidth;
            yNorm = event.offsetY / elem.clientHeight;
        } else if (event instanceof TouchEvent) {
            var rect = elem.getBoundingClientRect();
            xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
            yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
        }

        _pGlob.screenCoords.x = xNorm * 2 - 1;
        _pGlob.screenCoords.y = -yNorm * 2 + 1;
        raycaster.setFromCamera(_pGlob.screenCoords, appInstance.getCamera(true));
        var objList = [];
        appInstance.scene.traverse(function(obj){objList.push(obj);});
        var intersects = raycaster.intersectObjects(objList);
        callback(intersects, event);
    }
}

function objectsIncludeObj(objNames, testedObjName) {
    if (!testedObjName) return false;

    for (var i = 0; i < objNames.length; i++) {
        if (testedObjName == objNames[i]) {
            return true;
        } else {
            // also check children which are auto-generated for multi-material objects
            var obj = getObjectByName(objNames[i]);
            if (obj && obj.type == "Group") {
                for (var j = 0; j < obj.children.length; j++) {
                    if (testedObjName == obj.children[j].name) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

// utility function used by the whenClicked, whenHovered, whenDraggedOver, and raycast puzzles
function getPickedObjectName(obj) {
    // auto-generated from a multi-material object, use parent name instead
    if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
        return obj.parent.name;
    } else {
        return obj.name;
    }
}



// whenClicked puzzle
function registerOnClick(objSelector, xRay, doubleClick, mouseButtons, cbDo, cbIfMissedDo) {

    // for AR/VR
    _pGlob.objClickInfo = _pGlob.objClickInfo || [];

    _pGlob.objClickInfo.push({
        objSelector: objSelector,
        callbacks: [cbDo, cbIfMissedDo]
    });

    initObjectPicking(function(intersects, event) {

        var isPicked = false;

        var maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);
            var objNames = retrieveObjectNames(objSelector);

            if (objectsIncludeObj(objNames, objName)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = objName;
                isPicked = true;
                cbDo(event);
            }
        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo(event);
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}


// Describe this function...
function CLICK_CUBE() {
  registerOnClick('Cube', false, false, [0,1,2], function() {
    FADE_IN_OUT();
  }, function() {});
}

// Describe this function...
function GRADIENT_BACKGROUND_TEAL() {

          generateGradientBackground
          (
              'gradientLinear',
              false,
              '#000000',
              '#b87132',
              '#33ffff',
              'TEAL',
              '',
              '',
              0.5,
              0.2,
              1,

          )
      }


function screenFade() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        screenFade_ID_Input,
        screenFade_Z_Index_Input,
        typeDropdown,
        screenFade_Pause_Input,
        screenFade_Duration_Input,
        colorInput_1_PICKER,
        colorInput_1_TEXT,
        delete_When_Done_Checkbox,
        whenDone_Statement_Input,
    )
    {   //  BEGIN Plug.provide Function


//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Print To Modal Card';

        eval(`window.${screenFade_ID_Input} = { faded: null };`);

//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !screenFade_ID_Input ) {
            console.log('[ GLIFTEK ]: The',puzzleName, 'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

        // mainFunction();
        function mainFunction()
        {

//________________________________________________________________________________
//  PUZZLE CORE CODE


            function setColorFromInputs(colorInput_TEXT, colorInput_PICKER)
            {
                let colorInput_esc;

                if ( typeof colorInput_TEXT == 'undefined' || typeof colorInput_TEXT == null || colorInput_TEXT == '' )
                {
                    // colorInput_esc = colorInput_PICKER.substring(1);
                    colorInput_esc = colorInput_PICKER;
                    console.log(colorInput_PICKER,'supplied. using PICKER.');
                }
                else
                {
                    // colorInput_esc = colorInput_TEXT.substring(1);
                    colorInput_esc = colorInput_TEXT;
                    console.log(colorInput_TEXT,'supplied. using TEXT.');
                }

                return colorInput_esc
            };

            const colorInput_1esc = setColorFromInputs(colorInput_1_TEXT, colorInput_1_PICKER);

            console.log('colorInput_1esc:',colorInput_1esc);




            let computedColorDiv = document.createElement("div");
            computedColorDiv.id = 'computedColorDiv-' + screenFade_ID_Input;
            document.body.appendChild(computedColorDiv);



            function RGBA_from_color_input(color,alpha)
            {
                if
                (
                        color == 'transparent'
                    ||  color == null
                    ||  typeof color == 'undefined'
                )
                {
                    return 'rgba(0, 0, 0, 0)';
                }
                else
                {
                    computedColorDiv.style.color = color;
                    let computedColor = window.getComputedStyle(computedColorDiv).color;

                    console.log('computedColor for: ',color,':',computedColor);

                    let len = computedColor.length;
                    let computedColor_RGBA =
                    'rgba(' + computedColor.substring(4, len-1) + ", " + alpha +')';

                    console.log('computedColor_RGBA for: ',color,':',computedColor_RGBA);

                    return computedColor_RGBA;
                };
            };


            const screenFadeColor = RGBA_from_color_input ( colorInput_1esc, 1 );
            console.log('screenFadeColor: ',screenFadeColor);

            computedColorDiv.remove();


//________________________________________________________________________________
//  SET CSS


            let styleVar = setstyleVar();  //  sets all modal styles

            let style = document.createElement('style');

            style.id = 'screenFade-' + screenFade_ID_Input;

            style.innerHTML = styleVar;

            document.head.appendChild(style);



//________________________________________________________________________________
//  MAKE SCREEN FADE DIV


            let screenFade_Div = document.createElement('div');

            screenFade_Div.id = screenFade_ID_Input;

            screenFade_Div.className = 'screenFade-' + screenFade_ID_Input;



            getBGcolor();

            function getBGcolor()
            {
                if ( typeDropdown  == 'in' )
                    {
                        screenFade_Div.style.backgroundColor = 'rgba(0,0,0,0)';
                        console.log('screenFade_Div.style.backgroundColor:',screenFade_Div.style.backgroundColor);
                    }
                    else if ( typeDropdown  == 'out' )
                    {
                        screenFade_Div.style.backgroundColor = screenFadeColor;
                        console.log('screenFade_Div.style.backgroundColor:',screenFade_Div.style.backgroundColor);
                    }

            }



            const container = document.getElementById('v3d-container');

            container.appendChild(screenFade_Div);



//________________________________________________________________________________
//  SCREEN FADE ANIMATION

            setTimeout(function(){ animateScreenFade(); }, ( screenFade_Pause_Input * 1000 ) );


            function animateScreenFade()
            {
                const animationType = 'animation-screen-fade-' + typeDropdown + '-' + screenFade_ID_Input;

                screenFade_Div.style.animationName = animationType;

                console.log('screenFade_Div.style.animationName:',screenFade_Div.style.animationName);

                screenFade_Div.addEventListener('animationend', function(event)

                {
                    if ( event.animationName == animationType );
                    {
                        screenFade_Div.removeEventListener('animationend',null);

                        screenFadeDisplay();

                        let screenFadeState = eval(`${screenFade_ID_Input}.faded = '${typeDropdown}';`);
                        console.log('screenFadeState:',screenFadeState);

                        whenDone_Statement_Input();
                    }
                });


                function screenFadeDisplay()
                {
                    if ( typeDropdown  == 'in' )
                    {
                        screenFade_Div.style.display = 'block';
                        console.log('screenFade_Div.style.display:',screenFade_Div.style.display);
                        deleteWhenDone();
                    }
                    else if ( typeDropdown  == 'out' )
                    {
                        screenFade_Div.style.display = 'none';
                        console.log('screenFade_Div.style.display:',screenFade_Div.style.display);
                        deleteWhenDone();
                    }

                }

                function deleteWhenDone()
                {
                    if ( delete_When_Done_Checkbox == true )
                    {
                        screenFade_Div.remove();
                    }
                }

            };

//________________________________________________________________________________
//  SCREEN FADE DIV CSS

            function setstyleVar()
            {
                let result =
                `
                #computedColorDiv-${screenFade_ID_Input}
                {
                    height: 0px;
                    width: 0px;
                    display: none;
                    z-index = -10;
                }

                .screenFade-${screenFade_ID_Input}
                {
                    display: block;
                    position: fixed;
                    z-index: ${screenFade_Z_Index_Input};
                    left: 0;
                    top: 0;
                    height: 100%;
                    width: 100%;
                    overflow: hidden;
                    pointer-events: none;

                    animation-duration: ${screenFade_Duration_Input}s;
                    animation-timing-function: ease-in-out;
                }


                @keyframes animation-screen-fade-in-${screenFade_ID_Input}
                {
                    from {
                        background-color: rgba(0,0,0,0);
                    }
                    to {
                        background-color: ${screenFadeColor};
                    }
                }


                @keyframes animation-screen-fade-out-${screenFade_ID_Input}
                {
                    from {
                        background-color: ${screenFadeColor};
                    }
                    to {
                        background-color: rgba(0,0,0,0);
                    }
                }

                `;

                return result;
            };

//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function FADE_FROM_BLACK() {
  screen_fade_color_2 = '#31626b';
  /* fade FROM black */

          screenFade
          (
              'screenFade_1',
              20,
              'out',
              2,
              1,
              '#000000',
              '',
              true,
              function() {  CLICK_CUBE();
  },
          )
      offset_var = 0;
}


function setImageBackground() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        // sundiskCheckbox,
        imageURLInput,
    )
    {   //  BEGIN Plug.provide Function


//________________________________________________________________________________
//  MAIN FUNCTION

        mainFunction();
        function mainFunction()
        {

//________________________________________________________________________________
//  PUZZLE CORE CODE

            let bgTexture = new THREE.TextureLoader()
            .load(imageURLInput);

            bgTexture.minFilter = THREE.LinearFilter;

            app.scene.background = bgTexture;

            app.scene.background.encoding = THREE.sRGBEncoding;

//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}



// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}



// removeHTMLElement puzzle
function removeHTMLElement(id, isParent) {

    var elem = getElement(id, isParent);
    // COMPAT: compatible with IE11
    if (elem && elem.parentNode)
        elem.parentNode.removeChild(elem);

}



// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}


// Describe this function...
function FADE_IN_OUT() {
  if (cubeClicked == 0) {
    /* fade TO teal */

            screenFade
            (
                'screenFade_2',
                20,
                'in',
                0,
                0.5,
                '#cc0000',
                'black',
                true,
                function() {  SCREEN_VIGNETTE();

              setImageBackground
              (
                  './bg_clouds_godrays_01.jpg',
              )
          /* TIMER OVERLAPS FADE PAUSE */
      registerSetTimeout(0.25, function() {
        removeHTMLElement('screenFade_2', false);
      });

              screenFade
              (
                  'screenFade_3',
                  5,
                  'out',
                  0.5,
                  0.5,
                  '#cc0000',
                  'black',
                  true,
                  function() {  cubeClicked = 1;
        CLICK_CUBE();
      },
              )
          },
            )
        } else if (cubeClicked == 1) {

            screenFade
            (
                'screenFade_4',
                20,
                'in',
                0,
                0.5,
                '#cc0000',
                'black',
                true,
                function() {  GRADIENT_BACKGROUND_CENTER();
      /* TIMER OVERLAPS FADE PAUSE */
      registerSetTimeout(0.25, function() {
        removeHTMLElement('screenFade_4', false);
      });

              screenFade
              (
                  'screenFade_5',
                  5,
                  'out',
                  0.5,
                  0.5,
                  '#cc0000',
                  'black',
                  true,
                  function() {  cubeClicked = 2;
        CLICK_CUBE();
      },
              )
          },
            )
        }
}


function screenVignette() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        screenVignette_ID_Input,
        screenVignette_Z_Index_Input,
        screenVignette_Radius_Input,
        colorInput_1_OFFSET,
        screenVignette_Opacity_CENTER,
        colorInput_2_OFFSET,
        screenVignette_Opacity_MID,
        colorInput_3_OFFSET,
        screenVignette_Opacity_OUTER
    )
    {   //  BEGIN Plug.provide Function

//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Screen Vignette';

//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !screenVignette_ID_Input ) {
            console.log('[ GLIFTEK ]: The',puzzleName, 'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  MAIN FUNCTION

        // mainFunction();
        function mainFunction()
        {

//________________________________________________________________________________
//  MAKE VIGNETTE SVG

            const colorInput_1esc = '000000';
            const colorInput_2esc = '000000';
            const colorInput_3esc = '000000';

            let SVGWidthHeight, viewBoxWidthHeight, rectWidthHeight = '100%';
            let gradientCenterXY = '50%';

            const radius = screenVignette_Radius_Input;

            // const preserveAspectRatio =
            // `preserveAspectRatio='none' x='0' y='0'`;

            const preserveAspectRatio =
            `preserveAspectRatio='xMidYMin meet' x='0' y='0'`;

            const svgHeader =
            `data:image/svg+xml,%3Csvg id='screenVignette_graident_SVG' data-name='screenVignette_graident_SVG' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' ${preserveAspectRatio} viewBox='0 0 ${viewBoxWidthHeight} ${viewBoxWidthHeight}' width='${SVGWidthHeight}' height='${SVGWidthHeight}'  %3E`;

            const svgRect = `%3Crect x='0' y='0' width='${rectWidthHeight}' height='${rectWidthHeight}' `;

            let screenVignette_SVG =
            `${svgHeader}%3Cdefs%3E%3CradialGradient id='screenVignette_graident' cx='${gradientCenterXY}' cy='${gradientCenterXY}' r='${radius}' gradientUnits='userSpaceOnUse'%3E%3Cstop offset='${colorInput_1_OFFSET}' stop-color='%23${colorInput_1esc}' stop-opacity='${screenVignette_Opacity_CENTER}' /%3E%3Cstop offset='${colorInput_2_OFFSET}' stop-color='%23${colorInput_2esc}' stop-opacity='${screenVignette_Opacity_MID}' /%3E%3Cstop offset='${colorInput_3_OFFSET}' stop-color='%23${colorInput_3esc}' stop-opacity='${screenVignette_Opacity_OUTER}' /%3E%3C/radialGradient%3E%3C/defs%3E${svgRect} fill='url(%23screenVignette_graident)' /%3E%3C/svg%3E`;

            // console.log('screenVignette_SVG: ',screenVignette_SVG);

//________________________________________________________________________________
//  MAKE SCREEN VIGNETTE DIV


            let screenVignette_Div = document.createElement('div');

            screenVignette_Div.id = screenVignette_ID_Input;

            screenVignette_Div.className = 'screenVignette-Div-' + screenVignette_ID_Input;


            let screenVignette_Image = document.createElement('img');

            screenVignette_Image.id = 'screenVignette_Image-' + screenVignette_ID_Input;

            screenVignette_Image.className = 'screenVignette_Image-' + screenVignette_ID_Input;

            screenVignette_Image.src = screenVignette_SVG;

            screenVignette_Image.crossOrigin = 'anonymous';

            screenVignette_Div.appendChild(screenVignette_Image);


            const container = document.getElementById('v3d-container');

            container.appendChild(screenVignette_Div);


//________________________________________________________________________________
//  SET CSS

            let styleVar = setstyleVar();  //  sets all modal styles

            let style = document.createElement('style');

            style.id = 'screenVignette-Styles-' + screenVignette_ID_Input;

            style.innerHTML = styleVar;

            document.head.appendChild(style);

//________________________________________________________________________________
//  SCREEN FADE DIV CSS

            function setstyleVar()
            {
                let result =
                `
                .screenVignette-Div-${screenVignette_ID_Input}
                {
                    display: block;
                    position: fixed;
                    z-index: ${screenVignette_Z_Index_Input};
                    left: 0px;
                    top: 0px;
                    height: 100%;
                    width: 100%;
                    overflow: hidden;
                    pointer-events: none;

                }

                .screenVignette_Image-${screenVignette_ID_Input}
                {
                    left: 0px;
                    top: 0px;
                    height: 100%;
                    width: 100%;
                    border: none;

                    -webkit-user-select: none;
                    -ms-user-select: none;
                    user-select: none;
                }

                `;

                return result;
            };

            //background: url("${screenVignette_SVG}");
//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function SCREEN_VIGNETTE() {

          screenVignette
          (
              'screenVignette_1',
              30,
              '62%',
              0,
              0,
              0.3,
              0,
              2,
              0.98
          )
      }


MAIN();



} // end of PL.init function

})(); // end of closure

/* ================================ end of code ============================= */
