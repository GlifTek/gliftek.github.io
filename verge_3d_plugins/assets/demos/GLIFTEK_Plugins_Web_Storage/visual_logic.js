/**
 * Generated by Verge3D Puzzles v.3.7.0
 * Mon Aug 16 2021 17:12:51 GMT-0400 (Eastern Daylight Time)
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */

'use strict';

(function() {

// global variables/constants used by puzzles' functions

var LIST_NONE = '<none>';

var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster();

var PL = v3d.PL = v3d.PL || {};

// a more readable alias for PL (stands for "Puzzle Logic")
v3d.puzzles = PL;

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        }
    }

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    var PROC = {
    
};

// initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = true;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = false;
_initGlob.output.initOptions.useFullscreen = true;

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["MAKE_OBJECTS"] = MAKE_OBJECTS;
this.procedures["SET_LISTS"] = SET_LISTS;
this.procedures["SETUP_MENU"] = SETUP_MENU;
this.procedures["MAIN"] = MAIN;
this.procedures["SET_TEXT_OBJECTS_HIEGHT_AND_COLOR"] = SET_TEXT_OBJECTS_HIEGHT_AND_COLOR;
this.procedures["SET_DICT_OBJECT_COLORS"] = SET_DICT_OBJECT_COLORS;
this.procedures["SETUP_OBJECTS"] = SETUP_OBJECTS;
this.procedures["SET_PARENT_PARAMS"] = SET_PARENT_PARAMS;
this.procedures["TEXT_PROC_LOOP"] = TEXT_PROC_LOOP;
this.procedures["SET_INSTRUCTIONS"] = SET_INSTRUCTIONS;
this.procedures["DRAG_OBJECTS_LOOP"] = DRAG_OBJECTS_LOOP;
this.procedures["LOOP_TEXT_COLORS_AND_HEIGHT"] = LOOP_TEXT_COLORS_AND_HEIGHT;
this.procedures["DRAG_OBJECTS"] = DRAG_OBJECTS;
this.procedures["MAKE_TEXT_OBJECTS_AND_HITBOXES"] = MAKE_TEXT_OBJECTS_AND_HITBOXES;
this.procedures["CLICK_MENU_ITEMS"] = CLICK_MENU_ITEMS;
this.procedures["GET_DATA_FROM_OBJECTS"] = GET_DATA_FROM_OBJECTS;
this.procedures["CONFIG_WEB_STORAGE"] = CONFIG_WEB_STORAGE;
this.procedures["SET_CONSTRAINTS"] = SET_CONSTRAINTS;
this.procedures["HOVER_MENU_ITEMS"] = HOVER_MENU_ITEMS;
this.procedures["SET_DATABASE_NAME_VARS"] = SET_DATABASE_NAME_VARS;
this.procedures["OUTLINE_HITBOX"] = OUTLINE_HITBOX;
this.procedures["CLICK_OBJECTS"] = CLICK_OBJECTS;
this.procedures["SAVE_OBJECT_DATA"] = SAVE_OBJECT_DATA;
this.procedures["SAVE_KEY"] = SAVE_KEY;
this.procedures["HOVER_OBJECTS"] = HOVER_OBJECTS;
this.procedures["LOAD_KEY"] = LOAD_KEY;
this.procedures["LOAD_OBJECT_DATA"] = LOAD_OBJECT_DATA;
this.procedures["APPLY_LOADED_DATA_TO_OBJECTS"] = APPLY_LOADED_DATA_TO_OBJECTS;
this.procedures["NEXT_COLOR"] = NEXT_COLOR;
this.procedures["DELETE_KEY"] = DELETE_KEY;
this.procedures["CLEAR_DATABASE"] = CLEAR_DATABASE;
this.procedures["GET_LENGTH_OF_DATASTORE"] = GET_LENGTH_OF_DATASTORE;
this.procedures["GET_ALL_KEYS"] = GET_ALL_KEYS;
this.procedures["DELETE_DATASTORE"] = DELETE_DATASTORE;
this.procedures["DELETE_DATABASE"] = DELETE_DATABASE;
this.procedures["ITERATE_DATASTORE"] = ITERATE_DATASTORE;

var PROC = {
    "MAKE_OBJECTS": MAKE_OBJECTS,
    "SET_LISTS": SET_LISTS,
    "SETUP_MENU": SETUP_MENU,
    "MAIN": MAIN,
    "SET_TEXT_OBJECTS_HIEGHT_AND_COLOR": SET_TEXT_OBJECTS_HIEGHT_AND_COLOR,
    "SET_DICT_OBJECT_COLORS": SET_DICT_OBJECT_COLORS,
    "SETUP_OBJECTS": SETUP_OBJECTS,
    "SET_PARENT_PARAMS": SET_PARENT_PARAMS,
    "TEXT_PROC_LOOP": TEXT_PROC_LOOP,
    "SET_INSTRUCTIONS": SET_INSTRUCTIONS,
    "DRAG_OBJECTS_LOOP": DRAG_OBJECTS_LOOP,
    "LOOP_TEXT_COLORS_AND_HEIGHT": LOOP_TEXT_COLORS_AND_HEIGHT,
    "DRAG_OBJECTS": DRAG_OBJECTS,
    "MAKE_TEXT_OBJECTS_AND_HITBOXES": MAKE_TEXT_OBJECTS_AND_HITBOXES,
    "CLICK_MENU_ITEMS": CLICK_MENU_ITEMS,
    "GET_DATA_FROM_OBJECTS": GET_DATA_FROM_OBJECTS,
    "CONFIG_WEB_STORAGE": CONFIG_WEB_STORAGE,
    "SET_CONSTRAINTS": SET_CONSTRAINTS,
    "HOVER_MENU_ITEMS": HOVER_MENU_ITEMS,
    "SET_DATABASE_NAME_VARS": SET_DATABASE_NAME_VARS,
    "OUTLINE_HITBOX": OUTLINE_HITBOX,
    "CLICK_OBJECTS": CLICK_OBJECTS,
    "SAVE_OBJECT_DATA": SAVE_OBJECT_DATA,
    "SAVE_KEY": SAVE_KEY,
    "HOVER_OBJECTS": HOVER_OBJECTS,
    "LOAD_KEY": LOAD_KEY,
    "LOAD_OBJECT_DATA": LOAD_OBJECT_DATA,
    "APPLY_LOADED_DATA_TO_OBJECTS": APPLY_LOADED_DATA_TO_OBJECTS,
    "NEXT_COLOR": NEXT_COLOR,
    "DELETE_KEY": DELETE_KEY,
    "CLEAR_DATABASE": CLEAR_DATABASE,
    "GET_LENGTH_OF_DATASTORE": GET_LENGTH_OF_DATASTORE,
    "GET_ALL_KEYS": GET_ALL_KEYS,
    "DELETE_DATASTORE": DELETE_DATASTORE,
    "DELETE_DATABASE": DELETE_DATABASE,
    "ITERATE_DATASTORE": ITERATE_DATASTORE,
};

var text_object_name, text_vertical, text_material, text_color, obj, text_font, save_object, loaded_DICTIONARY, DICT_load_object, current_color, current_object, LIST_text_items, DICT_object_colors, textParent_scale, EXEC_TEXT_instructions, i, text_item_number, DICT_save_object, my_saved_key, DICT_save_all_objects, m, load_object, next_color, length_of_CSV, LIST_keys_from_database, LIST_text_colors, LIST_objects, hitbox_name, LIST_hitboxes, DICT_save_object_POSITION, hovered_text, my_dataStore, j, load_object_position, my_database, text_item, selected_item, DICT_save_object_ROTATION, my_description, load_object_rotation, DICT_save_object_SCALE, load_object_scale, load_object_color, LIST_colors, load_object_material;


// createObject puzzle
function createObject(type, name, width, height, depth, radius, tube, segments, cameraType, lightType, fov) {

    var oldObj = appInstance.scene.getObjectByName(name);
    if (oldObj) {
        oldObj.parent.remove(oldObj);
    }

    var obj;
    var geometry;

    switch (type) {
        case 'BOX':
            geometry = new v3d.BoxBufferGeometry(width, height, depth);
            break;
        case 'CAMERA':
            var aspect = appInstance.container.offsetWidth / appInstance.container.offsetHeight;

            if (cameraType == 'PERSPECTIVE') {

                obj = new v3d.PerspectiveCamera(fov, aspect, 1, 1000);

            } else {

                var width = fov * aspect;
                obj = new v3d.OrthographicCamera(-width/2, width/2, fov/2, -fov/2, -1000, 1000);

            }

            obj.lookAt(_pGlob.vec3Tmp.set(0, 0, 0));
            break;
        case 'CIRCLE':
            geometry = new v3d.CircleBufferGeometry(radius, segments);
            break;
        case 'CONE':
            geometry = new v3d.ConeBufferGeometry(radius, height, segments);
            break;
        case 'CYLINDER':
            geometry = new v3d.CylinderBufferGeometry(radius, radius, height, segments);
            break;
        case 'EMPTY':
            obj = new v3d.Object3D();
            break;
        case 'LIGHT':
            var color = 0xffffff;
            var intensity = 0.5;

            switch (lightType) {
                case 'AMBIENT':
                    obj = new v3d.AmbientLight(color, intensity);
                    break;
                case 'AREA':
                    v3d.RectAreaLightUniformsLib.init(LTC_MAT_1, LTC_MAT_2);
                    obj = new v3d.RectAreaLight(color, intensity, 1, 1);
                    break;
                case 'DIRECTIONAL':
                    obj = new v3d.DirectionalLight(color, intensity);
                    break;
                case 'HEMISPHERE':
                    obj = new v3d.HemisphereLight(color, 0, intensity);
                    break;
                case 'POINT':
                    obj = new v3d.PointLight(color, intensity);
                    break;
                case 'SPOT':
                    obj = new v3d.SpotLight(color, intensity);
                    break;
            }

            obj.isFreeLight = true;

            break;
        case 'PLANE':
            geometry = new v3d.PlaneBufferGeometry(width, height, 1, 1);
            break;
        case 'SPHERE':
            geometry = new v3d.SphereBufferGeometry(radius, 32, 32);
            break;
        case 'TEAPOT':
            geometry = new v3d.TeapotBufferGeometry(width);
            break;
        case 'TORUS':
            geometry = new v3d.TorusBufferGeometry(radius, tube, 32, 32);
            break;
    }

    if (geometry) {
        var material = new v3d.MeshStandardMaterial({
            color: 'white',
            roughness: 1.0,
            metalness: 0.0,
            side: (type == 'CIRCLE' || type == 'PLANE' || type == 'TEAPOT') ? v3d.DoubleSide : v3d.FrontSide
        });

        material.name = name + 'Material';

        obj = new v3d.Mesh(geometry, material);
    }

    obj.name = name;

    appInstance.scene.add(obj);

    // clean object cache
    _pGlob.objCache = {};

}



function matGetColors(matName) {
    var mat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
    if (!mat)
        return [];

    if (mat.isMeshNodeMaterial)
        return Object.keys(mat.nodeRGBMap);
    else if (mat.isMeshStandardMaterial)
        return ['color', 'emissive'];
    else
        return [];
}



// setMaterialColor puzzle
function setMaterialColor(matName, colName, r, g, b, cssCode) {

    var colors = matGetColors(matName);

    if (colors.indexOf(colName) < 0)
        return;

    if (cssCode) {
        var color = new v3d.Color(cssCode);
        color.convertSRGBToLinear();
        r = color.r;
        g = color.g;
        b = color.b;
    }

    var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);

    for (var i = 0; i < mats.length; i++) {
        var mat = mats[i];

        if (mat.isMeshNodeMaterial) {
            var rgbIdx = mat.nodeRGBMap[colName];
            mat.nodeRGB[rgbIdx].x = r;
            mat.nodeRGB[rgbIdx].y = g;
            mat.nodeRGB[rgbIdx].z = b;
        } else {
            mat[colName].r = r;
            mat[colName].g = g;
            mat[colName].b = b;
        }
        mat.needsUpdate = true;

        if (appInstance.scene !== null) {
            if (mat === appInstance.scene.worldMaterial) {
                appInstance.updateEnvironment(mat);
            }
        }
    }
}




// utility function envoked by almost all V3D-specific puzzles
// filter off some non-mesh types
function notIgnoredObj(obj) {
    return obj.type !== 'AmbientLight' &&
           obj.name !== '' &&
           !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
           !obj.isAuxClippingMesh;
}


// utility function envoked by almost all V3D-specific puzzles
// find first occurence of the object by its name
function getObjectByName(objName) {
    var objFound;
    var runTime = _pGlob !== undefined;
    objFound = runTime ? _pGlob.objCache[objName] : null;

    if (objFound && objFound.name === objName)
        return objFound;

    appInstance.scene.traverse(function(obj) {
        if (!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
            objFound = obj;
            if (runTime) {
                _pGlob.objCache[objName] = objFound;
            }
        }
    });
    return objFound;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects on the scene
function getAllObjectNames() {
    var objNameList = [];
    appInstance.scene.traverse(function(obj) {
        if (notIgnoredObj(obj))
            objNameList.push(obj.name)
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects which belong to the group
function getObjectNamesByGroupName(targetGroupName) {
    var objNameList = [];
    appInstance.scene.traverse(function(obj){
        if (notIgnoredObj(obj)) {
            var groupNames = obj.groupNames;
            if (!groupNames)
                return;
            for (var i = 0; i < groupNames.length; i++) {
                var groupName = groupNames[i];
                if (groupName == targetGroupName) {
                    objNameList.push(obj.name);
                }
            }
        }
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// process object input, which can be either single obj or array of objects, or a group
function retrieveObjectNames(objNames) {
    var acc = [];
    retrieveObjectNamesAcc(objNames, acc);
    return acc.filter(function(name) {
        return name;
    });
}

function retrieveObjectNamesAcc(currObjNames, acc) {
    if (typeof currObjNames == "string") {
        acc.push(currObjNames);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
        var newObj = getObjectNamesByGroupName(currObjNames[1]);
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "ALL_OBJECTS") {
        var newObj = getAllObjectNames();
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames)) {
        for (var i = 0; i < currObjNames.length; i++)
            retrieveObjectNamesAcc(currObjNames[i], acc);
    }
}





/**
 * Retrieve coordinate system from the loaded scene
 */
function getCoordSystem() {
    var scene = appInstance.scene;

    if (scene && "v3d" in scene.userData && "coordSystem" in scene.userData.v3d) {
        return scene.userData.v3d.coordSystem;
    } else {
        // COMPAT: <2.17, consider replacing to 'Y_UP_RIGHT' for scenes with unknown origin
        return 'Z_UP_RIGHT';
    }
}


/**
 * Transform coordinates from one space to another
 * Can be used with Vector3 or Euler.
 */
function coordsTransform(coords, from, to, noSignChange) {

    if (from == to)
        return coords;

    var y = coords.y, z = coords.z;

    if (from == 'Z_UP_RIGHT' && to == 'Y_UP_RIGHT') {
        coords.y = z;
        coords.z = noSignChange ? y : -y;
    } else if (from == 'Y_UP_RIGHT' && to == 'Z_UP_RIGHT') {
        coords.y = noSignChange ? z : -z;
        coords.z = y;
    } else {
        console.error('coordsTransform: Unsupported coordinate space');
    }

    return coords;
}


/**
 * Verge3D euler rotation to Blender/Max shortest.
 * 1) Convert from intrinsic rotation (v3d) to extrinsic XYZ (Blender/Max default
 *    order) via reversion: XYZ -> ZYX
 * 2) swizzle ZYX->YZX
 * 3) choose the shortest rotation to resemble Blender's behavior
 */
var eulerV3DToBlenderShortest = function() {

    var eulerTmp = new v3d.Euler();
    var eulerTmp2 = new v3d.Euler();
    var vec3Tmp = new v3d.Vector3();

    return function(euler, dest) {

        var eulerBlender = eulerTmp.copy(euler).reorder('YZX');
        var eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();

        var len = eulerBlender.toVector3(vec3Tmp).lengthSq();
        var lenAlt = eulerBlenderAlt.toVector3(vec3Tmp).lengthSq();

        dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
        return coordsTransform(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
    }

}();




function RotationInterface() {
    /**
     * For user manipulations use XYZ extrinsic rotations (which
     * are the same as ZYX intrinsic rotations)
     *     - Blender/Max/Maya use extrinsic rotations in the UI
     *     - XYZ is the default option, but could be set from
     *       some order hint if exported
     */
    this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
    this._actualRotation = new v3d.Euler();
}

Object.assign(RotationInterface, {
    initObject: function(obj) {
        if (obj.userData.v3d.puzzles === undefined) {
            obj.userData.v3d.puzzles = {}
        }
        if (obj.userData.v3d.puzzles.rotationInterface === undefined) {
            obj.userData.v3d.puzzles.rotationInterface = new RotationInterface();
        }

        var rotUI = obj.userData.v3d.puzzles.rotationInterface;
        rotUI.updateFromObject(obj);
        return rotUI;
    }
});

Object.assign(RotationInterface.prototype, {

    updateFromObject: function(obj) {
        var SYNC_ROT_EPS = 1e-8;

        if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
            this._actualRotation.copy(obj.rotation);
            this._updateUserRotFromActualRot();
        }
    },

    getActualRotation: function(euler) {
        return euler.copy(this._actualRotation);
    },

    setUserRotation: function(euler) {
        // don't copy the order, since it's fixed to ZYX for now
        this._userRotation.set(euler.x, euler.y, euler.z);
        this._updateActualRotFromUserRot();
    },

    getUserRotation: function(euler) {
        return euler.copy(this._userRotation);
    },

    _updateUserRotFromActualRot: function() {
        var order = this._userRotation.order;
        this._userRotation.copy(this._actualRotation).reorder(order);
    },

    _updateActualRotFromUserRot: function() {
        var order = this._actualRotation.order;
        this._actualRotation.copy(this._userRotation).reorder(order);
    }

});




// setObjTransform puzzle
function setObjTransform(objSelector, mode, x, y, z, offset) {

    var objNames = retrieveObjectNames(objSelector);

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    var inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''),
            Number(z !== ''));
    var coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.Math.DEG2RAD);
    }

    var coordSystem = getCoordSystem();

    coordsTransform(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    coordsTransform(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (var i = 0; i < objNames.length; i++) {

        var objName = objNames[i];
        if (!objName) continue;

        var obj = getObjectByName(objName);
        if (!obj) continue;

        if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            var euler = eulerV3DToBlenderShortest(obj.rotation, _pGlob.eulerTmp);
            coordsTransform(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            var rotUI = RotationInterface.initObject(obj);
            var euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

        }

        obj.updateMatrixWorld(true);
    }

}



// makeParent puzzle
function makeParent(objName, targetObjName) {
    if (!objName)
        return;
    var obj = getObjectByName(objName);
    if (!obj)
        return;
    if (targetObjName && targetObjName !== LIST_NONE) {
        var targetObj = getObjectByName(targetObjName);
        if (!targetObj)
            return;
    } else {
        obj.traverseAncestors(function(ancObj) {
            if (ancObj.type == "Scene")
                targetObj = ancObj;
        });
    }
    var matOffset = new v3d.Matrix4();
    matOffset.copy(targetObj.matrixWorld).invert();
    matOffset.multiply(obj.matrixWorld);
    matOffset.decompose(obj.position, obj.quaternion, obj.scale);
    targetObj.add(obj);

    obj.updateMatrixWorld(true);
}


// Describe this function...
function MAKE_OBJECTS() {
  var VARS = Object.defineProperties({}, {
    "text_object_name": { get: function() { return text_object_name; }, set: function(val) { text_object_name = val; } },
    "text_vertical": { get: function() { return text_vertical; }, set: function(val) { text_vertical = val; } },
    "text_material": { get: function() { return text_material; }, set: function(val) { text_material = val; } },
    "text_color": { get: function() { return text_color; }, set: function(val) { text_color = val; } },
    "obj": { get: function() { return obj; }, set: function(val) { obj = val; } },
    "text_font": { get: function() { return text_font; }, set: function(val) { text_font = val; } },
    "save_object": { get: function() { return save_object; }, set: function(val) { save_object = val; } },
    "loaded_DICTIONARY": { get: function() { return loaded_DICTIONARY; }, set: function(val) { loaded_DICTIONARY = val; } },
    "DICT_load_object": { get: function() { return DICT_load_object; }, set: function(val) { DICT_load_object = val; } },
    "current_color": { get: function() { return current_color; }, set: function(val) { current_color = val; } },
    "current_object": { get: function() { return current_object; }, set: function(val) { current_object = val; } },
    "LIST_text_items": { get: function() { return LIST_text_items; }, set: function(val) { LIST_text_items = val; } },
    "DICT_object_colors": { get: function() { return DICT_object_colors; }, set: function(val) { DICT_object_colors = val; } },
    "textParent_scale": { get: function() { return textParent_scale; }, set: function(val) { textParent_scale = val; } },
    "EXEC_TEXT_instructions": { get: function() { return EXEC_TEXT_instructions; }, set: function(val) { EXEC_TEXT_instructions = val; } },
    "i": { get: function() { return i; }, set: function(val) { i = val; } },
    "text_item_number": { get: function() { return text_item_number; }, set: function(val) { text_item_number = val; } },
    "DICT_save_object": { get: function() { return DICT_save_object; }, set: function(val) { DICT_save_object = val; } },
    "my_saved_key": { get: function() { return my_saved_key; }, set: function(val) { my_saved_key = val; } },
    "DICT_save_all_objects": { get: function() { return DICT_save_all_objects; }, set: function(val) { DICT_save_all_objects = val; } },
    "m": { get: function() { return m; }, set: function(val) { m = val; } },
    "load_object": { get: function() { return load_object; }, set: function(val) { load_object = val; } },
    "next_color": { get: function() { return next_color; }, set: function(val) { next_color = val; } },
    "length_of_CSV": { get: function() { return length_of_CSV; }, set: function(val) { length_of_CSV = val; } },
    "LIST_keys_from_database": { get: function() { return LIST_keys_from_database; }, set: function(val) { LIST_keys_from_database = val; } },
    "LIST_text_colors": { get: function() { return LIST_text_colors; }, set: function(val) { LIST_text_colors = val; } },
    "LIST_objects": { get: function() { return LIST_objects; }, set: function(val) { LIST_objects = val; } },
    "hitbox_name": { get: function() { return hitbox_name; }, set: function(val) { hitbox_name = val; } },
    "LIST_hitboxes": { get: function() { return LIST_hitboxes; }, set: function(val) { LIST_hitboxes = val; } },
    "DICT_save_object_POSITION": { get: function() { return DICT_save_object_POSITION; }, set: function(val) { DICT_save_object_POSITION = val; } },
    "hovered_text": { get: function() { return hovered_text; }, set: function(val) { hovered_text = val; } },
    "my_dataStore": { get: function() { return my_dataStore; }, set: function(val) { my_dataStore = val; } },
    "j": { get: function() { return j; }, set: function(val) { j = val; } },
    "load_object_position": { get: function() { return load_object_position; }, set: function(val) { load_object_position = val; } },
    "my_database": { get: function() { return my_database; }, set: function(val) { my_database = val; } },
    "text_item": { get: function() { return text_item; }, set: function(val) { text_item = val; } },
    "selected_item": { get: function() { return selected_item; }, set: function(val) { selected_item = val; } },
    "DICT_save_object_ROTATION": { get: function() { return DICT_save_object_ROTATION; }, set: function(val) { DICT_save_object_ROTATION = val; } },
    "my_description": { get: function() { return my_description; }, set: function(val) { my_description = val; } },
    "load_object_rotation": { get: function() { return load_object_rotation; }, set: function(val) { load_object_rotation = val; } },
    "DICT_save_object_SCALE": { get: function() { return DICT_save_object_SCALE; }, set: function(val) { DICT_save_object_SCALE = val; } },
    "load_object_scale": { get: function() { return load_object_scale; }, set: function(val) { load_object_scale = val; } },
    "load_object_color": { get: function() { return load_object_color; }, set: function(val) { load_object_color = val; } },
    "LIST_colors": { get: function() { return LIST_colors; }, set: function(val) { LIST_colors = val; } },
    "load_object_material": { get: function() { return load_object_material; }, set: function(val) { load_object_material = val; } },
});

  Function('app', 'v3d', 'VARS', 'PROC', (('// FLOOR' + '\n' +
  '//  ' + '\n' +
  '    let floorTexture = new THREE.TextureLoader().load( \'./checkerboard.jpg\' );' + '\n' +
  '	floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; ' + '\n' +
  '	floorTexture.repeat.set( 2.5, 2.5 );' + '\n' +
  '	let floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );' + '\n' +
  '	' + '\n' +
  '    floorMaterial.opacity = .5;' + '\n' +
  '    floorMaterial.transparent = true;' + '\n' +
  '    floorMaterial.needsUpdate = true;' + '\n' +
  '	' + '\n' +
  '	let floorGeometry = new THREE.PlaneBufferGeometry(20, 20, 10, 10);' + '\n' +
  '	let floor = new THREE.Mesh(floorGeometry, floorMaterial);' + '\n' +
  '	floor.rotation.x = Math.PI / 2;' + '\n' +
  '	app.scene.add(floor);')))(appInstance, v3d, VARS, PROC);

  createObject('BOX', 'Cube', 2, 2, 2, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
  createObject('TEAPOT', 'Teapot', 1, 0, 0, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
  createObject('TORUS', 'Torus', 0, 0, 0, 1, 0.5, 0, 'PERSPECTIVE', 'AMBIENT', 0);
  createObject('EMPTY', 'objParentEmpty', 0, 0, 0, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
  LIST_objects = ['Cube', 'Teapot', 'Torus'];
  LIST_colors = ['red', 'green', 'blue'];
  setMaterialColor('CubeMaterial', 'color', 0, 0, 0, 'red');
  setMaterialColor('TeapotMaterial', 'color', 0, 0, 0, 'green');
  setMaterialColor('TorusMaterial', 'color', 0, 0, 0, 'blue');
  setObjTransform('Cube', 'position', -6, '', '', false);
  setObjTransform('Teapot', 'position', 0, '', '', false);
  setObjTransform('Torus', 'position', 6, '', 0.5, false);
  setObjTransform('Torus', 'rotation', 90, '', '', false);
  makeParent('Cube', 'objParentEmpty');
  makeParent('Teapot', 'objParentEmpty');
  makeParent('Torus', 'objParentEmpty');
  setObjTransform('objParentEmpty', 'position', '', '', 1, false);
}

// Describe this function...
function SET_LISTS() {
  LIST_text_items = ['SAVE_KEY', 'LOAD_KEY', 'DELETE_KEY', 'GET_ALL_KEYS', 'GET_LENGTH_OF_DATASTORE', 'DELETE_DATASTORE', 'CLEAR_DATABASE', 'DELETE_DATABASE', 'ITERATE_DATASTORE'];
  LIST_text_colors = ['green', 'lightblue', 'red', 'purple', 'teal', 'cyan', 'gray', 'white', 'yellow'];
  LIST_hitboxes = [];
  selected_item = null;
  text_font = './VENUSRIS.ttf';
}

// Describe this function...
function SETUP_MENU() {
  SET_LISTS();
  TEXT_PROC_LOOP();
  HOVER_MENU_ITEMS();
  CLICK_MENU_ITEMS();
}

// Describe this function...
function MAIN() {
  var VARS = Object.defineProperties({}, {
    "text_object_name": { get: function() { return text_object_name; }, set: function(val) { text_object_name = val; } },
    "text_vertical": { get: function() { return text_vertical; }, set: function(val) { text_vertical = val; } },
    "text_material": { get: function() { return text_material; }, set: function(val) { text_material = val; } },
    "text_color": { get: function() { return text_color; }, set: function(val) { text_color = val; } },
    "obj": { get: function() { return obj; }, set: function(val) { obj = val; } },
    "text_font": { get: function() { return text_font; }, set: function(val) { text_font = val; } },
    "save_object": { get: function() { return save_object; }, set: function(val) { save_object = val; } },
    "loaded_DICTIONARY": { get: function() { return loaded_DICTIONARY; }, set: function(val) { loaded_DICTIONARY = val; } },
    "DICT_load_object": { get: function() { return DICT_load_object; }, set: function(val) { DICT_load_object = val; } },
    "current_color": { get: function() { return current_color; }, set: function(val) { current_color = val; } },
    "current_object": { get: function() { return current_object; }, set: function(val) { current_object = val; } },
    "LIST_text_items": { get: function() { return LIST_text_items; }, set: function(val) { LIST_text_items = val; } },
    "DICT_object_colors": { get: function() { return DICT_object_colors; }, set: function(val) { DICT_object_colors = val; } },
    "textParent_scale": { get: function() { return textParent_scale; }, set: function(val) { textParent_scale = val; } },
    "EXEC_TEXT_instructions": { get: function() { return EXEC_TEXT_instructions; }, set: function(val) { EXEC_TEXT_instructions = val; } },
    "i": { get: function() { return i; }, set: function(val) { i = val; } },
    "text_item_number": { get: function() { return text_item_number; }, set: function(val) { text_item_number = val; } },
    "DICT_save_object": { get: function() { return DICT_save_object; }, set: function(val) { DICT_save_object = val; } },
    "my_saved_key": { get: function() { return my_saved_key; }, set: function(val) { my_saved_key = val; } },
    "DICT_save_all_objects": { get: function() { return DICT_save_all_objects; }, set: function(val) { DICT_save_all_objects = val; } },
    "m": { get: function() { return m; }, set: function(val) { m = val; } },
    "load_object": { get: function() { return load_object; }, set: function(val) { load_object = val; } },
    "next_color": { get: function() { return next_color; }, set: function(val) { next_color = val; } },
    "length_of_CSV": { get: function() { return length_of_CSV; }, set: function(val) { length_of_CSV = val; } },
    "LIST_keys_from_database": { get: function() { return LIST_keys_from_database; }, set: function(val) { LIST_keys_from_database = val; } },
    "LIST_text_colors": { get: function() { return LIST_text_colors; }, set: function(val) { LIST_text_colors = val; } },
    "LIST_objects": { get: function() { return LIST_objects; }, set: function(val) { LIST_objects = val; } },
    "hitbox_name": { get: function() { return hitbox_name; }, set: function(val) { hitbox_name = val; } },
    "LIST_hitboxes": { get: function() { return LIST_hitboxes; }, set: function(val) { LIST_hitboxes = val; } },
    "DICT_save_object_POSITION": { get: function() { return DICT_save_object_POSITION; }, set: function(val) { DICT_save_object_POSITION = val; } },
    "hovered_text": { get: function() { return hovered_text; }, set: function(val) { hovered_text = val; } },
    "my_dataStore": { get: function() { return my_dataStore; }, set: function(val) { my_dataStore = val; } },
    "j": { get: function() { return j; }, set: function(val) { j = val; } },
    "load_object_position": { get: function() { return load_object_position; }, set: function(val) { load_object_position = val; } },
    "my_database": { get: function() { return my_database; }, set: function(val) { my_database = val; } },
    "text_item": { get: function() { return text_item; }, set: function(val) { text_item = val; } },
    "selected_item": { get: function() { return selected_item; }, set: function(val) { selected_item = val; } },
    "DICT_save_object_ROTATION": { get: function() { return DICT_save_object_ROTATION; }, set: function(val) { DICT_save_object_ROTATION = val; } },
    "my_description": { get: function() { return my_description; }, set: function(val) { my_description = val; } },
    "load_object_rotation": { get: function() { return load_object_rotation; }, set: function(val) { load_object_rotation = val; } },
    "DICT_save_object_SCALE": { get: function() { return DICT_save_object_SCALE; }, set: function(val) { DICT_save_object_SCALE = val; } },
    "load_object_scale": { get: function() { return load_object_scale; }, set: function(val) { load_object_scale = val; } },
    "load_object_color": { get: function() { return load_object_color; }, set: function(val) { load_object_color = val; } },
    "LIST_colors": { get: function() { return LIST_colors; }, set: function(val) { LIST_colors = val; } },
    "load_object_material": { get: function() { return load_object_material; }, set: function(val) { load_object_material = val; } },
});

  Function('app', 'v3d', 'VARS', 'PROC', 'window.addEventListener("contextmenu", e => e.preventDefault());')(appInstance, v3d, VARS, PROC);

  SET_INSTRUCTIONS();
  SET_DATABASE_NAME_VARS();
  SETUP_OBJECTS();
  SETUP_MENU();
  SET_CONSTRAINTS();
  CONFIG_WEB_STORAGE();
}

// Describe this function...
function SET_TEXT_OBJECTS_HIEGHT_AND_COLOR(text_object_name, text_vertical, text_material, text_color) {
  setObjTransform(text_object_name, 'position', '', '', text_vertical, false);
  setMaterialColor(text_material, 'color', 0, 0, 0, text_color);
}


// dictSet puzzle
function dictSet(dict, key, value) {
    if (dict && typeof dict == 'object')
        dict[key] = value;
}


// Describe this function...
function SET_DICT_OBJECT_COLORS() {
  DICT_object_colors = {};
  dictSet(DICT_object_colors, 'Cube', 'red');
  dictSet(DICT_object_colors, 'Teapot', 'green');
  dictSet(DICT_object_colors, 'Torus', 'blue');
}

// Describe this function...
function SETUP_OBJECTS() {
  MAKE_OBJECTS();
  SET_DICT_OBJECT_COLORS();
  DRAG_OBJECTS_LOOP();
  HOVER_OBJECTS();
  CLICK_OBJECTS();
}

// Describe this function...
function SET_PARENT_PARAMS() {
  textParent_scale = 1.15;
  setObjTransform('textParentEmpty', 'scale', textParent_scale, textParent_scale, textParent_scale, false);
  setObjTransform('textParentEmpty', 'position', '', 5, -1, false);
  setObjTransform('Camera', 'position', '', -45, 20, false);
}

// Describe this function...
function TEXT_PROC_LOOP() {
  createObject('EMPTY', 'textParentEmpty', 0, 0, 0, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
  var text_item_number_end = LIST_text_items.length;
  var text_item_number_inc = 1;
  if (0 > text_item_number_end) {
    text_item_number_inc = -text_item_number_inc;
  }
  for (text_item_number = 0; text_item_number_inc >= 0 ? text_item_number <= text_item_number_end : text_item_number >= text_item_number_end; text_item_number += text_item_number_inc) {
    text_item = LIST_text_items[text_item_number];
    MAKE_TEXT_OBJECTS_AND_HITBOXES(text_item, LIST_text_colors[text_item_number], text_font, text_item_number * -1);
    if (text_item_number == LIST_text_items.length - 1) {
      SET_PARENT_PARAMS();
      LOOP_TEXT_COLORS_AND_HEIGHT();
    }
  }
}

// Describe this function...
function SET_INSTRUCTIONS() {
  EXEC_TEXT_instructions = ('Welcome to the [ GLIFTEK ] Web Storage Plugin Demo.\\n' + '\n' +
  'Instructions:\\n' + '\n' +
  'Left Click: Move objects\\n' + '\n' +
  'Middle Click: Scale Objects\\n' + '\n' +
  'Right Click: Rotate Objects\\n' + '\n' +
  '' + '\n' +
  'To access your browser\'s offline web storage interface,\\n' + '\n' +
  'open your Broswer Dev Tools (f12 on most) and select:\\n' + '\n' +
  '' + '\n' +
  'Firefox: Storage Tab\\n' + '\n' +
  'Chrome: Application Tab, Storage Section\\n' + '\n' +
  'Edge: Application Tab, Storage Section\\n' + '\n' +
  'Opera: Ctrl+Shift+I, Application Tab, Storage Section\\n' + '\n' +
  '' + '\n' +
  'Links to browser support stats of the three storage drivers\\n' + '\n' +
  'used in this plugin:\\n' + '\n' +
  'IndexedDB - https://caniuse.com/indexeddb\\n' + '\n' +
  'LocalStorage - https://caniuse.com/mdn-api_window_localstorage\\n' + '\n' +
  'WebSQL - https://caniuse.com/sql-storage\\n');
}

// Describe this function...
function DRAG_OBJECTS_LOOP() {
  for (var i_index in LIST_objects) {
    i = LIST_objects[i_index];
    DRAG_OBJECTS(i);
  }
}

// Describe this function...
function LOOP_TEXT_COLORS_AND_HEIGHT() {
  var text_item_number_end2 = LIST_text_items.length;
  var text_item_number_inc2 = 1;
  if (0 > text_item_number_end2) {
    text_item_number_inc2 = -text_item_number_inc2;
  }
  for (text_item_number = 0; text_item_number_inc2 >= 0 ? text_item_number <= text_item_number_end2 : text_item_number >= text_item_number_end2; text_item_number += text_item_number_inc2) {
    SET_TEXT_OBJECTS_HIEGHT_AND_COLOR(LIST_text_items[text_item_number], text_item_number * -1, String(LIST_text_items[text_item_number]) + 'Material', LIST_text_colors[text_item_number]);
  }
}


// outline puzzle
function outline(objSelector, doWhat) {
    var objNames = retrieveObjectNames(objSelector);

    if (!appInstance.postprocessing || !appInstance.postprocessing.outlinePass)
        return;
    var outlineArray = appInstance.postprocessing.outlinePass.selectedObjects;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        var obj = getObjectByName(objName);
        if (!obj)
            continue;
        if (doWhat == "ENABLE") {
            if (outlineArray.indexOf(obj) == -1)
                outlineArray.push(obj);
        } else {
            var index = outlineArray.indexOf(obj);
            if (index > -1)
                outlineArray.splice(index, 1);
        }
    }
}



function intersectPlaneCSS(plane, cssX, cssY, dest) {
    var coords = _pGlob.vec2Tmp;
    var rc = _pGlob.raycasterTmp;
    coords.x = (cssX / appInstance.getWidth()) * 2 - 1;
    coords.y = - (cssY / appInstance.getHeight()) * 2 + 1;
    rc.setFromCamera(coords, appInstance.getCamera(true));
    return rc.ray.intersectPlane(plane, dest);
}



// dragMove puzzle
_pGlob.dragMoveOrigins = {};

function dragMove(objSelector, mode, blockId, parentDragOverBlockId) {
    var camera = appInstance.getCamera();
    if (!camera)
        return;

    if (!_pGlob.objDragOverInfoByBlock)
        return;

    var objNames = retrieveObjectNames(objSelector);

    var info = _pGlob.objDragOverInfoByBlock[parentDragOverBlockId];
    if (!info) return;

    var draggedObj = getObjectByName(info.draggedObjName);
    if (!draggedObj) return;

    if (!(blockId in _pGlob.dragMoveOrigins)) {
        _pGlob.dragMoveOrigins[blockId] = [];
    }
    var posOrigins = _pGlob.dragMoveOrigins[blockId];
    var lenDiff = objNames.length - posOrigins.length;
    for (var i = 0; i < lenDiff; i++) {
        posOrigins.push(new v3d.Vector3());
    }

    for (var i = 0; i < objNames.length; i++) {
        var obj = getObjectByName(objNames[i]);
        if (!obj) {
            continue;
        }

        var posOrigin = posOrigins[i];

        if (!info.isMoved) {
            // the object position before the first move is used as an initial value
            posOrigin.copy(obj.position);
        }

        var coordSystem = getCoordSystem();

        if (mode == "X" || mode == "Y" || mode == "Z") {

            if (coordSystem == 'Z_UP_RIGHT') {
                var axis = mode == "X" ? _pGlob.AXIS_X : (mode == "Y" ? _pGlob.AXIS_Z : _pGlob.AXIS_Y);
                var coord = mode == "X" ? "x" : (mode == "Y" ? "z" : "y");
            } else {
                var axis = mode == "X" ? _pGlob.AXIS_X : (mode == "Y" ? _pGlob.AXIS_Y : _pGlob.AXIS_Z);
                var coord = mode == "X" ? "x" : (mode == "Y" ? "y" : "z");
            }

            var planeNor = camera.getWorldDirection(_pGlob.vec3Tmp);
            planeNor.cross(axis).cross(axis);
            var plane = _pGlob.planeTmp.setFromNormalAndCoplanarPoint(planeNor, draggedObj.position);

            var p0 = intersectPlaneCSS(plane, info.downX, info.downY, _pGlob.vec3Tmp);
            var p1 = intersectPlaneCSS(plane, info.currX, info.currY, _pGlob.vec3Tmp2);
            if (p0 && p1) {
                obj.position[coord] = posOrigin[coord] + p1[coord] - p0[coord];
            }
        } else if (mode == "XY" || mode == "XZ" || mode == "YZ") {
            if (coordSystem == 'Z_UP_RIGHT') {
                var normal = mode == "XY" ? _pGlob.AXIS_Y : (mode == "XZ" ? _pGlob.AXIS_Z : _pGlob.AXIS_X);
                var coord0 = mode == "XY" ? "x" : (mode == "XZ" ? "x" : "y");
                var coord1 = mode == "XY" ? "z" : (mode == "XZ" ? "y" : "z");
            } else {
                var normal = mode == "XY" ? _pGlob.AXIS_Z : (mode == "XZ" ? _pGlob.AXIS_Y : _pGlob.AXIS_X);
                var coord0 = mode == "XY" ? "x" : (mode == "XZ" ? "x" : "y");
                var coord1 = mode == "XY" ? "y" : (mode == "XZ" ? "z" : "z");
            }

            var plane = _pGlob.planeTmp.setFromNormalAndCoplanarPoint(normal, draggedObj.position);

            var p0 = intersectPlaneCSS(plane, info.downX, info.downY, _pGlob.vec3Tmp);
            var p1 = intersectPlaneCSS(plane, info.currX, info.currY, _pGlob.vec3Tmp2);
            if (p0 && p1) {
                obj.position[coord0] = posOrigin[coord0] + p1[coord0] - p0[coord0];
                obj.position[coord1] = posOrigin[coord1] + p1[coord1] - p0[coord1];
            }
        } else if (mode == "XYZ") {
            var planeNor = camera.getWorldDirection(_pGlob.vec3Tmp);
            var plane = _pGlob.planeTmp.setFromNormalAndCoplanarPoint(planeNor, draggedObj.position);

            var p0 = intersectPlaneCSS(plane, info.downX, info.downY, _pGlob.vec3Tmp);
            var p1 = intersectPlaneCSS(plane, info.currX, info.currY, _pGlob.vec3Tmp2);
            if (p0 && p1) {
                obj.position.addVectors(posOrigin, p1).sub(p0);
            }
        }
        obj.updateMatrixWorld(true);
    }
}



// utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
function initObjectPicking(callback, eventType, mouseDownUseTouchStart, mouseButtons) {

    var elem = appInstance.renderer.domElement;
    elem.addEventListener(eventType, pickListener);
    if (v3d.PL.editorEventListeners)
        v3d.PL.editorEventListeners.push([elem, eventType, pickListener]);

    if (eventType == 'mousedown') {

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        elem.addEventListener(touchEventName, pickListener);
        if (v3d.PL.editorEventListeners)
            v3d.PL.editorEventListeners.push([elem, touchEventName, pickListener]);

    } else if (eventType == 'dblclick') {

        var prevTapTime = 0;

        function doubleTapCallback(event) {

            var now = new Date().getTime();
            var timesince = now - prevTapTime;

            if (timesince < 600 && timesince > 0) {

                pickListener(event);
                prevTapTime = 0;
                return;

            }

            prevTapTime = new Date().getTime();
        }

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        elem.addEventListener(touchEventName, doubleTapCallback);
        if (v3d.PL.editorEventListeners)
            v3d.PL.editorEventListeners.push([elem, touchEventName, doubleTapCallback]);
    }

    var raycaster = new v3d.Raycaster();

    function pickListener(event) {

        // to handle unload in loadScene puzzle
        if (!appInstance.getCamera())
            return;

        event.preventDefault();

        var xNorm = 0, yNorm = 0;
        if (event instanceof MouseEvent) {
            if (mouseButtons && mouseButtons.indexOf(event.button) == -1)
                return;
            xNorm = event.offsetX / elem.clientWidth;
            yNorm = event.offsetY / elem.clientHeight;
        } else if (event instanceof TouchEvent) {
            var rect = elem.getBoundingClientRect();
            xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
            yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
        }

        _pGlob.screenCoords.x = xNorm * 2 - 1;
        _pGlob.screenCoords.y = -yNorm * 2 + 1;
        raycaster.setFromCamera(_pGlob.screenCoords, appInstance.getCamera(true));
        var objList = [];
        appInstance.scene.traverse(function(obj){objList.push(obj);});
        var intersects = raycaster.intersectObjects(objList);
        callback(intersects, event);
    }
}

function objectsIncludeObj(objNames, testedObjName) {
    if (!testedObjName) return false;

    for (var i = 0; i < objNames.length; i++) {
        if (testedObjName == objNames[i]) {
            return true;
        } else {
            // also check children which are auto-generated for multi-material objects
            var obj = getObjectByName(objNames[i]);
            if (obj && obj.type == "Group") {
                for (var j = 0; j < obj.children.length; j++) {
                    if (testedObjName == obj.children[j].name) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

// utility function used by the whenClicked, whenHovered, whenDraggedOver, and raycast puzzles
function getPickedObjectName(obj) {
    // auto-generated from a multi-material object, use parent name instead
    if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
        return obj.parent.name;
    } else {
        return obj.name;
    }
}



function eventGetOffsetCoords(e, touchId, dest) {
    if (e instanceof MouseEvent) {
        dest.set(e.offsetX, e.offsetY);
    } else if (window.TouchEvent && e instanceof TouchEvent) {
        var rect = e.target.getBoundingClientRect();
        var touches = e.touches;
        if (e.type == "touchstart" || e.type == "touchend" || e.type == "touchmove") {
            touches = e.changedTouches;
        }

        var touch = touches[0];
        for (var i = 0; i < touches.length; i++) {
            if (touches[i].identifier == touchId) {
                touch = touches[i];
                break;
            }
        }

        dest.set(touch.clientX - rect.left, touch.clientY - rect.top);
    }
    return dest;
}



function eventTouchIdGetFirst(e) {
    if (e instanceof MouseEvent) {
        return -1;
    } else if (window.TouchEvent && e instanceof TouchEvent) {
        if (e.type == "touchstart" || e.type == "touchend" || e.type == "touchmove") {
            return e.changedTouches[0].identifier;
        } else {
            return e.touches[0].identifier;
        }
    }
    return -1;
}



/**
 * For "touchstart", "touchend" and "touchmove" events returns true if a touch
 * object with the provided touch id is in the changedTouches array, otherwise
 * - false. For other events returns true.
 */
function eventTouchIdChangedFilter(e, touchId) {
    if (window.TouchEvent && e instanceof TouchEvent) {
        if (e.type == "touchstart" || e.type == "touchend" || e.type == "touchmove") {
            var isChanged = false;
            for (var i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier == touchId) {
                    isChanged = true;
                    break;
                }
            }
            return isChanged;
        }
    }

    return true;
}



function initDragOverInfo() {
    return {
        draggedObjName: '',
        downX: 0, downY: 0,
        prevX: 0, prevY: 0,
        currX: 0, currY: 0,
        isDowned: false,
        isMoved: false,
        touchId: -1
    };
}



// whenDraggedOver puzzle
_pGlob.objDragOverInfoGlobal = [];
_pGlob.objDragOverInfoByBlock = {}

initObjectPicking(function(intersects, downEvent) {

    _pGlob.objDragOverInfoGlobal.forEach(function(el) {

        if (downEvent instanceof MouseEvent)
            if (el.mouseButtons.indexOf(downEvent.button) == -1)
                return;

        var maxIntersects = el.xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);

            if (objectsIncludeObj([el.objName], objName)) {
                el.callback({ downEvent: downEvent, draggedObjName: objName });
            }

        }

    });

}, 'mousedown', true);



// whenDraggedOver puzzle
function registerOnDrag(objSelector, xRay, mouseButtons, cbStart, cbMove, cbDrop, blockId) {

    var cb = function(cbParam) {

        if (appInstance.controls) {
            appInstance.controls.enabled = false;
        }

        if (!(blockId in _pGlob.objDragOverInfoByBlock)) {
            _pGlob.objDragOverInfoByBlock[blockId] = initDragOverInfo();
        }
        var info = _pGlob.objDragOverInfoByBlock[blockId];

        // NOTE: don't use more than one pointing event, e.g. don't process
        // some events related to multitouch actions
        if (info.isDowned) {
            return;
        }

        var touchId = eventTouchIdGetFirst(cbParam.downEvent);
        var coords = eventGetOffsetCoords(cbParam.downEvent, touchId,
                _pGlob.vec2Tmp);

        info.downX = info.prevX = info.currX = coords.x;
        info.downY = info.prevY = info.currY = coords.y;
        info.touchId = touchId;
        info.isDowned = true;
        info.isMoved = false;
        info.draggedObjName = cbParam.draggedObjName;

        cbStart(cbParam.downEvent);

        var elem = appInstance.container;

        var moveCb = function(e) {
            if (!eventTouchIdChangedFilter(e, info.touchId)) {
                // don't handle events not intended for this particular touch
                return;
            }

            var coords = eventGetOffsetCoords(e, info.touchId, _pGlob.vec2Tmp);
            info.prevX = info.currX;
            info.prevY = info.currY;
            info.currX = coords.x;
            info.currY = coords.y;
            cbMove(e);
            info.isMoved = true;
        }
        var upCb = function(e) {
            if (!eventTouchIdChangedFilter(e, info.touchId)) {
                // don't handle events not intended for this particular touch
                return;
            }

            var coords = eventGetOffsetCoords(e, info.touchId, _pGlob.vec2Tmp);
            info.currX = coords.x;
            info.currY = coords.y;
            info.prevX = info.currX;
            info.prevY = info.currY;
            cbDrop(e);
            info.isDowned = false;

            elem.removeEventListener('mousemove', moveCb);
            elem.removeEventListener('touchmove', moveCb);
            elem.removeEventListener('mouseup', upCb);
            elem.removeEventListener('touchend', upCb);
            if (appInstance.controls) {
                appInstance.controls.enabled = true;
            }
        }

        elem.addEventListener('mousemove', moveCb);
        elem.addEventListener('touchmove', moveCb);
        elem.addEventListener('mouseup', upCb);
        elem.addEventListener('touchend', upCb);
    }

    var objNames = retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        _pGlob.objDragOverInfoGlobal.push({
            objName: objName,
            callback: cb,
            xRay: xRay,
            mouseButtons: mouseButtons
        });
    }
}


// Describe this function...
function DRAG_OBJECTS(obj) {
  registerOnDrag(obj, false, [0,1,2], function() {
    outline(obj, 'ENABLE');
  }, function() {
    dragMove(obj, 'XY', ')lwA9%AEkfaYLV^270lD', '3Kf?{81_=}r?ypP|Mj6X');
  }, function() {
    outline(obj, 'DISABLE');
  }, '3Kf?{81_=}r?ypP|Mj6X');
}

function textReplace(haystack, needle, replacement) {
  needle = needle.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1")
                 .replace(/\x08/g,"\\x08");
  return haystack.replace(new RegExp(needle, 'g'), replacement);
}


// createTextObject puzzle
function createTextObject(name, text, font, size, height, alignX, alignY, segments, bevelThickness, bevelSize, doCb) {

    var oldObj = appInstance.scene.getObjectByName(name);

    var material = new v3d.MeshStandardMaterial({
        color: 'white',
        roughness: 1.0,
        metalness: 0.0,
        side: (height == 0) ? v3d.DoubleSide : v3d.FrontSide
    });

    material.name = name + 'Material';

    var obj = new v3d.Mesh(new v3d.BufferGeometry(), material);
    obj.name = name;

    appInstance.scene.add(obj);

    // clean object cache
    _pGlob.objCache = {};

    var loader = new v3d.TTFLoader();
    loader.setCrossOrigin('Anonymous');

    v3d.loadModule('opentype.js', function() {
        loader.load(font, function(json) {

            // NOTE: fix possible double-delete errors
            if (oldObj && oldObj.parent) {
                oldObj.parent.remove(oldObj);
            }

            var font = new v3d.Font(json);

            var geometry = new v3d.TextBufferGeometry(text, {

                font: font,

                size: size,
                height: height,
                curveSegments: segments,

                bevelThickness: bevelThickness,
                bevelSize: bevelSize,
                bevelEnabled: (bevelSize > 0 || bevelThickness > 0),

                alignX: alignX,
                alignY: alignY

            });

            obj.geometry = geometry;

            doCb(obj);
        });
    }, function() {
        console.error('create text object: opentype.js module not found, please copy it to your app directory');
    });

}


// Describe this function...
function MAKE_TEXT_OBJECTS_AND_HITBOXES(text_object_name, text_color, text_font, text_vertical) {
  createTextObject(text_object_name, textReplace(text_object_name, '_', ' '), text_font, 1, 0, 'center', 'center', 10, 0, 0, function() {});
  hitbox_name = String(text_object_name) + '_hitbox';
  createObject('PLANE', hitbox_name, 25, 1, 0, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
  setObjTransform(hitbox_name, 'position', '', -0.25, '', false);
  var VARS = Object.defineProperties({}, {
    "text_object_name": { get: function() { return text_object_name; }, set: function(val) { text_object_name = val; } },
    "text_vertical": { get: function() { return text_vertical; }, set: function(val) { text_vertical = val; } },
    "text_material": { get: function() { return text_material; }, set: function(val) { text_material = val; } },
    "text_color": { get: function() { return text_color; }, set: function(val) { text_color = val; } },
    "obj": { get: function() { return obj; }, set: function(val) { obj = val; } },
    "text_font": { get: function() { return text_font; }, set: function(val) { text_font = val; } },
    "save_object": { get: function() { return save_object; }, set: function(val) { save_object = val; } },
    "loaded_DICTIONARY": { get: function() { return loaded_DICTIONARY; }, set: function(val) { loaded_DICTIONARY = val; } },
    "DICT_load_object": { get: function() { return DICT_load_object; }, set: function(val) { DICT_load_object = val; } },
    "current_color": { get: function() { return current_color; }, set: function(val) { current_color = val; } },
    "current_object": { get: function() { return current_object; }, set: function(val) { current_object = val; } },
    "LIST_text_items": { get: function() { return LIST_text_items; }, set: function(val) { LIST_text_items = val; } },
    "DICT_object_colors": { get: function() { return DICT_object_colors; }, set: function(val) { DICT_object_colors = val; } },
    "textParent_scale": { get: function() { return textParent_scale; }, set: function(val) { textParent_scale = val; } },
    "EXEC_TEXT_instructions": { get: function() { return EXEC_TEXT_instructions; }, set: function(val) { EXEC_TEXT_instructions = val; } },
    "i": { get: function() { return i; }, set: function(val) { i = val; } },
    "text_item_number": { get: function() { return text_item_number; }, set: function(val) { text_item_number = val; } },
    "DICT_save_object": { get: function() { return DICT_save_object; }, set: function(val) { DICT_save_object = val; } },
    "my_saved_key": { get: function() { return my_saved_key; }, set: function(val) { my_saved_key = val; } },
    "DICT_save_all_objects": { get: function() { return DICT_save_all_objects; }, set: function(val) { DICT_save_all_objects = val; } },
    "m": { get: function() { return m; }, set: function(val) { m = val; } },
    "load_object": { get: function() { return load_object; }, set: function(val) { load_object = val; } },
    "next_color": { get: function() { return next_color; }, set: function(val) { next_color = val; } },
    "length_of_CSV": { get: function() { return length_of_CSV; }, set: function(val) { length_of_CSV = val; } },
    "LIST_keys_from_database": { get: function() { return LIST_keys_from_database; }, set: function(val) { LIST_keys_from_database = val; } },
    "LIST_text_colors": { get: function() { return LIST_text_colors; }, set: function(val) { LIST_text_colors = val; } },
    "LIST_objects": { get: function() { return LIST_objects; }, set: function(val) { LIST_objects = val; } },
    "hitbox_name": { get: function() { return hitbox_name; }, set: function(val) { hitbox_name = val; } },
    "LIST_hitboxes": { get: function() { return LIST_hitboxes; }, set: function(val) { LIST_hitboxes = val; } },
    "DICT_save_object_POSITION": { get: function() { return DICT_save_object_POSITION; }, set: function(val) { DICT_save_object_POSITION = val; } },
    "hovered_text": { get: function() { return hovered_text; }, set: function(val) { hovered_text = val; } },
    "my_dataStore": { get: function() { return my_dataStore; }, set: function(val) { my_dataStore = val; } },
    "j": { get: function() { return j; }, set: function(val) { j = val; } },
    "load_object_position": { get: function() { return load_object_position; }, set: function(val) { load_object_position = val; } },
    "my_database": { get: function() { return my_database; }, set: function(val) { my_database = val; } },
    "text_item": { get: function() { return text_item; }, set: function(val) { text_item = val; } },
    "selected_item": { get: function() { return selected_item; }, set: function(val) { selected_item = val; } },
    "DICT_save_object_ROTATION": { get: function() { return DICT_save_object_ROTATION; }, set: function(val) { DICT_save_object_ROTATION = val; } },
    "my_description": { get: function() { return my_description; }, set: function(val) { my_description = val; } },
    "load_object_rotation": { get: function() { return load_object_rotation; }, set: function(val) { load_object_rotation = val; } },
    "DICT_save_object_SCALE": { get: function() { return DICT_save_object_SCALE; }, set: function(val) { DICT_save_object_SCALE = val; } },
    "load_object_scale": { get: function() { return load_object_scale; }, set: function(val) { load_object_scale = val; } },
    "load_object_color": { get: function() { return load_object_color; }, set: function(val) { load_object_color = val; } },
    "LIST_colors": { get: function() { return LIST_colors; }, set: function(val) { LIST_colors = val; } },
    "load_object_material": { get: function() { return load_object_material; }, set: function(val) { load_object_material = val; } },
});

  Function('app', 'v3d', 'VARS', 'PROC', (('let hitbox_name = VARS[\'hitbox_name\'];' + '\n' +
  'let hitbox_Obj = app.scene.getObjectByName(hitbox_name);' + '\n' +
  'hitbox_Obj.material.opacity = 0;' + '\n' +
  'hitbox_Obj.material.transparent = true;' + '\n' +
  'hitbox_Obj.material.needsUpdate = true;' + '\n' +
  '// console.log(\'hitbox_Obj.material:\',hitbox_Obj.material);')))(appInstance, v3d, VARS, PROC);

  var VARS = Object.defineProperties({}, {
    "text_object_name": { get: function() { return text_object_name; }, set: function(val) { text_object_name = val; } },
    "text_vertical": { get: function() { return text_vertical; }, set: function(val) { text_vertical = val; } },
    "text_material": { get: function() { return text_material; }, set: function(val) { text_material = val; } },
    "text_color": { get: function() { return text_color; }, set: function(val) { text_color = val; } },
    "obj": { get: function() { return obj; }, set: function(val) { obj = val; } },
    "text_font": { get: function() { return text_font; }, set: function(val) { text_font = val; } },
    "save_object": { get: function() { return save_object; }, set: function(val) { save_object = val; } },
    "loaded_DICTIONARY": { get: function() { return loaded_DICTIONARY; }, set: function(val) { loaded_DICTIONARY = val; } },
    "DICT_load_object": { get: function() { return DICT_load_object; }, set: function(val) { DICT_load_object = val; } },
    "current_color": { get: function() { return current_color; }, set: function(val) { current_color = val; } },
    "current_object": { get: function() { return current_object; }, set: function(val) { current_object = val; } },
    "LIST_text_items": { get: function() { return LIST_text_items; }, set: function(val) { LIST_text_items = val; } },
    "DICT_object_colors": { get: function() { return DICT_object_colors; }, set: function(val) { DICT_object_colors = val; } },
    "textParent_scale": { get: function() { return textParent_scale; }, set: function(val) { textParent_scale = val; } },
    "EXEC_TEXT_instructions": { get: function() { return EXEC_TEXT_instructions; }, set: function(val) { EXEC_TEXT_instructions = val; } },
    "i": { get: function() { return i; }, set: function(val) { i = val; } },
    "text_item_number": { get: function() { return text_item_number; }, set: function(val) { text_item_number = val; } },
    "DICT_save_object": { get: function() { return DICT_save_object; }, set: function(val) { DICT_save_object = val; } },
    "my_saved_key": { get: function() { return my_saved_key; }, set: function(val) { my_saved_key = val; } },
    "DICT_save_all_objects": { get: function() { return DICT_save_all_objects; }, set: function(val) { DICT_save_all_objects = val; } },
    "m": { get: function() { return m; }, set: function(val) { m = val; } },
    "load_object": { get: function() { return load_object; }, set: function(val) { load_object = val; } },
    "next_color": { get: function() { return next_color; }, set: function(val) { next_color = val; } },
    "length_of_CSV": { get: function() { return length_of_CSV; }, set: function(val) { length_of_CSV = val; } },
    "LIST_keys_from_database": { get: function() { return LIST_keys_from_database; }, set: function(val) { LIST_keys_from_database = val; } },
    "LIST_text_colors": { get: function() { return LIST_text_colors; }, set: function(val) { LIST_text_colors = val; } },
    "LIST_objects": { get: function() { return LIST_objects; }, set: function(val) { LIST_objects = val; } },
    "hitbox_name": { get: function() { return hitbox_name; }, set: function(val) { hitbox_name = val; } },
    "LIST_hitboxes": { get: function() { return LIST_hitboxes; }, set: function(val) { LIST_hitboxes = val; } },
    "DICT_save_object_POSITION": { get: function() { return DICT_save_object_POSITION; }, set: function(val) { DICT_save_object_POSITION = val; } },
    "hovered_text": { get: function() { return hovered_text; }, set: function(val) { hovered_text = val; } },
    "my_dataStore": { get: function() { return my_dataStore; }, set: function(val) { my_dataStore = val; } },
    "j": { get: function() { return j; }, set: function(val) { j = val; } },
    "load_object_position": { get: function() { return load_object_position; }, set: function(val) { load_object_position = val; } },
    "my_database": { get: function() { return my_database; }, set: function(val) { my_database = val; } },
    "text_item": { get: function() { return text_item; }, set: function(val) { text_item = val; } },
    "selected_item": { get: function() { return selected_item; }, set: function(val) { selected_item = val; } },
    "DICT_save_object_ROTATION": { get: function() { return DICT_save_object_ROTATION; }, set: function(val) { DICT_save_object_ROTATION = val; } },
    "my_description": { get: function() { return my_description; }, set: function(val) { my_description = val; } },
    "load_object_rotation": { get: function() { return load_object_rotation; }, set: function(val) { load_object_rotation = val; } },
    "DICT_save_object_SCALE": { get: function() { return DICT_save_object_SCALE; }, set: function(val) { DICT_save_object_SCALE = val; } },
    "load_object_scale": { get: function() { return load_object_scale; }, set: function(val) { load_object_scale = val; } },
    "load_object_color": { get: function() { return load_object_color; }, set: function(val) { load_object_color = val; } },
    "LIST_colors": { get: function() { return LIST_colors; }, set: function(val) { LIST_colors = val; } },
    "load_object_material": { get: function() { return load_object_material; }, set: function(val) { load_object_material = val; } },
});

  Function('app', 'v3d', 'VARS', 'PROC', '')(appInstance, v3d, VARS, PROC);

  LIST_hitboxes.push(hitbox_name);
  makeParent(hitbox_name, text_object_name);
  makeParent(text_object_name, 'textParentEmpty');
}

function subsequenceFirstFromEnd(sequence, at2) {
  var start = 0;
  var end = sequence.length - 1 - at2 + 1;
  return sequence.slice(start, end);
}


// whenClicked puzzle
function registerOnClick(objSelector, xRay, doubleClick, mouseButtons, cbDo, cbIfMissedDo) {

    // for AR/VR
    _pGlob.objClickInfo = _pGlob.objClickInfo || [];

    _pGlob.objClickInfo.push({
        objSelector: objSelector,
        callbacks: [cbDo, cbIfMissedDo]
    });

    initObjectPicking(function(intersects, event) {

        var isPicked = false;

        var maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);
            var objNames = retrieveObjectNames(objSelector);

            if (objectsIncludeObj(objNames, objName)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = objName;
                isPicked = true;
                cbDo(event);
            }
        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo(event);
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}


// Describe this function...
function CLICK_MENU_ITEMS() {
  registerOnClick(LIST_hitboxes, false, false, [0,1,2], function() {
    OUTLINE_HITBOX();
    selected_item = subsequenceFirstFromEnd(_pGlob.pickedObject, 7);
    var VARS = Object.defineProperties({}, {
    "text_object_name": { get: function() { return text_object_name; }, set: function(val) { text_object_name = val; } },
    "text_vertical": { get: function() { return text_vertical; }, set: function(val) { text_vertical = val; } },
    "text_material": { get: function() { return text_material; }, set: function(val) { text_material = val; } },
    "text_color": { get: function() { return text_color; }, set: function(val) { text_color = val; } },
    "obj": { get: function() { return obj; }, set: function(val) { obj = val; } },
    "text_font": { get: function() { return text_font; }, set: function(val) { text_font = val; } },
    "save_object": { get: function() { return save_object; }, set: function(val) { save_object = val; } },
    "loaded_DICTIONARY": { get: function() { return loaded_DICTIONARY; }, set: function(val) { loaded_DICTIONARY = val; } },
    "DICT_load_object": { get: function() { return DICT_load_object; }, set: function(val) { DICT_load_object = val; } },
    "current_color": { get: function() { return current_color; }, set: function(val) { current_color = val; } },
    "current_object": { get: function() { return current_object; }, set: function(val) { current_object = val; } },
    "LIST_text_items": { get: function() { return LIST_text_items; }, set: function(val) { LIST_text_items = val; } },
    "DICT_object_colors": { get: function() { return DICT_object_colors; }, set: function(val) { DICT_object_colors = val; } },
    "textParent_scale": { get: function() { return textParent_scale; }, set: function(val) { textParent_scale = val; } },
    "EXEC_TEXT_instructions": { get: function() { return EXEC_TEXT_instructions; }, set: function(val) { EXEC_TEXT_instructions = val; } },
    "i": { get: function() { return i; }, set: function(val) { i = val; } },
    "text_item_number": { get: function() { return text_item_number; }, set: function(val) { text_item_number = val; } },
    "DICT_save_object": { get: function() { return DICT_save_object; }, set: function(val) { DICT_save_object = val; } },
    "my_saved_key": { get: function() { return my_saved_key; }, set: function(val) { my_saved_key = val; } },
    "DICT_save_all_objects": { get: function() { return DICT_save_all_objects; }, set: function(val) { DICT_save_all_objects = val; } },
    "m": { get: function() { return m; }, set: function(val) { m = val; } },
    "load_object": { get: function() { return load_object; }, set: function(val) { load_object = val; } },
    "next_color": { get: function() { return next_color; }, set: function(val) { next_color = val; } },
    "length_of_CSV": { get: function() { return length_of_CSV; }, set: function(val) { length_of_CSV = val; } },
    "LIST_keys_from_database": { get: function() { return LIST_keys_from_database; }, set: function(val) { LIST_keys_from_database = val; } },
    "LIST_text_colors": { get: function() { return LIST_text_colors; }, set: function(val) { LIST_text_colors = val; } },
    "LIST_objects": { get: function() { return LIST_objects; }, set: function(val) { LIST_objects = val; } },
    "hitbox_name": { get: function() { return hitbox_name; }, set: function(val) { hitbox_name = val; } },
    "LIST_hitboxes": { get: function() { return LIST_hitboxes; }, set: function(val) { LIST_hitboxes = val; } },
    "DICT_save_object_POSITION": { get: function() { return DICT_save_object_POSITION; }, set: function(val) { DICT_save_object_POSITION = val; } },
    "hovered_text": { get: function() { return hovered_text; }, set: function(val) { hovered_text = val; } },
    "my_dataStore": { get: function() { return my_dataStore; }, set: function(val) { my_dataStore = val; } },
    "j": { get: function() { return j; }, set: function(val) { j = val; } },
    "load_object_position": { get: function() { return load_object_position; }, set: function(val) { load_object_position = val; } },
    "my_database": { get: function() { return my_database; }, set: function(val) { my_database = val; } },
    "text_item": { get: function() { return text_item; }, set: function(val) { text_item = val; } },
    "selected_item": { get: function() { return selected_item; }, set: function(val) { selected_item = val; } },
    "DICT_save_object_ROTATION": { get: function() { return DICT_save_object_ROTATION; }, set: function(val) { DICT_save_object_ROTATION = val; } },
    "my_description": { get: function() { return my_description; }, set: function(val) { my_description = val; } },
    "load_object_rotation": { get: function() { return load_object_rotation; }, set: function(val) { load_object_rotation = val; } },
    "DICT_save_object_SCALE": { get: function() { return DICT_save_object_SCALE; }, set: function(val) { DICT_save_object_SCALE = val; } },
    "load_object_scale": { get: function() { return load_object_scale; }, set: function(val) { load_object_scale = val; } },
    "load_object_color": { get: function() { return load_object_color; }, set: function(val) { load_object_color = val; } },
    "LIST_colors": { get: function() { return LIST_colors; }, set: function(val) { LIST_colors = val; } },
    "load_object_material": { get: function() { return load_object_material; }, set: function(val) { load_object_material = val; } },
});

    Function('app', 'v3d', 'VARS', 'PROC', (('let selectedItem = VARS[\'selected_item\'];' + '\n' +
    'let command = `v3d.puzzles.procedures.${selectedItem}()`;' + '\n' +
    'eval(command);')))(appInstance, v3d, VARS, PROC);

  }, function() {});
}


// getObjTransform puzzle
function getObjTransform(objName, mode, coord) {
    if (!objName)
        return;
    var obj = getObjectByName(objName);
    if (!obj)
        return;

    var coordSystem = getCoordSystem();

    var transformVal;

    if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
        transformVal = eulerV3DToBlenderShortest(obj.rotation,
                _pGlob.eulerTmp);
    } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
        // Maya coordinates
        // Use separate rotation interface to fix ambiguous rotations for Maya,
        // might as well do the same for Blender/Max.

        var rotUI = RotationInterface.initObject(obj);
        transformVal = rotUI.getUserRotation(_pGlob.eulerTmp);
    } else {
        transformVal = coordsTransform(obj[mode].clone(), 'Y_UP_RIGHT',
                coordSystem, mode === 'scale');
    }

    if (mode === 'rotation') {
        transformVal.x = v3d.MathUtils.radToDeg(transformVal.x);
        transformVal.y = v3d.MathUtils.radToDeg(transformVal.y);
        transformVal.z = v3d.MathUtils.radToDeg(transformVal.z);
    }

    if (coord == 'xyz') {
        // remove order component for Euler vectors
        return transformVal.toArray().slice(0, 3);
    } else {
        return transformVal[coord];
    }
}



// getObjectMaterial puzzle
function getObjectMaterial(objSelector) {
    var objNames = retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (!obj)
            continue;

        obj = obj.resolveMultiMaterial()[0];

        if (obj.material && typeof obj.material.name == "string")
            return obj.material.name;
    }
    return '';
}



// getMaterialColor puzzle
function getMaterialColor(matName, colName, coord) {

    var colors = matGetColors(matName);
    if (colors.indexOf(colName) < 0)
        return;

    var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);

    if (mats.length) {

        var mat = mats[0];
        var color = _pGlob.colorTmp;

        if (mat.isMeshNodeMaterial) {
            var rgbIdx = mat.nodeRGBMap[colName];

            color.r = mat.nodeRGB[rgbIdx].x;
            color.g = mat.nodeRGB[rgbIdx].y;
            color.b = mat.nodeRGB[rgbIdx].z;

        } else {

            color.copy(mat[colName]);

        }

        switch (coord) {
            case 'R':
            case 'G':
            case 'B':
                return color[coord.toLowerCase()];
                break;
            case 'RGB':
                return color.toArray();
                break;
            case 'CSS_HEX':
            case 'CSS_RGB':
                color.convertLinearToSRGB();

                if (coord == 'CSS_HEX')
                    return '#' + color.getHexString();
                else
                    return color.getStyle();
                break;
        }
    }

}


// Describe this function...
function GET_DATA_FROM_OBJECTS(save_object) {
  DICT_save_object = {};
  DICT_save_object_POSITION = {};
  DICT_save_object_ROTATION = {};
  DICT_save_object_SCALE = {};
  dictSet(DICT_save_object, 'name', save_object);
  dictSet(DICT_save_object_POSITION, 'x', getObjTransform(save_object, 'position', 'x'));
  dictSet(DICT_save_object_POSITION, 'y', getObjTransform(save_object, 'position', 'y'));
  dictSet(DICT_save_object_POSITION, 'z', getObjTransform(save_object, 'position', 'z'));
  dictSet(DICT_save_object_ROTATION, 'x', getObjTransform(save_object, 'rotation', 'x'));
  dictSet(DICT_save_object_ROTATION, 'y', getObjTransform(save_object, 'rotation', 'y'));
  dictSet(DICT_save_object_ROTATION, 'z', getObjTransform(save_object, 'rotation', 'z'));
  dictSet(DICT_save_object_SCALE, 'x', getObjTransform(save_object, 'scale', 'x'));
  dictSet(DICT_save_object_SCALE, 'y', getObjTransform(save_object, 'scale', 'y'));
  dictSet(DICT_save_object_SCALE, 'z', getObjTransform(save_object, 'scale', 'z'));
  dictSet(DICT_save_object, 'position', DICT_save_object_POSITION);
  dictSet(DICT_save_object, 'rotation', DICT_save_object_ROTATION);
  dictSet(DICT_save_object, 'scale', DICT_save_object_SCALE);
  dictSet(DICT_save_object, 'color', getMaterialColor(getObjectMaterial(save_object), 'color', 'CSS_HEX'));
  return DICT_save_object;
}


function configureWebStorage() {
    return (function
//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        databaseName,
        size,
        storeName,
        description,
        driverDropdown
    )
    {
//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Configure Web Storage';
//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !databaseName ) {
            console.log('[ GLIFTEK ]: The',puzzleName,'plugin puzzle is missing an input!');
        }   else    {
            mainFunction()
            };

//________________________________________________________________________________
//  BEGIN mainFunction

// window.localForageJS = loadLocalForageJS(mainFunction);
        // mainFunction()
        function mainFunction()
        {

//________________________________________________________________________________

            window.localForageJS = loadLocalForageJS();
            console.log('loading localForageJS...');

            //  LOAD LOCAL FORAGE TO WINDOW VAR
            // window.localForageJS = loadLocalForageJS();
            // loopUntilJSLoads();
            // function loopUntilJSLoads()
            // {
            //     // if (window.localForageJS == 'undefined' || window.localForageJS == null )
            //     if ( typeof window.localForageJS == 'undefined')

            //     {
            //         console.log('window.localForageJS NOT loaded.');
            //         loopUntilJSLoads();
            //     }
            //     else
            //     {
            //         console.log('window.localForageJS:',window.localForageJS);
            //         driverCheck();
            //     }

            // };

            driverCheck();

            function  driverCheck()
            {
                // if ( typeof window.userWebStorage !== 'undefined' )
                // {
                //     console.log('Use Only ONE "Configure Web Storage" puzzle per scene.');
                // }
                // else if ( typeof window.userWebStorage == 'undefined' )
                // {

                //     if ( !window.localForageJS )
                //     {
                //         window.localForageJS = loadLocalForageJS();
                //     }

                let driverName = eval('localforage.' + driverDropdown);

                if ( localforage.supports(driverName) !== true )
                {
                    console.log('[ GLIFTEK ]: The',puzzleName,'plugin says: Driver',driverDropdown,'(',driverName,') is NOT supported by this browser.\nSwitching to IndexedDB (asyncStorage).');

                    driverName = eval('localforage.INDEXEDDB');

                    makeDB(driverName);
                }
                else
                {
                    console.log('[ GLIFTEK ]: The',puzzleName,'plugin says: Using driver',driverDropdown,'(',driverName,') is supported by this browser.');

                    makeDB(driverName);
                }

            }



            function makeDB(driverName)
            {
                window.userWebStorage = localforage.createInstance(
                {

                    driver: driverName,

                    size: size,

                    storeName: storeName,

                    name: databaseName,

                });
            };

        // };




//________________________________________________________________________________
// LOCAL FORAGE JS

function loadLocalForageJS()
{
    /*!
        localForage -- Offline Storage, Improved
        Version 1.9.0
        https://localforage.github.io/localForage
        (c) 2013-2017 Mozilla, Apache License 2.0
    */

    !function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.localforage=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c||a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){(function(a){"use strict";function c(){k=!0;for(var a,b,c=l.length;c;){for(b=l,l=[],a=-1;++a<c;)b[a]();c=l.length}k=!1}function d(a){1!==l.push(a)||k||e()}var e,f=a.MutationObserver||a.WebKitMutationObserver;if(f){var g=0,h=new f(c),i=a.document.createTextNode("");h.observe(i,{characterData:!0}),e=function(){i.data=g=++g%2}}else if(a.setImmediate||void 0===a.MessageChannel)e="document"in a&&"onreadystatechange"in a.document.createElement("script")?function(){var b=a.document.createElement("script");b.onreadystatechange=function(){c(),b.onreadystatechange=null,b.parentNode.removeChild(b),b=null},a.document.documentElement.appendChild(b)}:function(){setTimeout(c,0)};else{var j=new a.MessageChannel;j.port1.onmessage=c,e=function(){j.port2.postMessage(0)}}var k,l=[];b.exports=d}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],2:[function(a,b,c){"use strict";function d(){}function e(a){if("function"!=typeof a)throw new TypeError("resolver must be a function");this.state=s,this.queue=[],this.outcome=void 0,a!==d&&i(this,a)}function f(a,b,c){this.promise=a,"function"==typeof b&&(this.onFulfilled=b,this.callFulfilled=this.otherCallFulfilled),"function"==typeof c&&(this.onRejected=c,this.callRejected=this.otherCallRejected)}function g(a,b,c){o(function(){var d;try{d=b(c)}catch(b){return p.reject(a,b)}d===a?p.reject(a,new TypeError("Cannot resolve promise with itself")):p.resolve(a,d)})}function h(a){var b=a&&a.then;if(a&&("object"==typeof a||"function"==typeof a)&&"function"==typeof b)return function(){b.apply(a,arguments)}}function i(a,b){function c(b){f||(f=!0,p.reject(a,b))}function d(b){f||(f=!0,p.resolve(a,b))}function e(){b(d,c)}var f=!1,g=j(e);"error"===g.status&&c(g.value)}function j(a,b){var c={};try{c.value=a(b),c.status="success"}catch(a){c.status="error",c.value=a}return c}function k(a){return a instanceof this?a:p.resolve(new this(d),a)}function l(a){var b=new this(d);return p.reject(b,a)}function m(a){function b(a,b){function d(a){g[b]=a,++h!==e||f||(f=!0,p.resolve(j,g))}c.resolve(a).then(d,function(a){f||(f=!0,p.reject(j,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=new Array(e),h=0,i=-1,j=new this(d);++i<e;)b(a[i],i);return j}function n(a){function b(a){c.resolve(a).then(function(a){f||(f=!0,p.resolve(h,a))},function(a){f||(f=!0,p.reject(h,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=-1,h=new this(d);++g<e;)b(a[g]);return h}var o=a(1),p={},q=["REJECTED"],r=["FULFILLED"],s=["PENDING"];b.exports=e,e.prototype.catch=function(a){return this.then(null,a)},e.prototype.then=function(a,b){if("function"!=typeof a&&this.state===r||"function"!=typeof b&&this.state===q)return this;var c=new this.constructor(d);if(this.state!==s){g(c,this.state===r?a:b,this.outcome)}else this.queue.push(new f(c,a,b));return c},f.prototype.callFulfilled=function(a){p.resolve(this.promise,a)},f.prototype.otherCallFulfilled=function(a){g(this.promise,this.onFulfilled,a)},f.prototype.callRejected=function(a){p.reject(this.promise,a)},f.prototype.otherCallRejected=function(a){g(this.promise,this.onRejected,a)},p.resolve=function(a,b){var c=j(h,b);if("error"===c.status)return p.reject(a,c.value);var d=c.value;if(d)i(a,d);else{a.state=r,a.outcome=b;for(var e=-1,f=a.queue.length;++e<f;)a.queue[e].callFulfilled(b)}return a},p.reject=function(a,b){a.state=q,a.outcome=b;for(var c=-1,d=a.queue.length;++c<d;)a.queue[c].callRejected(b);return a},e.resolve=k,e.reject=l,e.all=m,e.race=n},{1:1}],3:[function(a,b,c){(function(b){"use strict";"function"!=typeof b.Promise&&(b.Promise=a(2))}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{2:2}],4:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(){try{if("undefined"!=typeof indexedDB)return indexedDB;if("undefined"!=typeof webkitIndexedDB)return webkitIndexedDB;if("undefined"!=typeof mozIndexedDB)return mozIndexedDB;if("undefined"!=typeof OIndexedDB)return OIndexedDB;if("undefined"!=typeof msIndexedDB)return msIndexedDB}catch(a){return}}function f(){try{if(!ua||!ua.open)return!1;var a="undefined"!=typeof openDatabase&&/(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)&&!/BlackBerry/.test(navigator.platform),b="function"==typeof fetch&&-1!==fetch.toString().indexOf("[native code");return(!a||b)&&"undefined"!=typeof indexedDB&&"undefined"!=typeof IDBKeyRange}catch(a){return!1}}function g(a,b){a=a||[],b=b||{};try{return new Blob(a,b)}catch(f){if("TypeError"!==f.name)throw f;for(var c="undefined"!=typeof BlobBuilder?BlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder?MozBlobBuilder:WebKitBlobBuilder,d=new c,e=0;e<a.length;e+=1)d.append(a[e]);return d.getBlob(b.type)}}function h(a,b){b&&a.then(function(a){b(null,a)},function(a){b(a)})}function i(a,b,c){"function"==typeof b&&a.then(b),"function"==typeof c&&a.catch(c)}function j(a){return"string"!=typeof a&&(console.warn(a+" used as a key, but it is not a string."),a=String(a)),a}function k(){if(arguments.length&&"function"==typeof arguments[arguments.length-1])return arguments[arguments.length-1]}function l(a){for(var b=a.length,c=new ArrayBuffer(b),d=new Uint8Array(c),e=0;e<b;e++)d[e]=a.charCodeAt(e);return c}function m(a){return new va(function(b){var c=a.transaction(wa,Ba),d=g([""]);c.objectStore(wa).put(d,"key"),c.onabort=function(a){a.preventDefault(),a.stopPropagation(),b(!1)},c.oncomplete=function(){var a=navigator.userAgent.match(/Chrome\/(\d+)/),c=navigator.userAgent.match(/Edge\//);b(c||!a||parseInt(a[1],10)>=43)}}).catch(function(){return!1})}function n(a){return"boolean"==typeof xa?va.resolve(xa):m(a).then(function(a){return xa=a})}function o(a){var b=ya[a.name],c={};c.promise=new va(function(a,b){c.resolve=a,c.reject=b}),b.deferredOperations.push(c),b.dbReady?b.dbReady=b.dbReady.then(function(){return c.promise}):b.dbReady=c.promise}function p(a){var b=ya[a.name],c=b.deferredOperations.pop();if(c)return c.resolve(),c.promise}function q(a,b){var c=ya[a.name],d=c.deferredOperations.pop();if(d)return d.reject(b),d.promise}function r(a,b){return new va(function(c,d){if(ya[a.name]=ya[a.name]||B(),a.db){if(!b)return c(a.db);o(a),a.db.close()}var e=[a.name];b&&e.push(a.version);var f=ua.open.apply(ua,e);b&&(f.onupgradeneeded=function(b){var c=f.result;try{c.createObjectStore(a.storeName),b.oldVersion<=1&&c.createObjectStore(wa)}catch(c){if("ConstraintError"!==c.name)throw c;console.warn('The database "'+a.name+'" has been upgraded from version '+b.oldVersion+" to version "+b.newVersion+', but the storage "'+a.storeName+'" already exists.')}}),f.onerror=function(a){a.preventDefault(),d(f.error)},f.onsuccess=function(){c(f.result),p(a)}})}function s(a){return r(a,!1)}function t(a){return r(a,!0)}function u(a,b){if(!a.db)return!0;var c=!a.db.objectStoreNames.contains(a.storeName),d=a.version<a.db.version,e=a.version>a.db.version;if(d&&(a.version!==b&&console.warn('The database "'+a.name+"\" can't be downgraded from version "+a.db.version+" to version "+a.version+"."),a.version=a.db.version),e||c){if(c){var f=a.db.version+1;f>a.version&&(a.version=f)}return!0}return!1}function v(a){return new va(function(b,c){var d=new FileReader;d.onerror=c,d.onloadend=function(c){var d=btoa(c.target.result||"");b({__local_forage_encoded_blob:!0,data:d,type:a.type})},d.readAsBinaryString(a)})}function w(a){return g([l(atob(a.data))],{type:a.type})}function x(a){return a&&a.__local_forage_encoded_blob}function y(a){var b=this,c=b._initReady().then(function(){var a=ya[b._dbInfo.name];if(a&&a.dbReady)return a.dbReady});return i(c,a,a),c}function z(a){o(a);for(var b=ya[a.name],c=b.forages,d=0;d<c.length;d++){var e=c[d];e._dbInfo.db&&(e._dbInfo.db.close(),e._dbInfo.db=null)}return a.db=null,s(a).then(function(b){return a.db=b,u(a)?t(a):b}).then(function(d){a.db=b.db=d;for(var e=0;e<c.length;e++)c[e]._dbInfo.db=d}).catch(function(b){throw q(a,b),b})}function A(a,b,c,d){void 0===d&&(d=1);try{var e=a.db.transaction(a.storeName,b);c(null,e)}catch(e){if(d>0&&(!a.db||"InvalidStateError"===e.name||"NotFoundError"===e.name))return va.resolve().then(function(){if(!a.db||"NotFoundError"===e.name&&!a.db.objectStoreNames.contains(a.storeName)&&a.version<=a.db.version)return a.db&&(a.version=a.db.version+1),t(a)}).then(function(){return z(a).then(function(){A(a,b,c,d-1)})}).catch(c);c(e)}}function B(){return{forages:[],db:null,dbReady:null,deferredOperations:[]}}function C(a){function b(){return va.resolve()}var c=this,d={db:null};if(a)for(var e in a)d[e]=a[e];var f=ya[d.name];f||(f=B(),ya[d.name]=f),f.forages.push(c),c._initReady||(c._initReady=c.ready,c.ready=y);for(var g=[],h=0;h<f.forages.length;h++){var i=f.forages[h];i!==c&&g.push(i._initReady().catch(b))}var j=f.forages.slice(0);return va.all(g).then(function(){return d.db=f.db,s(d)}).then(function(a){return d.db=a,u(d,c._defaultConfig.version)?t(d):a}).then(function(a){d.db=f.db=a,c._dbInfo=d;for(var b=0;b<j.length;b++){var e=j[b];e!==c&&(e._dbInfo.db=d.db,e._dbInfo.version=d.version)}})}function D(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.get(a);h.onsuccess=function(){var a=h.result;void 0===a&&(a=null),x(a)&&(a=w(a)),b(a)},h.onerror=function(){d(h.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function E(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.openCursor(),i=1;h.onsuccess=function(){var c=h.result;if(c){var d=c.value;x(d)&&(d=w(d));var e=a(d,c.key,i++);void 0!==e?b(e):c.continue()}else b()},h.onerror=function(){d(h.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function F(a,b,c){var d=this;a=j(a);var e=new va(function(c,e){var f;d.ready().then(function(){return f=d._dbInfo,"[object Blob]"===za.call(b)?n(f.db).then(function(a){return a?b:v(b)}):b}).then(function(b){A(d._dbInfo,Ba,function(f,g){if(f)return e(f);try{var h=g.objectStore(d._dbInfo.storeName);null===b&&(b=void 0);var i=h.put(b,a);g.oncomplete=function(){void 0===b&&(b=null),c(b)},g.onabort=g.onerror=function(){var a=i.error?i.error:i.transaction.error;e(a)}}catch(a){e(a)}})}).catch(e)});return h(e,c),e}function G(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Ba,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.delete(a);f.oncomplete=function(){b()},f.onerror=function(){d(h.error)},f.onabort=function(){var a=h.error?h.error:h.transaction.error;d(a)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function H(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Ba,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.clear();e.oncomplete=function(){a()},e.onabort=e.onerror=function(){var a=g.error?g.error:g.transaction.error;c(a)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function I(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Aa,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.count();g.onsuccess=function(){a(g.result)},g.onerror=function(){c(g.error)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function J(a,b){var c=this,d=new va(function(b,d){if(a<0)return void b(null);c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=!1,i=g.openKeyCursor();i.onsuccess=function(){var c=i.result;if(!c)return void b(null);0===a?b(c.key):h?b(c.key):(h=!0,c.advance(a))},i.onerror=function(){d(i.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function K(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Aa,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.openKeyCursor(),h=[];g.onsuccess=function(){var b=g.result;if(!b)return void a(h);h.push(b.key),b.continue()},g.onerror=function(){c(g.error)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function L(a,b){b=k.apply(this,arguments);var c=this.config();a="function"!=typeof a&&a||{},a.name||(a.name=a.name||c.name,a.storeName=a.storeName||c.storeName);var d,e=this;if(a.name){var f=a.name===c.name&&e._dbInfo.db,g=f?va.resolve(e._dbInfo.db):s(a).then(function(b){var c=ya[a.name],d=c.forages;c.db=b;for(var e=0;e<d.length;e++)d[e]._dbInfo.db=b;return b});d=a.storeName?g.then(function(b){if(b.objectStoreNames.contains(a.storeName)){var c=b.version+1;o(a);var d=ya[a.name],e=d.forages;b.close();for(var f=0;f<e.length;f++){var g=e[f];g._dbInfo.db=null,g._dbInfo.version=c}return new va(function(b,d){var e=ua.open(a.name,c);e.onerror=function(a){e.result.close(),d(a)},e.onupgradeneeded=function(){e.result.deleteObjectStore(a.storeName)},e.onsuccess=function(){var a=e.result;a.close(),b(a)}}).then(function(a){d.db=a;for(var b=0;b<e.length;b++){var c=e[b];c._dbInfo.db=a,p(c._dbInfo)}}).catch(function(b){throw(q(a,b)||va.resolve()).catch(function(){}),b})}}):g.then(function(b){o(a);var c=ya[a.name],d=c.forages;b.close();for(var e=0;e<d.length;e++){d[e]._dbInfo.db=null}return new va(function(b,c){var d=ua.deleteDatabase(a.name);d.onerror=d.onblocked=function(a){var b=d.result;b&&b.close(),c(a)},d.onsuccess=function(){var a=d.result;a&&a.close(),b(a)}}).then(function(a){c.db=a;for(var b=0;b<d.length;b++)p(d[b]._dbInfo)}).catch(function(b){throw(q(a,b)||va.resolve()).catch(function(){}),b})})}else d=va.reject("Invalid arguments");return h(d,b),d}function M(){return"function"==typeof openDatabase}function N(a){var b,c,d,e,f,g=.75*a.length,h=a.length,i=0;"="===a[a.length-1]&&(g--,"="===a[a.length-2]&&g--);var j=new ArrayBuffer(g),k=new Uint8Array(j);for(b=0;b<h;b+=4)c=Da.indexOf(a[b]),d=Da.indexOf(a[b+1]),e=Da.indexOf(a[b+2]),f=Da.indexOf(a[b+3]),k[i++]=c<<2|d>>4,k[i++]=(15&d)<<4|e>>2,k[i++]=(3&e)<<6|63&f;return j}function O(a){var b,c=new Uint8Array(a),d="";for(b=0;b<c.length;b+=3)d+=Da[c[b]>>2],d+=Da[(3&c[b])<<4|c[b+1]>>4],d+=Da[(15&c[b+1])<<2|c[b+2]>>6],d+=Da[63&c[b+2]];return c.length%3==2?d=d.substring(0,d.length-1)+"=":c.length%3==1&&(d=d.substring(0,d.length-2)+"=="),d}function P(a,b){var c="";if(a&&(c=Ua.call(a)),a&&("[object ArrayBuffer]"===c||a.buffer&&"[object ArrayBuffer]"===Ua.call(a.buffer))){var d,e=Ga;a instanceof ArrayBuffer?(d=a,e+=Ia):(d=a.buffer,"[object Int8Array]"===c?e+=Ka:"[object Uint8Array]"===c?e+=La:"[object Uint8ClampedArray]"===c?e+=Ma:"[object Int16Array]"===c?e+=Na:"[object Uint16Array]"===c?e+=Pa:"[object Int32Array]"===c?e+=Oa:"[object Uint32Array]"===c?e+=Qa:"[object Float32Array]"===c?e+=Ra:"[object Float64Array]"===c?e+=Sa:b(new Error("Failed to get type for BinaryArray"))),b(e+O(d))}else if("[object Blob]"===c){var f=new FileReader;f.onload=function(){var c=Ea+a.type+"~"+O(this.result);b(Ga+Ja+c)},f.readAsArrayBuffer(a)}else try{b(JSON.stringify(a))}catch(c){console.error("Couldn't convert value into a JSON string: ",a),b(null,c)}}function Q(a){if(a.substring(0,Ha)!==Ga)return JSON.parse(a);var b,c=a.substring(Ta),d=a.substring(Ha,Ta);if(d===Ja&&Fa.test(c)){var e=c.match(Fa);b=e[1],c=c.substring(e[0].length)}var f=N(c);switch(d){case Ia:return f;case Ja:return g([f],{type:b});case Ka:return new Int8Array(f);case La:return new Uint8Array(f);case Ma:return new Uint8ClampedArray(f);case Na:return new Int16Array(f);case Pa:return new Uint16Array(f);case Oa:return new Int32Array(f);case Qa:return new Uint32Array(f);case Ra:return new Float32Array(f);case Sa:return new Float64Array(f);default:throw new Error("Unkown type: "+d)}}function R(a,b,c,d){a.executeSql("CREATE TABLE IF NOT EXISTS "+b.storeName+" (id INTEGER PRIMARY KEY, key unique, value)",[],c,d)}function S(a){var b=this,c={db:null};if(a)for(var d in a)c[d]="string"!=typeof a[d]?a[d].toString():a[d];var e=new va(function(a,d){try{c.db=openDatabase(c.name,String(c.version),c.description,c.size)}catch(a){return d(a)}c.db.transaction(function(e){R(e,c,function(){b._dbInfo=c,a()},function(a,b){d(b)})},d)});return c.serializer=Va,e}function T(a,b,c,d,e,f){a.executeSql(c,d,e,function(a,g){g.code===g.SYNTAX_ERR?a.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?",[b.storeName],function(a,h){h.rows.length?f(a,g):R(a,b,function(){a.executeSql(c,d,e,f)},f)},f):f(a,g)},f)}function U(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT * FROM "+e.storeName+" WHERE key = ? LIMIT 1",[a],function(a,c){var d=c.rows.length?c.rows.item(0).value:null;d&&(d=e.serializer.deserialize(d)),b(d)},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function V(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT * FROM "+e.storeName,[],function(c,d){for(var f=d.rows,g=f.length,h=0;h<g;h++){var i=f.item(h),j=i.value;if(j&&(j=e.serializer.deserialize(j)),void 0!==(j=a(j,i.key,h+1)))return void b(j)}b()},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function W(a,b,c,d){var e=this;a=j(a);var f=new va(function(f,g){e.ready().then(function(){void 0===b&&(b=null);var h=b,i=e._dbInfo;i.serializer.serialize(b,function(b,j){j?g(j):i.db.transaction(function(c){T(c,i,"INSERT OR REPLACE INTO "+i.storeName+" (key, value) VALUES (?, ?)",[a,b],function(){f(h)},function(a,b){g(b)})},function(b){if(b.code===b.QUOTA_ERR){if(d>0)return void f(W.apply(e,[a,h,c,d-1]));g(b)}})})}).catch(g)});return h(f,c),f}function X(a,b,c){return W.apply(this,[a,b,c,1])}function Y(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"DELETE FROM "+e.storeName+" WHERE key = ?",[a],function(){b()},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function Z(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"DELETE FROM "+d.storeName,[],function(){a()},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function $(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"SELECT COUNT(key) as c FROM "+d.storeName,[],function(b,c){var d=c.rows.item(0).c;a(d)},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function _(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT key FROM "+e.storeName+" WHERE id = ? LIMIT 1",[a+1],function(a,c){var d=c.rows.length?c.rows.item(0).key:null;b(d)},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function aa(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"SELECT key FROM "+d.storeName,[],function(b,c){for(var d=[],e=0;e<c.rows.length;e++)d.push(c.rows.item(e).key);a(d)},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function ba(a){return new va(function(b,c){a.transaction(function(d){d.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'",[],function(c,d){for(var e=[],f=0;f<d.rows.length;f++)e.push(d.rows.item(f).name);b({db:a,storeNames:e})},function(a,b){c(b)})},function(a){c(a)})})}function ca(a,b){b=k.apply(this,arguments);var c=this.config();a="function"!=typeof a&&a||{},a.name||(a.name=a.name||c.name,a.storeName=a.storeName||c.storeName);var d,e=this;return d=a.name?new va(function(b){var d;d=a.name===c.name?e._dbInfo.db:openDatabase(a.name,"","",0),b(a.storeName?{db:d,storeNames:[a.storeName]}:ba(d))}).then(function(a){return new va(function(b,c){a.db.transaction(function(d){function e(a){return new va(function(b,c){d.executeSql("DROP TABLE IF EXISTS "+a,[],function(){b()},function(a,b){c(b)})})}for(var f=[],g=0,h=a.storeNames.length;g<h;g++)f.push(e(a.storeNames[g]));va.all(f).then(function(){b()}).catch(function(a){c(a)})},function(a){c(a)})})}):va.reject("Invalid arguments"),h(d,b),d}function da(){try{return"undefined"!=typeof localStorage&&"setItem"in localStorage&&!!localStorage.setItem}catch(a){return!1}}function ea(a,b){var c=a.name+"/";return a.storeName!==b.storeName&&(c+=a.storeName+"/"),c}function fa(){var a="_localforage_support_test";try{return localStorage.setItem(a,!0),localStorage.removeItem(a),!1}catch(a){return!0}}function ga(){return!fa()||localStorage.length>0}function ha(a){var b=this,c={};if(a)for(var d in a)c[d]=a[d];return c.keyPrefix=ea(a,b._defaultConfig),ga()?(b._dbInfo=c,c.serializer=Va,va.resolve()):va.reject()}function ia(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo.keyPrefix,c=localStorage.length-1;c>=0;c--){var d=localStorage.key(c);0===d.indexOf(a)&&localStorage.removeItem(d)}});return h(c,a),c}function ja(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo,d=localStorage.getItem(b.keyPrefix+a);return d&&(d=b.serializer.deserialize(d)),d});return h(d,b),d}function ka(a,b){var c=this,d=c.ready().then(function(){for(var b=c._dbInfo,d=b.keyPrefix,e=d.length,f=localStorage.length,g=1,h=0;h<f;h++){var i=localStorage.key(h);if(0===i.indexOf(d)){var j=localStorage.getItem(i);if(j&&(j=b.serializer.deserialize(j)),void 0!==(j=a(j,i.substring(e),g++)))return j}}});return h(d,b),d}function la(a,b){var c=this,d=c.ready().then(function(){var b,d=c._dbInfo;try{b=localStorage.key(a)}catch(a){b=null}return b&&(b=b.substring(d.keyPrefix.length)),b});return h(d,b),d}function ma(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo,c=localStorage.length,d=[],e=0;e<c;e++){var f=localStorage.key(e);0===f.indexOf(a.keyPrefix)&&d.push(f.substring(a.keyPrefix.length))}return d});return h(c,a),c}function na(a){var b=this,c=b.keys().then(function(a){return a.length});return h(c,a),c}function oa(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo;localStorage.removeItem(b.keyPrefix+a)});return h(d,b),d}function pa(a,b,c){var d=this;a=j(a);var e=d.ready().then(function(){void 0===b&&(b=null);var c=b;return new va(function(e,f){var g=d._dbInfo;g.serializer.serialize(b,function(b,d){if(d)f(d);else try{localStorage.setItem(g.keyPrefix+a,b),e(c)}catch(a){"QuotaExceededError"!==a.name&&"NS_ERROR_DOM_QUOTA_REACHED"!==a.name||f(a),f(a)}})})});return h(e,c),e}function qa(a,b){if(b=k.apply(this,arguments),a="function"!=typeof a&&a||{},!a.name){var c=this.config();a.name=a.name||c.name,a.storeName=a.storeName||c.storeName}var d,e=this;return d=a.name?new va(function(b){b(a.storeName?ea(a,e._defaultConfig):a.name+"/")}).then(function(a){for(var b=localStorage.length-1;b>=0;b--){var c=localStorage.key(b);0===c.indexOf(a)&&localStorage.removeItem(c)}}):va.reject("Invalid arguments"),h(d,b),d}function ra(a,b){a[b]=function(){var c=arguments;return a.ready().then(function(){return a[b].apply(a,c)})}}function sa(){for(var a=1;a<arguments.length;a++){var b=arguments[a];if(b)for(var c in b)b.hasOwnProperty(c)&&($a(b[c])?arguments[0][c]=b[c].slice():arguments[0][c]=b[c])}return arguments[0]}var ta="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},ua=e();"undefined"==typeof Promise&&a(3);var va=Promise,wa="local-forage-detect-blob-support",xa=void 0,ya={},za=Object.prototype.toString,Aa="readonly",Ba="readwrite",Ca={_driver:"asyncStorage",_initStorage:C,_support:f(),iterate:E,getItem:D,setItem:F,removeItem:G,clear:H,length:I,key:J,keys:K,dropInstance:L},Da="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",Ea="~~local_forage_type~",Fa=/^~~local_forage_type~([^~]+)~/,Ga="__lfsc__:",Ha=Ga.length,Ia="arbf",Ja="blob",Ka="si08",La="ui08",Ma="uic8",Na="si16",Oa="si32",Pa="ur16",Qa="ui32",Ra="fl32",Sa="fl64",Ta=Ha+Ia.length,Ua=Object.prototype.toString,Va={serialize:P,deserialize:Q,stringToBuffer:N,bufferToString:O},Wa={_driver:"webSQLStorage",_initStorage:S,_support:M(),iterate:V,getItem:U,setItem:X,removeItem:Y,clear:Z,length:$,key:_,keys:aa,dropInstance:ca},Xa={_driver:"localStorageWrapper",_initStorage:ha,_support:da(),iterate:ka,getItem:ja,setItem:pa,removeItem:oa,clear:ia,length:na,key:la,keys:ma,dropInstance:qa},Ya=function(a,b){return a===b||"number"==typeof a&&"number"==typeof b&&isNaN(a)&&isNaN(b)},Za=function(a,b){for(var c=a.length,d=0;d<c;){if(Ya(a[d],b))return!0;d++}return!1},$a=Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)},_a={},ab={},bb={INDEXEDDB:Ca,WEBSQL:Wa,LOCALSTORAGE:Xa},cb=[bb.INDEXEDDB._driver,bb.WEBSQL._driver,bb.LOCALSTORAGE._driver],db=["dropInstance"],eb=["clear","getItem","iterate","key","keys","length","removeItem","setItem"].concat(db),fb={description:"",driver:cb.slice(),name:"localforage",size:4980736,storeName:"keyvaluepairs",version:1},gb=function(){function a(b){d(this,a);for(var c in bb)if(bb.hasOwnProperty(c)){var e=bb[c],f=e._driver;this[c]=f,_a[f]||this.defineDriver(e)}this._defaultConfig=sa({},fb),this._config=sa({},this._defaultConfig,b),this._driverSet=null,this._initDriver=null,this._ready=!1,this._dbInfo=null,this._wrapLibraryMethodsWithReady(),this.setDriver(this._config.driver).catch(function(){})}return a.prototype.config=function(a){if("object"===(void 0===a?"undefined":ta(a))){if(this._ready)return new Error("Can't call config() after localforage has been used.");for(var b in a){if("storeName"===b&&(a[b]=a[b].replace(/\W/g,"_")),"version"===b&&"number"!=typeof a[b])return new Error("Database version must be a number.");this._config[b]=a[b]}return!("driver"in a&&a.driver)||this.setDriver(this._config.driver)}return"string"==typeof a?this._config[a]:this._config},a.prototype.defineDriver=function(a,b,c){var d=new va(function(b,c){try{var d=a._driver,e=new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");if(!a._driver)return void c(e);for(var f=eb.concat("_initStorage"),g=0,i=f.length;g<i;g++){var j=f[g];if((!Za(db,j)||a[j])&&"function"!=typeof a[j])return void c(e)}(function(){for(var b=function(a){return function(){var b=new Error("Method "+a+" is not implemented by the current driver"),c=va.reject(b);return h(c,arguments[arguments.length-1]),c}},c=0,d=db.length;c<d;c++){var e=db[c];a[e]||(a[e]=b(e))}})();var k=function(c){_a[d]&&console.info("Redefining LocalForage driver: "+d),_a[d]=a,ab[d]=c,b()};"_support"in a?a._support&&"function"==typeof a._support?a._support().then(k,c):k(!!a._support):k(!0)}catch(a){c(a)}});return i(d,b,c),d},a.prototype.driver=function(){return this._driver||null},a.prototype.getDriver=function(a,b,c){var d=_a[a]?va.resolve(_a[a]):va.reject(new Error("Driver not found."));return i(d,b,c),d},a.prototype.getSerializer=function(a){var b=va.resolve(Va);return i(b,a),b},a.prototype.ready=function(a){var b=this,c=b._driverSet.then(function(){return null===b._ready&&(b._ready=b._initDriver()),b._ready});return i(c,a,a),c},a.prototype.setDriver=function(a,b,c){function d(){g._config.driver=g.driver()}function e(a){return g._extend(a),d(),g._ready=g._initStorage(g._config),g._ready}function f(a){return function(){function b(){for(;c<a.length;){var f=a[c];return c++,g._dbInfo=null,g._ready=null,g.getDriver(f).then(e).catch(b)}d();var h=new Error("No available storage method found.");return g._driverSet=va.reject(h),g._driverSet}var c=0;return b()}}var g=this;$a(a)||(a=[a]);var h=this._getSupportedDrivers(a),j=null!==this._driverSet?this._driverSet.catch(function(){return va.resolve()}):va.resolve();return this._driverSet=j.then(function(){var a=h[0];return g._dbInfo=null,g._ready=null,g.getDriver(a).then(function(a){g._driver=a._driver,d(),g._wrapLibraryMethodsWithReady(),g._initDriver=f(h)})}).catch(function(){d();var a=new Error("No available storage method found.");return g._driverSet=va.reject(a),g._driverSet}),i(this._driverSet,b,c),this._driverSet},a.prototype.supports=function(a){return!!ab[a]},a.prototype._extend=function(a){sa(this,a)},a.prototype._getSupportedDrivers=function(a){for(var b=[],c=0,d=a.length;c<d;c++){var e=a[c];this.supports(e)&&b.push(e)}return b},a.prototype._wrapLibraryMethodsWithReady=function(){for(var a=0,b=eb.length;a<b;a++)ra(this,eb[a])},a.prototype.createInstance=function(b){return new a(b)},a}(),hb=new gb;b.exports=hb},{3:3}]},{},[4])(4)});


};  //  END LoadLocalForageJS

//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function CONFIG_WEB_STORAGE() {

          configureWebStorage
          (
              my_database,
              4980736,
              my_dataStore,
              my_description,
              'INDEXEDDB',
          );}


// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {
    var camera = appInstance.getCamera();

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = coordsTransform(worldPos, getCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = coordsTransform(worldTarget, getCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(worldPos);
        }
        camera.position.copy(worldPos);
        camera.lookAt(worldTarget);
        doSlot();
    }
}



// objConstraintAddLimit puzzle
function objConstraintAddLimit(constraintName, objSelector, mode, min, max) {
    var objNames = retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        if (!objName) continue;

        var obj = getObjectByName(objName);
        if (!obj || !obj.constraints) continue;

        for (var j = obj.constraints.length - 1; j >= 0; j--) {
            if (obj.constraints[j].name == constraintName) {
                obj.constraints.splice(j, 1);
            }
        }

        var coordSystem = getCoordSystem();

        switch (mode) {
            case 'POS_X':
            case 'POS_Y':
            case 'POS_Z':
                var cons = new v3d.LimitLocationConstraint();
                cons.name = constraintName;

                if (coordSystem == 'Z_UP_RIGHT')
                    var compIndex = mode == 'POS_X' ? 0 : (mode == 'POS_Y' ? 2 : 1);
                else
                    var compIndex = mode == 'POS_X' ? 0 : (mode == 'POS_Y' ? 1 : 2);

                // swizzle sign and limits order
                if (coordSystem == 'Z_UP_RIGHT' && mode == 'POS_Y') {
                    cons.min.setComponent(compIndex, -max);
                    cons.max.setComponent(compIndex, -min);
                } else {
                    cons.min.setComponent(compIndex, min);
                    cons.max.setComponent(compIndex, max);
                }
                obj.constraints.push(cons);
                break;

            case 'ROT_X':
            case 'ROT_Y':
            case 'ROT_Z':
                var cons = new v3d.LimitRotationConstraint();
                cons.name = constraintName;

                if (coordSystem == 'Z_UP_RIGHT')
                    cons.axis = mode == 'ROT_X' ? 'X' : (mode == 'ROT_Y' ? 'Z' : 'Y');
                else
                    cons.axis = mode == 'ROT_X' ? 'X' : (mode == 'ROT_Y' ? 'Y' : 'Z');

                // swizzle sign and limits order
                if (coordSystem == 'Z_UP_RIGHT' && mode == 'ROT_Y') {
                    cons.min = v3d.Math.degToRad(-max);
                    cons.max = v3d.Math.degToRad(-min);
                } else {
                    cons.min = v3d.Math.degToRad(min);
                    cons.max = v3d.Math.degToRad(max);
                }

                obj.constraints.push(cons);
                break;

            case 'SCALE_X':
            case 'SCALE_Y':
            case 'SCALE_Z':
                var cons = new v3d.LimitScaleConstraint();
                cons.name = constraintName;

                if (coordSystem == 'Z_UP_RIGHT')
                    var compIndex = mode == 'SCALE_X' ? 0 : (mode == 'SCALE_Y' ? 2 : 1);
                else
                    var compIndex = mode == 'SCALE_X' ? 0 : (mode == 'SCALE_Y' ? 1 : 2);

                cons.min.setComponent(compIndex, min);
                cons.max.setComponent(compIndex, max);
                obj.constraints.push(cons);
                break;
        }
    }
}


// Describe this function...
function SET_CONSTRAINTS() {
  setObjTransform('textParentEmpty', 'position', '', 10, 11, false);
  tweenCamera('', 'Camera_Target', 0, function() {}, 0);
  objConstraintAddLimit('myConst1', LIST_objects, 'POS_X', -8, 8);
  objConstraintAddLimit('myConst2', LIST_objects, 'POS_Y', -8, 8);
}


// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}



// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}



// whenHovered puzzle
initObjectPicking(function(intersects, event) {

    var prevHovered = _pGlob.hoveredObject;
    var currHovered = '';

    // search for closest hovered object

    var lastIntersectIndex = Infinity;
    _pGlob.objHoverInfo.forEach(function(el) {
        var maxIntersects = el.xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);

            if (objectsIncludeObj(retrieveObjectNames(el.objSelector), objName) && i <= lastIntersectIndex) {
                currHovered = objName;
                lastIntersectIndex = i;
            }
        }
    });

    if (prevHovered == currHovered) return;

    // first - all "out" callbacks, then - all "over"
    _pGlob.objHoverInfo.forEach(function(el) {
        if (objectsIncludeObj(retrieveObjectNames(el.objSelector), prevHovered)) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = prevHovered;
            el.callbacks[1](event);
        }
    });

    _pGlob.objHoverInfo.forEach(function(el) {
        if (objectsIncludeObj(retrieveObjectNames(el.objSelector), currHovered)) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = currHovered;
            el.callbacks[0](event);
        }
    });

    _pGlob.hoveredObject = currHovered;
}, 'mousemove', false);



// whenHovered puzzle
function registerOnHover(objSelector, xRay, cbOver, cbOut) {

    _pGlob.objHoverInfo = _pGlob.objHoverInfo || [];

    _pGlob.objHoverInfo.push({
        objSelector: objSelector,
        callbacks: [cbOver, cbOut],
        xRay: xRay
    });
}


// Describe this function...
function HOVER_MENU_ITEMS() {
  registerOnHover(LIST_hitboxes, false, function() {
    setHTMLElemStyle('cursor', 'pointer', ['CONTAINER'], false);
    outline(_pGlob.hoveredObject, 'ENABLE');
  }, function() {
    setHTMLElemStyle('cursor', 'default', ['CONTAINER'], false);
    outline(_pGlob.hoveredObject, 'DISABLE');
  });
}

// Describe this function...
function SET_DATABASE_NAME_VARS() {
  my_saved_key = 'all_objects_data_save_01';
  my_dataStore = 'myDataStore_01';
  my_database = 'myAppsDatabase';
  my_description = ('GLIFTEK Web Storage plugin demo.' + '\n' +
  'Saves objects data to browser storage for later retrivial.');
}


// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}


// Describe this function...
function OUTLINE_HITBOX() {
  outline(_pGlob.pickedObject, 'DISABLE');
  registerSetTimeout(0.15, function() {
    outline(_pGlob.pickedObject, 'ENABLE');
  });
}


// dictGet puzzle
function dictGet(dict, key) {
    if (dict && typeof dict == 'object')
        return dict[key];
}


// Describe this function...
function CLICK_OBJECTS() {
  registerOnClick(LIST_objects, false, false, [0,1,2], function() {
    setMaterialColor(getObjectMaterial(_pGlob.pickedObject), 'color', 0, 0, 0, NEXT_COLOR(dictGet(DICT_object_colors, _pGlob.pickedObject), _pGlob.pickedObject));
  }, function() {});
}

// Describe this function...
function SAVE_OBJECT_DATA() {
  DICT_save_all_objects = {};
  for (var j_index in LIST_objects) {
    j = LIST_objects[j_index];
    dictSet(DICT_save_all_objects, j, GET_DATA_FROM_OBJECTS(j));
  }
  return DICT_save_all_objects;
}


function setKeyToWebStorage() {
    return (function
//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        key,
        value,
        storeName,
        databaseName,
    )
    {
//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Set Key (to web storage dataStore)';
//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !key ) {
            console.log('[ GLIFTEK ]: The',puzzleName,'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

        function mainFunction()
        {

//________________________________________________________________________________

            config();
            function config()
            {
                if ( typeof window.userWebStorage !== 'undefined' )
                {
                    window.userWebStorage.config(
                    {
                        name: databaseName,
                        storeName: storeName,
                    })

                    saveItems();
                }
                else
                {
                    const message = ('[ GLIFTEK Plugins ] - ' + puzzleName + ':\nA "Configure Web Storage" puzzle is needed before\nusing this plugin.');
                    console.log(message);
                    alert(message);
                }

            };



            function saveItems()
            {

                window.userWebStorage.setItem(key, value)
                .then(function()
                {

                    console.log(value,'saved to web storage.' );

                })
                .catch(function(err)
                {
                    // This code runs if there were any errors

                    console.log(err);

                    console.log('web storage failed to save.');
                });

            };

//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function SAVE_KEY() {
  console.log('procedure "SAVE" running.');

          setKeyToWebStorage
          (
              my_saved_key,
              SAVE_OBJECT_DATA(),
              my_dataStore,
              my_database,
          );}

// Describe this function...
function HOVER_OBJECTS() {
  registerOnHover(LIST_objects, false, function() {
    outline(_pGlob.hoveredObject, 'ENABLE');
  }, function() {
    outline(_pGlob.hoveredObject, 'DISABLE');
  });
}


function getKeyFromWebStorage() {
    return (function
//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        key,
        storeName,
        databaseName
    )
    {
//________________________________________________________________________________
//  DECLARE VARIABLES
        let returnResult;
        const puzzleName = 'Get Key (from web storage dataStore)';
//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !key ) {
            console.log('[ GLIFTEK ]: The',puzzleName,'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

        function mainFunction()
        {

//________________________________________________________________________________

            config();
            function config()
            {
                // if ( window.userLocalStorage )
                if ( typeof window.userWebStorage !== 'undefined' )
                {
                    window.userWebStorage.config(
                    {
                        name: databaseName,
                        storeName: storeName,
                    })

                    loadItems();
                }
                else
                {

                    const message = ('[ GLIFTEK Plugins ] - ' + puzzleName + ':\nA "Configure Web Storage" puzzle is needed before\nusing this plugin.');
                    console.log(message);
                    alert(message);
                }

            };


            function loadItems()
            {
                returnResult = window.userWebStorage.getItem(key)
                .then(function(value) {

                    // This code runs once the value has been loaded

                    // from the offline store.

                    if (value) {

                        console.log(key,'loaded from web storage.' );

                        return value;

                    }

                    else if (!value) {

                        console.log(key,' does not exist.');

                        return key + ' does not exist in ' + databaseName + '.';
                    };

                })
                .catch(function(err)
                {
                    // This code runs if there were any errors

                    console.log(err);

                    console.log('web storage failed to load.');
                });

            };

//________________________________________________________________________________
        };  // END mainFunction

        return returnResult;
//________________________________________________________________________________
    }).apply(null, arguments);
}



// waitPromise puzzle
_pGlob.promiseValue = '';

function waitPromise(promise, onFulfilled, onRejected) {

    if (promise) {

        promise.then(function(value) {

            window.pv = value;
            _pGlob.promiseValue = value;
            onFulfilled();

        }, function(reason) {

            _pGlob.promiseValue = reason;
            onRejected();

        });

    } else {

        _pGlob.promiseValue = 'Incorrect promise value';
        onRejected();

    }
}


// Describe this function...
function LOAD_KEY() {
  console.log('procedure "LOAD" running.');
  waitPromise(
          getKeyFromWebStorage
          (
              my_saved_key,
              my_dataStore,
              my_database,
          )
          , function() {
    LOAD_OBJECT_DATA(_pGlob.promiseValue);
  }, function() {
    console.log('load from local storage failed.');
  });
}

// Describe this function...
function LOAD_OBJECT_DATA(loaded_DICTIONARY) {
  for (var m_index in loaded_DICTIONARY) {
    m = loaded_DICTIONARY[m_index];
    APPLY_LOADED_DATA_TO_OBJECTS(m);
  }
}

// Describe this function...
function APPLY_LOADED_DATA_TO_OBJECTS(DICT_load_object) {
  load_object = dictGet(DICT_load_object, 'name');
  load_object_position = dictGet(DICT_load_object, 'position');
  load_object_rotation = dictGet(DICT_load_object, 'rotation');
  load_object_scale = dictGet(DICT_load_object, 'scale');
  load_object_color = dictGet(DICT_load_object, 'color');
  setObjTransform(load_object, 'position', dictGet(load_object_position, 'x'), dictGet(load_object_position, 'y'), dictGet(load_object_position, 'z'), false);
  setObjTransform(load_object, 'rotation', dictGet(load_object_rotation, 'x'), dictGet(load_object_rotation, 'y'), dictGet(load_object_rotation, 'z'), false);
  setObjTransform(load_object, 'scale', dictGet(load_object_scale, 'x'), dictGet(load_object_scale, 'y'), dictGet(load_object_scale, 'z'), false);
  load_object_material = getObjectMaterial(load_object);
  setMaterialColor(load_object_material, 'color', 0, 0, 0, load_object_color);
}

// Describe this function...
function NEXT_COLOR(current_color, current_object) {
  if (current_color == 'red') {
    next_color = 'green';
  } else if (current_color == 'green') {
    next_color = 'blue';
  } else if (current_color == 'blue') {
    next_color = 'red';
  }
  dictSet(DICT_object_colors, current_object, next_color);
  return next_color;
}


function deleteKeyFromDataStore() {
    return (function
//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        key,
        storeName,
        databaseName
    )
    {
//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Delete Key (from web storage dataStore)';
//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !key ) {
            console.log('[ GLIFTEK ]: The',puzzleName,'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

        function mainFunction()
        {

//________________________________________________________________________________


            config();
            function config()
            {

                if ( typeof window.userWebStorage !== 'undefined' )
                {
                    window.userWebStorage.config(
                    {
                        name: databaseName,
                        storeName: storeName,
                    })

                    deleteItem();
                }
                else
                {

                    const message = ('[ GLIFTEK Plugins ] - ' + puzzleName + ':\nA "Configure Web Storage" puzzle is needed before\nusing this plugin.');
                    console.log(message);
                    alert(message);
                }

            };


            function deleteItem()
            {
                window.userWebStorage.removeItem(key)
                .then(function()
                {

                    console.log(key,'deleted from web storage.' );

                })
                .catch(function(err)
                {
                    // This code runs if there were any errors

                    console.log(err);

                    console.log('web storage failed to delete',key,'.');
                });

            }


//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function DELETE_KEY() {

          deleteKeyFromDataStore
          (
              my_saved_key,
              my_database,
          );}


function clearWebStorageDatabase() {
    return (function
//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        databaseName
    )
    {
//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Clear Web Storage';
//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !databaseName ) {
            console.log('[ GLIFTEK ]: The',puzzleName,'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

        function mainFunction()
        {

//________________________________________________________________________________

            config();
            function config()
            {
                if ( typeof window.userWebStorage !== 'undefined' )
                {
                    window.userWebStorage.config(
                    {
                        name: databaseName,
                    })

                    clearDatabase();
                }
                else
                {
                    const message = ('[ GLIFTEK Plugins ] - ' + puzzleName +
                    ':\nA "Configure Web Storage" puzzle is needed before\nusing this plugin.');
                    console.log(message);
                    alert(message);
                }

            };


            function clearDatabase()
            {
                window.userWebStorage.clear()
                .then(function()
                {

                    console.log('all data cleared from', databaseName);

                })
                .catch(function(err)
                {
                    // This code runs if there were any errors

                    console.log(err);

                    console.log('web storage failed to clear.');
                });
            };


//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function CLEAR_DATABASE() {

          clearWebStorageDatabase
          (
              my_database,
          );}


function getLengthOfDataStore() {
    return (function
//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        storeName,
        databaseName
    )
    {
//________________________________________________________________________________
//  DECLARE VARIABLES
        let returnResult;
        const puzzleName = 'Get Length Of DataStore';
//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !storeName ) {
            console.log('[ GLIFTEK ]: The',puzzleName,'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

        function mainFunction()
        {

//________________________________________________________________________________

            config();
            function config()
            {
                if ( typeof window.userWebStorage !== 'undefined' )
                {
                    window.userWebStorage.config(
                    {
                        name: databaseName,
                        storeName: storeName,
                    })

                    getLengthOfDatabase();
                }
                else
                {

                    const message = ('[ GLIFTEK Plugins ] - ' + puzzleName +
                    ':\nA "Configure Web Storage" puzzle is needed before\nusing this plugin.');
                    console.log(message);
                    alert(message);
                }

            };


            function getLengthOfDatabase()
            {
                returnResult =
                window.userWebStorage.length().then(function(numberOfKeys) {
                    // Outputs the length of the database.
                    console.log('Number of key / value pairs in dataStore',storeName,'in',databaseName,'is',numberOfKeys);
                }).catch(function(err) {
                    // This code runs if there were any errors
                    console.log(err);
                    console.log('get web storage database length failed.');
                });

            };

//________________________________________________________________________________
        };  // END mainFunction

        return returnResult;
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function GET_LENGTH_OF_DATASTORE() {
  length_of_CSV =
          getLengthOfDataStore
          (
              my_dataStore,
              my_database,
          )
          ;
}


function getKeysOfDataStore() {
    return (function
//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        storeName,
        databaseName
    )
    {
//________________________________________________________________________________
//  DECLARE VARIABLES
        let returnResult;
        const puzzleName = 'Get Keys Of DataStore';
//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !storeName ) {
            console.log('[ GLIFTEK ]: The',puzzleName,'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

        function mainFunction()
        {

//________________________________________________________________________________

            config();
            function config()
            {
                if ( typeof window.userWebStorage !== 'undefined' )
                {
                    window.userWebStorage.config(
                    {
                        name: databaseName,
                        storeName: storeName,
                    })

                    getKeys();
                }
                else
                {
                    const message = ('[ GLIFTEK Plugins ] - ' + puzzleName +
                    ':\nA "Configure Web Storage" puzzle is needed before\nusing this plugin.');
                    console.log(message);
                    alert(message);
                }

            };


            function getKeys()
            {
                returnResult =
                window.userWebStorage.keys().then(function(value) {

                    console.log('keys in',storeName,':',value);
                    return value;

                })
                .catch(function(err)
                {
                    // This code runs if there were any errors

                    console.log(err);

                    console.log('get keys of web storage database failed.');
                });
            };

//________________________________________________________________________________
        };  // END mainFunction

        return returnResult;
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function GET_ALL_KEYS() {
  LIST_keys_from_database =
          getKeysOfDataStore
          (
              my_dataStore,
              my_database,
          )
          ;
  console.log('LIST_keys_from_database: ');
  console.log(LIST_keys_from_database);
}


function removeDataStore() {
    return (function
//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        dataStoreName,
        databaseName
    )
    {
//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Delete DataStore';
//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !dataStoreName ) {
            console.log('[ GLIFTEK ]: The',puzzleName,'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

        function mainFunction()
        {

//________________________________________________________________________________

            config();
            function config()
            {

                if ( typeof window.userWebStorage !== 'undefined' )
                {

                    removeStore();
                }
                else
                {

                    const message = ('[ GLIFTEK Plugins ] - ' + puzzleName + ':\nA "Configure Web Storage" puzzle is needed before\nusing this plugin.');
                    console.log(message);
                    alert(message);
                }
            };


            function removeStore()
            {
                window.userWebStorage.dropInstance({
                    name: databaseName,
                    storeName: dataStoreName,
                })
                .then(function()
                {

                    console.log('store',dataStoreName,'removed from web storage database',databaseName,'.');

                })
                .catch(function(err)
                {
                    // This code runs if there were any errors

                    console.log(err);

                    console.log('web storage failed to remove',dataStoreName,'.');
                });
            };

//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function DELETE_DATASTORE() {

          removeDataStore
          (
              my_dataStore,
              my_database,
          );}


function removeDatabaseFromWebStorage() {
    return (function
//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        databaseName
    )
    {
//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Remove Database From Web Storage';
//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !databaseName ) {
            console.log('[ GLIFTEK ]: The',puzzleName,'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

        function mainFunction()
        {

//________________________________________________________________________________

config();
            function config()
            {

                if ( typeof window.userWebStorage !== 'undefined' )
                {
                    removeDatabase()
                }
                else
                {

                    const message = ('[ GLIFTEK Plugins ] - ' + puzzleName + ':\nA "Configure Web Storage" puzzle is needed before\nusing this plugin.');
                    console.log(message);
                    alert(message);
                }

            };

            function removeDatabase()
            {
                window.userWebStorage.dropInstance({
                // localforage.dropInstance({

                    name: databaseName,
                })
                .then(function()
                {

                    console.log('database',databaseName,'removed from web storage.');

                })
                .catch(function(err)
                {
                    // This code runs if there were any errors

                    console.log(err);

                    console.log('web storage failed to remove',databaseName,'.');
                });
            };

//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function DELETE_DATABASE() {

          removeDatabaseFromWebStorage
          (
              my_database,
          );}


function iterateThroughWebStorage() {
    return (function
//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        value,
        key,
        iterationNumber,
        storeName,
        databaseName
    )
    {
//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Iterate Through Web Storage';
//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !value ) {
            console.log('[ GLIFTEK ]: The',puzzleName,'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

        function mainFunction()
        {

//________________________________________________________________________________

            console.log('key', key);
            console.log('value: ', value);
            console.log('iterationNumber: ', iterationNumber);
            console.log('storeName', storeName);
            console.log('databaseName: ', databaseName);


            window.userWebStorage.config({
                driver: localforage.LOCALSTORAGE,
                name: databaseName,
                storeName: storeName,
            })


            // The same code, but using ES6 Promises.
            window.userWebStorage.iterate(function(value, key, iterationNumber) {
                // Resulting key/value pair -- this callback
                // will be executed for every item in the
                // database.
                console.log([key, value]);
            }).then(function() {
                console.log('Iteration has completed');
            }).catch(function(err) {
                // This code runs if there were any errors
                console.log(err);
            });

            // Exit the iteration early:
            window.userWebStorage.iterate(function(value, key, iterationNumber) {
                if (iterationNumber < 3) {
                    console.log([key, value]);
                } else {
                    return [key, value];
                }
            }).then(function(result) {
                console.log('Iteration has completed, last iterated pair:');
                console.log(result);
            }).catch(function(err) {
                // This code runs if there were any errors
                console.log(err);
            });


//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function ITERATE_DATASTORE() {

          iterateThroughWebStorage
          (
              my_saved_key,
              'someValue',
              0,
              my_dataStore,
              my_database,
          );}


MAIN();



} // end of PL.init function

})(); // end of closure

/* ================================ end of code ============================= */
