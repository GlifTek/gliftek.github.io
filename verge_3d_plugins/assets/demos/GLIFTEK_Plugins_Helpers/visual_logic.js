/**
 * Generated by Verge3D Puzzles v.3.8.0 pre4
 * Tue Sep 07 2021 21:03:05 GMT-0400 (Eastern Daylight Time)
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */

'use strict';

(function() {

// global variables/constants used by puzzles' functions

var LIST_NONE = '<none>';

var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster();

var PL = v3d.PL = v3d.PL || {};

// a more readable alias for PL (stands for "Puzzle Logic")
v3d.puzzles = PL;

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        }
    }

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    var PROC = {
    
};

// initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = false;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = false;
_initGlob.output.initOptions.useFullscreen = true;

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["BATCH"] = BATCH;
this.procedures["CHANGE_EXAMPLES_LOOP"] = CHANGE_EXAMPLES_LOOP;
this.procedures["HIDE_ALL"] = HIDE_ALL;
this.procedures["CHANGE_EXAMPLE_PROCEDURE"] = CHANGE_EXAMPLE_PROCEDURE;
this.procedures["DISABLE_RENDERING"] = DISABLE_RENDERING;
this.procedures["MAKE_OBJECTS"] = MAKE_OBJECTS;
this.procedures["MAIN"] = MAIN;
this.procedures["do something"] = do_something;
this.procedures["MAKE_LIST_TEXT"] = MAKE_LIST_TEXT;
this.procedures["MAKE_LISTS"] = MAKE_LISTS;
this.procedures["MAKE_HELPERS"] = MAKE_HELPERS;
this.procedures["MAKE_GRID_CUBE"] = MAKE_GRID_CUBE;
this.procedures["MAKE_TEAPOT"] = MAKE_TEAPOT;
this.procedures["SET_MATERIALS"] = SET_MATERIALS;
this.procedures["MAKE_TORUS"] = MAKE_TORUS;
this.procedures["MAKE_GRID_POLAR"] = MAKE_GRID_POLAR;
this.procedures["MAKE_SPHERE"] = MAKE_SPHERE;
this.procedures["MAKE_OTHER_HELPERS"] = MAKE_OTHER_HELPERS;
this.procedures["MAKE_BOX"] = MAKE_BOX;

var PROC = {
    "BATCH": BATCH,
    "CHANGE_EXAMPLES_LOOP": CHANGE_EXAMPLES_LOOP,
    "HIDE_ALL": HIDE_ALL,
    "CHANGE_EXAMPLE_PROCEDURE": CHANGE_EXAMPLE_PROCEDURE,
    "DISABLE_RENDERING": DISABLE_RENDERING,
    "MAKE_OBJECTS": MAKE_OBJECTS,
    "MAIN": MAIN,
    "do something": do_something,
    "MAKE_LIST_TEXT": MAKE_LIST_TEXT,
    "MAKE_LISTS": MAKE_LISTS,
    "MAKE_HELPERS": MAKE_HELPERS,
    "MAKE_GRID_CUBE": MAKE_GRID_CUBE,
    "MAKE_TEAPOT": MAKE_TEAPOT,
    "SET_MATERIALS": SET_MATERIALS,
    "MAKE_TORUS": MAKE_TORUS,
    "MAKE_GRID_POLAR": MAKE_GRID_POLAR,
    "MAKE_SPHERE": MAKE_SPHERE,
    "MAKE_OTHER_HELPERS": MAKE_OTHER_HELPERS,
    "MAKE_BOX": MAKE_BOX,
};

var obj, obj_transparent, obj_to_show_transparent, LIST_objects, grid_Cube_color, COLOR_object_transparent, LIST_grids_Cube, grid_Cube_Center_color, COLOR_object_wireframe, obj_to_show, LIST_all_meshes, list_length, obj_number;


function addObjectsToGroup() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        addOrRemoveDropdown,
        mainInput,
        groupNameInput,
    )
    {   //  BEGIN Plug.provide Function
//________________________________________________________________________________
//  DECLARE VARIABLES

    const puzzleName = 'Add Object(s) to Group';

//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !mainInput || mainInput == '<none>' ) {
            console.log('[ GLIFTEK ]: The ',puzzleName, 'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  MAIN FUNCTION

        function mainFunction()
        {
//________________________________________________________________________________
//  PUZZLE CORE CODE


            // console.log('groupNameInput:',groupNameInput);

            groupCheck(groupNameInput);

            function groupCheck(groupNameInput)
            {

                if ( groupNameInput[0] )
                {
                    if (groupNameInput[0] == 'GROUP')
                    {
                        groupNameInput = groupNameInput[1];

                        addGroupNameToObjects(groupNameInput);
                    }

                    else if (groupNameInput[0] !== 'GROUP')
                    {
                        addGroupNameToObjects(groupNameInput);
                    }
                }
                else
                {
                    addGroupNameToObjects(groupNameInput);
                };

            };  //  END groupCheck()



            function addGroupNameToObjects(groupNameInput)
            {
                arrayCheck();

                function arrayCheck()
                {

                    //	if not array make array and insert object, name and insert to list.
                    if ( !Array.isArray(mainInput) )
                    {
                        const objArray = [];
                        objArray.push(mainInput);
                        mainLoop( objArray );
                    }

                    else if( Array.isArray(mainInput) )
                    {
                        const objArray = mainInput;
                        mainLoop( objArray );
                    }

			    };	//	END	arrayCheck


                function mainLoop( objArray )
                {

                    for (let i = 0; i < objArray.length; i++)
                    {
                        let objInput = objArray[i];

                        if (  ( objInput == null  ) || ( objInput == 'undefined'  ) )
                        {
                            console.log('[ GLIFTEK ]: The ',puzzleName,
                            'plugin puzzle is missing an input in list slot',(i + 1));
                        }


                        else if ( ( objInput instanceof v3d.Mesh ) == true )
                        {
                            const objInputObj = objInput;
                            addOrRemoveFromGroup(objInputObj)
                        }

                        else if ( ( objInput instanceof v3d.Mesh ) == false )
                        {
                            const objInputObj = app.scene.getObjectByName(objInput);
                            addOrRemoveFromGroup(objInputObj)
                        }



                        function addOrRemoveFromGroup(objInputObj)
                        {
                            if ( addOrRemoveDropdown == 'add' )
                            {
                                addGroupName(objInputObj)
                            }

                            else if ( addOrRemoveDropdown == 'remove' )
                            {
                                removeGroupName(objInputObj)
                            }
                        };



                        function addGroupName(objInputObj)
                        {
                            objInputObj.groupNames.push(groupNameInput);
                        };


                        function removeGroupName(objInputObj)
                        {
                            // console.log('objInputObj.groupNames:',objInputObj.groupNames);

                            for (let j = 0; j < objInputObj.groupNames.length; j++)
                            {
                                if ( objInputObj.groupNames[j] == groupNameInput)
                                {
                                    // console.log('groupNameInput',objInputObj.groupNames[j],
                                    // 'found in',objInputObj,'.\nRemoving object from group.');

                                    objInputObj.groupNames.pop(groupNameInput);
                                }
                                else
                                {
                                    console.log('[ GLIFTEK ]: The ',puzzleName,'plugin puzzle says',
                                    groupNameInput,'is not an existing group.');
                                }
                            };
                        };  //  END removeGroupName

                    }
                };  //  END mainLoop;
            };  //  END addGroupNameToObjects()

//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}




// utility function envoked by almost all V3D-specific puzzles
// filter off some non-mesh types
function notIgnoredObj(obj) {
    return obj.type !== 'AmbientLight' &&
           obj.name !== '' &&
           !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
           !obj.isAuxClippingMesh;
}


// utility function envoked by almost all V3D-specific puzzles
// find first occurence of the object by its name
function getObjectByName(objName) {
    var objFound;
    var runTime = _pGlob !== undefined;
    objFound = runTime ? _pGlob.objCache[objName] : null;

    if (objFound && objFound.name === objName)
        return objFound;

    appInstance.scene.traverse(function(obj) {
        if (!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
            objFound = obj;
            if (runTime) {
                _pGlob.objCache[objName] = objFound;
            }
        }
    });
    return objFound;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects on the scene
function getAllObjectNames() {
    var objNameList = [];
    appInstance.scene.traverse(function(obj) {
        if (notIgnoredObj(obj))
            objNameList.push(obj.name)
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects which belong to the group
function getObjectNamesByGroupName(targetGroupName) {
    var objNameList = [];
    appInstance.scene.traverse(function(obj){
        if (notIgnoredObj(obj)) {
            var groupNames = obj.groupNames;
            if (!groupNames)
                return;
            for (var i = 0; i < groupNames.length; i++) {
                var groupName = groupNames[i];
                if (groupName == targetGroupName) {
                    objNameList.push(obj.name);
                }
            }
        }
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// process object input, which can be either single obj or array of objects, or a group
function retrieveObjectNames(objNames) {
    var acc = [];
    retrieveObjectNamesAcc(objNames, acc);
    return acc.filter(function(name) {
        return name;
    });
}

function retrieveObjectNamesAcc(currObjNames, acc) {
    if (typeof currObjNames == "string") {
        acc.push(currObjNames);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
        var newObj = getObjectNamesByGroupName(currObjNames[1]);
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "ALL_OBJECTS") {
        var newObj = getAllObjectNames();
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames)) {
        for (var i = 0; i < currObjNames.length; i++)
            retrieveObjectNamesAcc(currObjNames[i], acc);
    }
}




// batchGeometry puzzle
function batchGeometry(objSelector) {
    var objNames = retrieveObjectNames(objSelector);
    var meshObjs = [];

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (!obj)
            continue;

        obj.resolveMultiMaterial().forEach(function(objR) {
            if (objR.isMesh && objR.geometry)
                meshObjs.push(objR);
        });

    }

    if (meshObjs.length >= 2)
        v3d.BufferGeometryUtils.batchMeshes(meshObjs, appInstance.scene);

}


// Describe this function...
function BATCH() {

          addObjectsToGroup
          (
              'add',
              ['Box', 'Box_transparent'],
              'GROUP_Box'
          )
      batchGeometry(['GROUP', 'GROUP_Box']);

          addObjectsToGroup
          (
              'add',
              ['Torus', 'Torus_transparent'],
              'GROUP_Torus'
          )
      batchGeometry(['GROUP', 'GROUP_Torus']);

          addObjectsToGroup
          (
              'add',
              ['Teapot', 'Teapot_transparent'],
              'GROUP_Teapot'
          )
      batchGeometry(['GROUP', 'GROUP_Teapot']);
}


// utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
function initObjectPicking(callback, eventType, mouseDownUseTouchStart, mouseButtons) {

    var elem = appInstance.renderer.domElement;
    elem.addEventListener(eventType, pickListener);
    if (v3d.PL.editorEventListeners)
        v3d.PL.editorEventListeners.push([elem, eventType, pickListener]);

    if (eventType == 'mousedown') {

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        elem.addEventListener(touchEventName, pickListener);
        if (v3d.PL.editorEventListeners)
            v3d.PL.editorEventListeners.push([elem, touchEventName, pickListener]);

    } else if (eventType == 'dblclick') {

        var prevTapTime = 0;

        function doubleTapCallback(event) {

            var now = new Date().getTime();
            var timesince = now - prevTapTime;

            if (timesince < 600 && timesince > 0) {

                pickListener(event);
                prevTapTime = 0;
                return;

            }

            prevTapTime = new Date().getTime();
        }

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        elem.addEventListener(touchEventName, doubleTapCallback);
        if (v3d.PL.editorEventListeners)
            v3d.PL.editorEventListeners.push([elem, touchEventName, doubleTapCallback]);
    }

    var raycaster = new v3d.Raycaster();

    function pickListener(event) {

        // to handle unload in loadScene puzzle
        if (!appInstance.getCamera())
            return;

        event.preventDefault();

        var xNorm = 0, yNorm = 0;
        if (event instanceof MouseEvent) {
            if (mouseButtons && mouseButtons.indexOf(event.button) == -1)
                return;
            xNorm = event.offsetX / elem.clientWidth;
            yNorm = event.offsetY / elem.clientHeight;
        } else if (event instanceof TouchEvent) {
            var rect = elem.getBoundingClientRect();
            xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
            yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
        }

        _pGlob.screenCoords.x = xNorm * 2 - 1;
        _pGlob.screenCoords.y = -yNorm * 2 + 1;
        raycaster.setFromCamera(_pGlob.screenCoords, appInstance.getCamera(true));
        var objList = [];
        appInstance.scene.traverse(function(obj){objList.push(obj);});
        var intersects = raycaster.intersectObjects(objList);
        callback(intersects, event);
    }
}

function objectsIncludeObj(objNames, testedObjName) {
    if (!testedObjName) return false;

    for (var i = 0; i < objNames.length; i++) {
        if (testedObjName == objNames[i]) {
            return true;
        } else {
            // also check children which are auto-generated for multi-material objects
            var obj = getObjectByName(objNames[i]);
            if (obj && obj.type == "Group") {
                for (var j = 0; j < obj.children.length; j++) {
                    if (testedObjName == obj.children[j].name) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

// utility function used by the whenClicked, whenHovered, whenDraggedOver, and raycast puzzles
function getPickedObjectName(obj) {
    // auto-generated from a multi-material object, use parent name instead
    if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
        return obj.parent.name;
    } else {
        return obj.name;
    }
}



// whenClicked puzzle
function registerOnClick(objSelector, xRay, doubleClick, mouseButtons, cbDo, cbIfMissedDo) {

    // for AR/VR
    _pGlob.objClickInfo = _pGlob.objClickInfo || [];

    _pGlob.objClickInfo.push({
        objSelector: objSelector,
        callbacks: [cbDo, cbIfMissedDo]
    });

    initObjectPicking(function(intersects, event) {

        var isPicked = false;

        var maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);
            var objNames = retrieveObjectNames(objSelector);

            if (objectsIncludeObj(objNames, objName)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = objName;
                isPicked = true;
                cbDo(event);
            }
        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo(event);
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}


// Describe this function...
function CHANGE_EXAMPLES_LOOP() {
  registerOnClick(LIST_objects, false, false, [0,1,2], function() {
    CHANGE_EXAMPLE_PROCEDURE(_pGlob.pickedObject);
  }, function() {});
}


// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
    }
}



// disableRendering puzzle
function disableRendering(enableSSAA) {
    appInstance.ssaaOnPause = enableSSAA;
    appInstance.disableRendering(1);
}


// Describe this function...
function HIDE_ALL() {
  changeVis(['ALL_OBJECTS'], false);
  disableRendering(true);
  changeVis('Teapot', true);
  changeVis('Teapot_transparent', true);
}

// Describe this function...
function CHANGE_EXAMPLE_PROCEDURE(obj) {
  obj_transparent = String(obj) + '_transparent';
  changeVis(obj, false);
  changeVis(obj_transparent, false);
  list_length = LIST_objects.length - 1;
  obj_number = LIST_objects.indexOf(obj);
  if (obj_number < list_length) {
    obj_to_show = LIST_objects[obj_number + 1];
    do_something();
  } else if (obj_number >= list_length) {
    obj_to_show = LIST_objects[0];
    do_something();
  }
}


// enableRendering puzzle
function enableRendering() {
    appInstance.enableRendering();
}



// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}



// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;
        elem.addEventListener(eventType, callback);
        if (v3d.PL.editorEventListeners)
            v3d.PL.editorEventListeners.push([elem, eventType, callback]);
    }
}


// Describe this function...
function DISABLE_RENDERING() {
  eventHTMLElem('pointerdown', ['CONTAINER'], false, function(event) {
    enableRendering();
  });
  eventHTMLElem('pointerup', ['CONTAINER'], false, function(event) {
    disableRendering(true);
  });
}


// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}


// Describe this function...
function MAKE_OBJECTS() {
  MAKE_TEAPOT();
  MAKE_TORUS();
  MAKE_BOX();
  registerSetTimeout(0.1, function() {
    SET_MATERIALS();
    HIDE_ALL();
    CHANGE_EXAMPLES_LOOP();
  });
}


function setScreenScale(factor) {

    // already have maximum pixel ratio in HiDPI mode
    if (!appInstance.useHiDPIRenderPass)
        appInstance.renderer.setPixelRatio(factor);

    if (appInstance.postprocessing)
        appInstance.postprocessing.composer.setPixelRatio(factor);

    // to update possible post-processing passes
    appInstance.onResize();
}


// Describe this function...
function MAIN() {
  setScreenScale(1.5);
  changeVis('Suzanne', false);
  MAKE_LIST_TEXT();
  MAKE_HELPERS();
  MAKE_OBJECTS();
  DISABLE_RENDERING();
}

// Describe this function...
function do_something() {
  obj_to_show_transparent = String(obj_to_show) + '_transparent';
  changeVis(obj_to_show, true);
  changeVis(obj_to_show_transparent, true);
}

// Describe this function...
function MAKE_LIST_TEXT() {
  LIST_objects = ['Teapot', 'Torus', 'Box'];
  LIST_all_meshes = ['Teapot', 'Torus', 'Box', 'Teapot_transparent', 'Torus_transparent', 'Box_transparent'];
  LIST_grids_Cube = ['gridHelper_1', 'gridHelper_2', 'gridHelper_3'];
}

// Describe this function...
function MAKE_LISTS() {
  LIST_objects = ['Teapot', 'Torus', 'Sphere'];
  LIST_grids_Cube = ['gridHelper_1', 'gridHelper_2', 'gridHelper_3'];
}

// Describe this function...
function MAKE_HELPERS() {
  MAKE_GRID_CUBE();
  MAKE_GRID_POLAR();
  MAKE_OTHER_HELPERS();
}


function createGridHelper() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        gridSize,
        divisions,
        colorGrid,
        colorCenterLine
    )
    {   //  BEGIN Plug.provide Function

//________________________________________________________________________________
//  MAIN FUNCTION

        mainFunction();
        function mainFunction()
        {
//________________________________________________________________________________
//  PUZZLE CORE CODE


            if (typeof gridHelperNumber == 'undefined')

                { window.gridHelperNumber = 1 }

            else {  gridHelperNumber++  };



            let gridHelperParent = new v3d.Object3D();

            let gridHelper = new v3d.GridHelper(gridSize, divisions, colorCenterLine, colorGrid);

            gridHelper.raycast = function() {};



            gridHelper.rotateX(v3d.Math.degToRad(-90));

            gridHelperParent.add(gridHelper);

            gridHelperParent.rotateX(v3d.Math.degToRad(-90));



            gridHelperParent.name = 'gridHelper_' + gridHelperNumber;

            app.scene.add(gridHelperParent);

//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}




/**
 * Retrieve coordinate system from the loaded scene
 */
function getCoordSystem() {
    var scene = appInstance.scene;

    if (scene && "v3d" in scene.userData && "coordSystem" in scene.userData.v3d) {
        return scene.userData.v3d.coordSystem;
    } else {
        // COMPAT: <2.17, consider replacing to 'Y_UP_RIGHT' for scenes with unknown origin
        return 'Z_UP_RIGHT';
    }
}


/**
 * Transform coordinates from one space to another
 * Can be used with Vector3 or Euler.
 */
function coordsTransform(coords, from, to, noSignChange) {

    if (from == to)
        return coords;

    var y = coords.y, z = coords.z;

    if (from == 'Z_UP_RIGHT' && to == 'Y_UP_RIGHT') {
        coords.y = z;
        coords.z = noSignChange ? y : -y;
    } else if (from == 'Y_UP_RIGHT' && to == 'Z_UP_RIGHT') {
        coords.y = noSignChange ? z : -z;
        coords.z = y;
    } else {
        console.error('coordsTransform: Unsupported coordinate space');
    }

    return coords;
}


/**
 * Verge3D euler rotation to Blender/Max shortest.
 * 1) Convert from intrinsic rotation (v3d) to extrinsic XYZ (Blender/Max default
 *    order) via reversion: XYZ -> ZYX
 * 2) swizzle ZYX->YZX
 * 3) choose the shortest rotation to resemble Blender's behavior
 */
var eulerV3DToBlenderShortest = function() {

    var eulerTmp = new v3d.Euler();
    var eulerTmp2 = new v3d.Euler();
    var vec3Tmp = new v3d.Vector3();

    return function(euler, dest) {

        var eulerBlender = eulerTmp.copy(euler).reorder('YZX');
        var eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();

        var len = eulerBlender.toVector3(vec3Tmp).lengthSq();
        var lenAlt = eulerBlenderAlt.toVector3(vec3Tmp).lengthSq();

        dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
        return coordsTransform(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
    }

}();




function RotationInterface() {
    /**
     * For user manipulations use XYZ extrinsic rotations (which
     * are the same as ZYX intrinsic rotations)
     *     - Blender/Max/Maya use extrinsic rotations in the UI
     *     - XYZ is the default option, but could be set from
     *       some order hint if exported
     */
    this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
    this._actualRotation = new v3d.Euler();
}

Object.assign(RotationInterface, {
    initObject: function(obj) {
        if (obj.userData.v3d.puzzles === undefined) {
            obj.userData.v3d.puzzles = {}
        }
        if (obj.userData.v3d.puzzles.rotationInterface === undefined) {
            obj.userData.v3d.puzzles.rotationInterface = new RotationInterface();
        }

        var rotUI = obj.userData.v3d.puzzles.rotationInterface;
        rotUI.updateFromObject(obj);
        return rotUI;
    }
});

Object.assign(RotationInterface.prototype, {

    updateFromObject: function(obj) {
        var SYNC_ROT_EPS = 1e-8;

        if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
            this._actualRotation.copy(obj.rotation);
            this._updateUserRotFromActualRot();
        }
    },

    getActualRotation: function(euler) {
        return euler.copy(this._actualRotation);
    },

    setUserRotation: function(euler) {
        // don't copy the order, since it's fixed to ZYX for now
        this._userRotation.set(euler.x, euler.y, euler.z);
        this._updateActualRotFromUserRot();
    },

    getUserRotation: function(euler) {
        return euler.copy(this._userRotation);
    },

    _updateUserRotFromActualRot: function() {
        var order = this._userRotation.order;
        this._userRotation.copy(this._actualRotation).reorder(order);
    },

    _updateActualRotFromUserRot: function() {
        var order = this._actualRotation.order;
        this._actualRotation.copy(this._userRotation).reorder(order);
    }

});




// setObjTransform puzzle
function setObjTransform(objSelector, mode, vector, offset){
    var x = vector[0];
      var y = vector[1];
      var z = vector[2];

    var objNames = retrieveObjectNames(objSelector);

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    var inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''),
            Number(z !== ''));
    var coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.MathUtils.DEG2RAD);
    }

    var coordSystem = getCoordSystem();

    coordsTransform(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    coordsTransform(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (var i = 0; i < objNames.length; i++) {

        var objName = objNames[i];
        if (!objName) continue;

        var obj = getObjectByName(objName);
        if (!obj) continue;

        if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            var euler = eulerV3DToBlenderShortest(obj.rotation, _pGlob.eulerTmp);
            coordsTransform(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            var rotUI = RotationInterface.initObject(obj);
            var euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

        }

        obj.updateMatrixWorld(true);
    }

}


// Describe this function...
function MAKE_GRID_CUBE() {
  grid_Cube_color = 'teal';
  grid_Cube_Center_color = 'cyan';

          createGridHelper
          (
              10,
              10,
              grid_Cube_color,
              grid_Cube_Center_color
          )
      setObjTransform('gridHelper_1', 'rotation', ['', 90, ''], false);
  setObjTransform('gridHelper_1', 'position', [-5, '', 5], false);

          createGridHelper
          (
              10,
              10,
              grid_Cube_color,
              grid_Cube_Center_color
          )
      setObjTransform('gridHelper_2', 'rotation', ['', -90, -90], false);
  setObjTransform('gridHelper_2', 'position', ['', 5, 5], false);

          createGridHelper
          (
              10,
              10,
              grid_Cube_color,
              grid_Cube_Center_color
          )
      setObjTransform('Cube', 'position', ['', '', 1], false);
}


// createObject puzzle
function createObject(type, name, width, height, depth, radius, tube, segments, cameraType, lightType, fov) {

    var oldObj = appInstance.scene.getObjectByName(name);
    if (oldObj) {
        oldObj.parent.remove(oldObj);
    }

    var obj;
    var geometry;

    switch (type) {
        case 'BOX':
            geometry = new v3d.BoxGeometry(width, height, depth);
            break;
        case 'CAMERA':
            var aspect = appInstance.container.offsetWidth / appInstance.container.offsetHeight;

            if (cameraType == 'PERSPECTIVE') {

                obj = new v3d.PerspectiveCamera(fov, aspect, 1, 1000);

            } else {

                var width = fov * aspect;
                obj = new v3d.OrthographicCamera(-width/2, width/2, fov/2, -fov/2, -1000, 1000);

            }

            obj.lookAt(_pGlob.vec3Tmp.set(0, 0, 0));
            break;
        case 'CIRCLE':
            geometry = new v3d.CircleGeometry(radius, segments);
            break;
        case 'CONE':
            geometry = new v3d.ConeGeometry(radius, height, segments);
            break;
        case 'CYLINDER':
            geometry = new v3d.CylinderGeometry(radius, radius, height, segments);
            break;
        case 'EMPTY':
            obj = new v3d.Object3D();
            break;
        case 'LIGHT':
            var color = 0xffffff;
            var intensity = 0.5;

            switch (lightType) {
                case 'AMBIENT':
                    obj = new v3d.AmbientLight(color, intensity);
                    break;
                case 'AREA':
                    v3d.RectAreaLightUniformsLib.init(LTC_MAT_1, LTC_MAT_2);
                    obj = new v3d.RectAreaLight(color, intensity, 1, 1);
                    break;
                case 'DIRECTIONAL':
                    obj = new v3d.DirectionalLight(color, intensity);
                    break;
                case 'HEMISPHERE':
                    obj = new v3d.HemisphereLight(color, 0, intensity);
                    break;
                case 'POINT':
                    obj = new v3d.PointLight(color, intensity);
                    break;
                case 'SPOT':
                    obj = new v3d.SpotLight(color, intensity);
                    break;
            }

            obj.isFreeLight = true;

            break;
        case 'PLANE':
            geometry = new v3d.PlaneGeometry(width, height, 1, 1);
            break;
        case 'SPHERE':
            geometry = new v3d.SphereGeometry(radius, 32, 32);
            break;
        case 'TEAPOT':
            geometry = new v3d.TeapotGeometry(width);
            break;
        case 'TORUS':
            geometry = new v3d.TorusGeometry(radius, tube, 32, 32);
            break;
    }

    if (geometry) {
        var material = new v3d.MeshStandardMaterial({
            color: 'white',
            roughness: 1.0,
            metalness: 0.0,
            side: (type == 'CIRCLE' || type == 'PLANE' || type == 'TEAPOT') ? v3d.DoubleSide : v3d.FrontSide
        });

        material.name = name + 'Material';

        obj = new v3d.Mesh(geometry, material);
    }

    obj.name = name;

    appInstance.scene.add(obj);

    // clean object cache
    _pGlob.objCache = {};

}



// makeParent puzzle
function makeParent(objName, targetObjName) {
    if (!objName)
        return;
    var obj = getObjectByName(objName);
    if (!obj)
        return;
    if (targetObjName && targetObjName !== LIST_NONE) {
        var targetObj = getObjectByName(targetObjName);
        if (!targetObj)
            return;
    } else {
        obj.traverseAncestors(function(ancObj) {
            if (ancObj.type == "Scene")
                targetObj = ancObj;
        });
    }
    var matOffset = new v3d.Matrix4();
    matOffset.copy(targetObj.matrixWorld).invert();
    matOffset.multiply(obj.matrixWorld);
    matOffset.decompose(obj.position, obj.quaternion, obj.scale);
    targetObj.add(obj);

    obj.updateMatrixWorld(true);
}


// Describe this function...
function MAKE_TEAPOT() {
  createObject('TEAPOT', 'Teapot', 2, 0, 0, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
  createObject('TEAPOT', 'Teapot_transparent', 2, 0, 0, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
  makeParent('Teapot_transparent', 'Teapot');
  setObjTransform('Teapot', 'position', ['', '', 5], false);
}


function matGetColors(matName) {
    var mat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
    if (!mat)
        return [];

    if (mat.isMeshNodeMaterial)
        return Object.keys(mat.nodeRGBMap);
    else if (mat.isMeshStandardMaterial)
        return ['color', 'emissive'];
    else
        return [];
}



// setMaterialColor puzzle
function setMaterialColor(matName, colName, r, g, b, cssCode) {

    var colors = matGetColors(matName);

    if (colors.indexOf(colName) < 0)
        return;

    if (cssCode) {
        var color = new v3d.Color(cssCode);
        color.convertSRGBToLinear();
        r = color.r;
        g = color.g;
        b = color.b;
    }

    var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);

    for (var i = 0; i < mats.length; i++) {
        var mat = mats[i];

        if (mat.isMeshNodeMaterial) {
            var rgbIdx = mat.nodeRGBMap[colName];
            mat.nodeRGB[rgbIdx].x = r;
            mat.nodeRGB[rgbIdx].y = g;
            mat.nodeRGB[rgbIdx].z = b;
        } else {
            mat[colName].r = r;
            mat[colName].g = g;
            mat[colName].b = b;
        }
        mat.needsUpdate = true;

        if (appInstance.scene !== null) {
            if (mat === appInstance.scene.worldMaterial) {
                appInstance.updateEnvironment(mat);
            }
        }
    }
}



// getObjectMaterial puzzle
function getObjectMaterial(objSelector) {
    var objNames = retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (!obj)
            continue;

        obj = obj.resolveMultiMaterial()[0];

        if (obj.material && typeof obj.material.name == "string")
            return obj.material.name;
    }
    return '';
}



function setMaterialTransparency() {
    return (function
//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        matInput,
        opacity,
    )
    {
//________________________________________________________________________________
//  DECLARE VARIABLES

        const puzzleName = 'Set Material Transparency';
//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if ( !matInput || matInput == '<none>' ) {
            console.log('[ GLIFTEK ]: The',puzzleName, 'plugin puzzle is missing an input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  BEGIN mainFunction

        function mainFunction()
        {

//________________________________________________________________________________


            // CHECK for material name objOutputObjMatName in scene
            app.scene.traverse( function( node )
            {
                if ( node instanceof v3d.Mesh ) {
                    if (node.material.name == matInput)
                    {
                        // if ( node.material instanceof v3d.MeshNodeMaterial)
                        // {

                            // let hitbox_name = VARS['hitbox_name'];
                            // let hitbox_Obj = app.scene.getObjectByName(hitbox_name);
                            node.material.opacity = opacity;
                            node.material.transparent = true;
                            node.material.needsUpdate = true;
                        // }
                    }
                }
            });


//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}



function quadWireframe() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (   objInput,
        colorInput,
        segUinput,
        segVinput,
        isWireInput,
        wireWidthInput,
        wireColorInput
    )
    {   //  BEGIN Plug.provide Function
//________________________________________________________________________________
//  DECLARE VARIABLES
    let objInputObj;
//________________________________________________________________________________
//  NO INPUT ERROR CHECK

        if (
            !objInput ||
            //  objInput == '<none>' ||
            !colorInput ||
            !wireColorInput ||
            !segUinput ||
            !segVinput ||
            !wireWidthInput ||
            !wireColorInput
            )
        {
            console.log('Quad Material Puzzle missing input!');
        }   else    { mainFunction () };

//________________________________________________________________________________
//  MAIN FUNCTION

        function mainFunction()
        {
//________________________________________________________________________________
//  PUZZLE CORE CODE



            // let uniforms = {
            //     segU: {value: 8},
            //     segV: {value: 8},
            //     isWire: {value: false},
            //     wireWidthFactor: {value: 2},
            //     wireColor: {value: new THREE.Color(0x00f0ff)}
            // }

            let uniforms = {
                segU: {value: segUinput},
                segV: {value: segVinput},
                isWire: {value: isWireInput},
                wireWidthFactor: {value: wireWidthInput},
                wireColor: {value: new THREE.Color(wireColorInput)}
            }

            // let quadMaterial = new v3d.MeshNodeMaterial( {
            let quadMaterial = new THREE.MeshStandardMaterial( {
            /*   map: new THREE.TextureLoader().load("https://threejs.org/examples/textures/uv_grid_opengl.jpg"), */

            side: THREE.DoubleSide,
            onBeforeCompile: shader => {
                shader.uniforms.segU = uniforms.segU;
                shader.uniforms.segV = uniforms.segV;
                shader.uniforms.wireColor = uniforms.wireColor;
                shader.uniforms.isWire = uniforms.isWire;
                shader.uniforms.wireWidthFactor = uniforms.wireWidthFactor;

                shader.fragmentShader = `

                uniform float segU;
                uniform float segV;
                uniform vec3 wireColor;
                uniform float isWire;
                uniform float wireWidthFactor;

                ${shader.fragmentShader}
                `.replace(
                `#include <dithering_fragment>`,
                `#include <dithering_fragment>

                    // http://madebyevan.com/shaders/grid/
                    vec2 coord = vUv * vec2(segU, segV);

                    vec2 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);
                    float line = min(grid.x, grid.y) / wireWidthFactor;
                    line = 1.0 - min(line, 1.0);

                    if (isWire > 0.5 && line < 0.5) discard;
                    if (isWire > 0.5) gl_FragColor = vec4(0);
                    gl_FragColor = mix(gl_FragColor, vec4(wireColor, 1.0), line);
                `
                );
                //console.log(shader.fragmentShader);
            }
            });

            // quadMaterial.color = new THREE.Color(0x000000);
            quadMaterial.color = new THREE.Color(colorInput);
            quadMaterial.defines = {"USE_UV": ""};
            quadMaterial.opacity = 0;


            // const geometry = new THREE.TorusGeometry( 10, 3, 40, 72 );
            // torus = new v3d.Mesh( geometry, quadMaterial );

            objInputObj = app.scene.getObjectByName(objInput);
            objInputObj.material = quadMaterial;

            //app.scene.add( torus );

            //console.log('torus: ',torus);

            // let quadWinNameVar = (`const window.${objInputObj.name}_quadMaterialWin`);
            // console.log('quadWinNameVar: ',quadWinNameVar);
            // eval(quadWinNameVar = quadMaterial);

            window.quadMaterialWin = quadMaterial;
//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
// PUZZLE OUTPUT

        //  FOR OUTPUT TYPE PUZZLE RETURN
        // return objInputObj.material;
        return objInputObj;

//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function SET_MATERIALS() {
  COLOR_object_transparent = '#29293d';
  COLOR_object_wireframe = 'white';
  setMaterialColor('Teapot_transparentMaterial', 'color', 0, 0, 0, COLOR_object_transparent);

          setMaterialTransparency
          (
              getObjectMaterial('Teapot_transparent'),
              0.6
          );setMaterialColor('Torus_transparentMaterial', 'color', 0, 0, 0, COLOR_object_transparent);

          setMaterialTransparency
          (
              getObjectMaterial('Torus_transparent'),
              0.8
          );setMaterialColor('Box_transparentMaterial', 'color', 0, 0, 0, COLOR_object_transparent);

          setMaterialTransparency
          (
              getObjectMaterial('Box_transparent'),
              0.8
          );
      quadWireframe
      (
          'Teapot',
          'black',
          4,
          4,
          true,
          3,
          COLOR_object_wireframe
      )
      ;

      quadWireframe
      (
          'Torus',
          'black',
          8,
          8,
          true,
          3,
          COLOR_object_wireframe
      )
      ;

      quadWireframe
      (
          'Box',
          'black',
          4,
          4,
          true,
          3,
          COLOR_object_wireframe
      )
      ;
}

// Describe this function...
function MAKE_TORUS() {
  createObject('TORUS', 'Torus', 0, 0, 0, 2, 1, 0, 'PERSPECTIVE', 'AMBIENT', 0);
  createObject('TORUS', 'Torus_transparent', 0, 0, 0, 2, 1, 0, 'PERSPECTIVE', 'AMBIENT', 0);
  makeParent('Torus_transparent', 'Torus');
  setObjTransform('Torus', 'position', ['', '', 5], false);
  setObjTransform('Torus', 'rotation', [90, '', ''], false);
}


function createPolarGridHelper() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        radius,
        radials,
        circles,
        divisions,
        color1,
        color2
    )
    {   //  BEGIN Plug.provide Function

//________________________________________________________________________________
//  MAIN FUNCTION

        mainFunction();
        function mainFunction()
        {
//________________________________________________________________________________
//  PUZZLE CORE CODE


            if (typeof polarGridHelperNumber == 'undefined')

                { window.polarGridHelperNumber = 1 }

            else {  polarGridHelperNumber++ };



            let polarGridHelperParent = new v3d.Object3D();

            let polarGridHelper = new v3d.PolarGridHelper(radius, radials, circles, divisions, color1, color2);

            polarGridHelper.raycast = function() {};



            polarGridHelper.rotateX(v3d.Math.degToRad(-90));

            polarGridHelperParent.add(polarGridHelper);

            polarGridHelperParent.rotateX(v3d.Math.degToRad(-90));



            polarGridHelperParent.name = 'polarGridHelper_' + polarGridHelperNumber;

            app.scene.add(polarGridHelperParent);

//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function MAKE_GRID_POLAR() {

          createPolarGridHelper
          (
              5,
              8,
              6,
              64,
              'cyan',
              'cyan'
          )
      }

// Describe this function...
function MAKE_SPHERE() {
  createObject('SPHERE', 'Sphere', 0, 0, 0, 2, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
  setObjTransform('Sphere', 'position', ['', '', 5], false);
}


// createVector puzzle
function createVector(x, y, z) {
    return [x, y, z];
};



function createArrowHelper() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        dir,
        origin,
        length,
        hex,
        headLength,
        headWidth
    )
    {   //  BEGIN Plug.provide Function

//________________________________________________________________________________
//  MAIN FUNCTION

        mainFunction();
        function mainFunction()
        {
//________________________________________________________________________________
//  PUZZLE CORE CODE

            if (typeof arrowHelperNumber == 'undefined')

                { window.arrowHelperNumber = 1 }

            else {  arrowHelperNumber++ };



            const dirVar = new THREE.Vector3( dir[0],dir[1],dir[2] );

            //normalize the direction vector (convert to vector of length 1)
            dirVar.normalize();


            const originVar = new THREE.Vector3( origin[0],origin[1],origin[2] );


            let arrowHelper = new v3d.ArrowHelper(dirVar, originVar, length, hex);


            let arrowHelperParent = new v3d.Object3D();



            arrowHelperParent.add(arrowHelper);

            arrowHelperParent.rotateX(v3d.Math.degToRad(-90));



            arrowHelperParent.name = 'arrowHelper_' + arrowHelperNumber;

            app.scene.add(arrowHelperParent);



//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}



function createAxesHelper() {
    return (function

//________________________________________________________________________________
// ALL ARGUMENTS USED FROM INPUTS

    (
        axisSize
    )
    {   //  BEGIN Plug.provide Function

//________________________________________________________________________________
//  MAIN FUNCTION

        mainFunction();
        function mainFunction()
        {
//________________________________________________________________________________
//  PUZZLE CORE CODE

            if (typeof axesHelperNumber == 'undefined')

                { window.axesHelperNumber = 1 }

            else {  axesHelperNumber++ };



            let axesHelper = new v3d.AxesHelper(axisSize);

            axesHelper.raycast = function() {};



            let axesHelperParent = new v3d.Object3D();



            axesHelperParent.add(axesHelper);

            axesHelperParent.rotateX(v3d.Math.degToRad(-90));



            axesHelperParent.name = 'axesHelper_' + axesHelperNumber;

            app.scene.add(axesHelperParent);


//________________________________________________________________________________
        };  // END mainFunction
//________________________________________________________________________________
    }).apply(null, arguments);
}


// Describe this function...
function MAKE_OTHER_HELPERS() {

          createArrowHelper
          (
              createVector(0, -3, 0),
              createVector(0, 0, 0),
              3,
              '#4682B4',
              0.5,
              0.25
          )

          createAxesHelper
          (
              3
          )
      }

// Describe this function...
function MAKE_BOX() {
  createObject('BOX', 'Box', 4, 4, 4, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
  createObject('BOX', 'Box_transparent', 4, 4, 4, 0, 0, 0, 'PERSPECTIVE', 'AMBIENT', 0);
  makeParent('Box_transparent', 'Box');
  setObjTransform('Box', 'position', ['', '', 5], false);
}


'<none>';

MAIN();

'cyan';



} // end of PL.init function

})(); // end of closure

/* ================================ end of code ============================= */
